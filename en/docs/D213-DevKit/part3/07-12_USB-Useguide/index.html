<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-D213-DevKit/part3/07-12_USB-Useguide" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">USB 使用指南 | 东山Π</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://artinchip.100ask.net/en/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://artinchip.100ask.net/en/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://artinchip.100ask.net/en/docs/D213-DevKit/part3/07-12_USB-Useguide"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" property="og:locale:alternate" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="USB 使用指南 | 东山Π"><meta data-rh="true" name="description" content="1. 配置指南"><meta data-rh="true" property="og:description" content="1. 配置指南"><link data-rh="true" rel="icon" href="/en/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://artinchip.100ask.net/en/docs/D213-DevKit/part3/07-12_USB-Useguide"><link data-rh="true" rel="alternate" href="https://artinchip.100ask.net/docs/D213-DevKit/part3/07-12_USB-Useguide" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://artinchip.100ask.net/en/docs/D213-DevKit/part3/07-12_USB-Useguide" hreflang="en"><link data-rh="true" rel="alternate" href="https://artinchip.100ask.net/docs/D213-DevKit/part3/07-12_USB-Useguide" hreflang="x-default"><link rel="stylesheet" href="/en/assets/css/styles.d875fe7e.css">
<script src="/en/assets/js/runtime~main.992f447a.js" defer="defer"></script>
<script src="/en/assets/js/main.2e68fdc6.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/en/"><div class="navbar__logo"><img src="/en/img/logo.svg" alt="东山PI" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/en/img/logo.svg" alt="东山PI" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">东山Π</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/en/docs/D213-DevKit/BoardIntroduction">D213-DevKit</a><a class="navbar__item navbar__link" href="/en/docs/category/luban-sdk使用指南">Luban-SDK</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/docs/D213-DevKit/part3/07-12_USB-Useguide" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-Hans">简体中文</a></li><li><a href="/en/docs/D213-DevKit/part3/07-12_USB-Useguide" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en">English</a></li></ul></div><a href="https://github.com/100askTeam/ArtInChip-Docs" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/D213-DevKit/BoardIntroduction">匠心创D213-DevKit开发板</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/D213-DevKit/SupportingResources">源码工具文档手册</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/en/docs/category/快速启动">快速启动</a><button aria-label="Expand sidebar category &#x27;快速启动&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/en/docs/D213-DevKit/ConfigHostEnv">安装并配置开发环境</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/en/docs/category/luban-sdk开发">Luban-SDK开发</a><button aria-label="Expand sidebar category &#x27;Luban-SDK开发&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/en/docs/category/luban-linux系统开发">Luban-Linux系统开发</a><button aria-label="Collapse sidebar category &#x27;Luban-Linux系统开发&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-1_BWMUserGuide">BWM 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-2_CMUUserGuide">CMU 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-3_DMABook">DMA 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-4_RTCUserGuide">RTC 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-5_TSensorUserGuide">TSensor 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-6_WatchdogUserGuide">Watchdog 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/04-7_WRIUserGuide">WRI 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/05-1_SDMCUserGuide">SDMC 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/05-2_SPI_NANDUserGuide">SPI NAND 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/05-3_SPI_NORUserGuide">SPI NOR 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/05-4_FileSystemUserGuide">文件系统使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/06-1_GE-Useguide">GE 开发指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/06-2_VE-Useguide">VE 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/06-3_Display-Useguide">Display 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/06-4_DVP-Useguide">DVP开发指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/06-8_I2S-Useguide">I2S 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/06-9_AudioCodec-Useguide">AudioCodec 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-1_CAN-Useguide">CAN 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-2_ CIR-Useguide">CIR 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-3_ GPAI-Useguide">GPAI 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-4_I2C-Useguide">I2C 开发指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-5_MAC-Useguide">MAC 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-6_PBus-Useguide">PBus 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-7_PINCTRL-Useguide">PINCTRL 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-8_PWM-Useguide">PWM 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-9_RTP-Useguide">RTP 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-10_SPI-Useguide">SPI 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-11_UART-Useguide">UART 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/en/docs/D213-DevKit/part3/07-12_USB-Useguide">USB 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/07-13_PSADC-Useguide">PSADC 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/08-1_SPI-ENC">SPI ENC</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/08-2_CE-Useguide">CE 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/08-3_eFuse-Useguide">eFuse 使用指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/08-4_HardwareAuthorizationCertification">硬件授权认证</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/10-1_TouchscreenDebuggingGuide">触摸屏调试指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/10-2_DisplayDebuggingGuide">显示屏调试指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/10-3_WiFiDebuggingGuide">WiFi调试指南</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/en/docs/D213-DevKit/part3/10-4_GuideToUsingTheKeyMatrix">按键矩阵使用指南</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/en/docs/category/linux-bringup参考">Linux-Bringup参考</a><button aria-label="Expand sidebar category &#x27;Linux-Bringup参考&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/en/docs/category/linux-uboot开发">Linux-Uboot开发</a><button aria-label="Expand sidebar category &#x27;Linux-Uboot开发&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/en/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/en/docs/category/luban-linux系统开发"><span itemprop="name">Luban-Linux系统开发</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">USB 使用指南</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>USB 使用指南</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-配置指南">1. 配置指南<a href="#1-配置指南" class="hash-link" aria-label="Direct link to 1. 配置指南" title="Direct link to 1. 配置指南">​</a></h2>
<p>ArtinChip 提供了 2 路 USB Host 端口 和 1 路 USB Device 端口，需要分别进行配置。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="11-usb-host-配置">1.1. USB Host 配置<a href="#11-usb-host-配置" class="hash-link" aria-label="Direct link to 1.1. USB Host 配置" title="Direct link to 1.1. USB Host 配置">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="111-usb-host-controller-配置">1.1.1. USB Host Controller 配置<a href="#111-usb-host-controller-配置" class="hash-link" aria-label="Direct link to 1.1.1. USB Host Controller 配置" title="Direct link to 1.1.1. USB Host Controller 配置">​</a></h4>
<p>首先需要配置好 USB Host Contoller ，ArtinChip 在 1 个 USB Host 端口中提供了 2 类 Host Contoller：</p>
<ul>
<li>针对 USB 2.0 (High Speed) 的 EHCI 控制器</li>
<li>针对 USB 1.0/1.1 (Low/Full Speed) 的 OHCI 控制器</li>
</ul>
<p>在软件上需要需要分开配置。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1111-ehci-配置">1.1.1.1. EHCI 配置<a href="#1111-ehci-配置" class="hash-link" aria-label="Direct link to 1.1.1.1. EHCI 配置" title="Direct link to 1.1.1.1. EHCI 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中使能相应 EHCI Driver：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   EHCI HCD (USB 2.0) support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Root Hub Transaction Translators</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Improved Transaction Translator scheduling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;     Support for Artinchip on-chip EHCI USB controller</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>注解</p>
<p>内核配置主要是通过 <code>make menuconfig</code> 命令进行kernel的功能选择，配置完成后的项目存储在 <code>target/configs/xxx_defconfig</code> 文件中。</p>
<ul>
<li>DTS 文件中配置相应 EHCI Device:</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usbh0: usb@10210000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compatible = &quot;artinchip,aic-usbh-v1.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg = &lt;0x0 0x10210000 0x0 0x100&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interrupts-extended = &lt;&amp;plic0 35 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;&amp;plic0 4 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clocks = &lt;&amp;cmu CLK_USBH0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock-names = &quot;usbh&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resets = &lt;&amp;rst RESET_USBH0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reset-names = &quot;usbh&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dr_mode = &quot;host&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usbh1: usb@10220000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compatible = &quot;artinchip,aic-usbh-v1.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg = &lt;0x0 0x10220000 0x0 0x100&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interrupts-extended = &lt;&amp;plic0 37 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &lt;&amp;plic0 38 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clocks = &lt;&amp;cmu CLK_USBH1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock-names = &quot;usbh&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resets = &lt;&amp;rst RESET_USBH1&gt;, &lt;&amp;rst RESET_USBPHY1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reset-names = &quot;usbh&quot;, &quot;usbh-phy&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dr_mode = &quot;host&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>注解</p>
<p>这些参数主要在文件 <code>target/d211/common/d211.dtsi</code> 中，模块系统参数随 IC 的设定而定，一般不能进行更改，除非更换了新的 IC，则需要在专业人士的指导下进行更改。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1112-ohci-配置">1.1.1.2. OHCI 配置<a href="#1112-ohci-配置" class="hash-link" aria-label="Direct link to 1.1.1.2. OHCI 配置" title="Direct link to 1.1.1.2. OHCI 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中使能相应 EHCI Driver：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   OHCI HCD (USB 1.1) support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;     Support for Artinchip on-chip OHCI USB controller</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>DTS 文件中配置相应 EHCI Device:</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ohci0: usb@10210400 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compatible = &quot;artinchip,aic-ohci-v1.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg = &lt;0x10210400 0x100&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interrupts = &lt;&amp;plic0 4 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    num-ports = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ohci1: usb@10220400 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compatible = &quot;artinchip,aic-ohci-v1.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg = &lt;0x10220400 0x100&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interrupts = &lt;&amp;plic0 6 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="112-usb-interface-驱动配置">1.1.2. USB Interface 驱动配置<a href="#112-usb-interface-驱动配置" class="hash-link" aria-label="Direct link to 1.1.2. USB Interface 驱动配置" title="Direct link to 1.1.2. USB Interface 驱动配置">​</a></h4>
<p>在配置好 USB Host Controller 以后，就能够正确识别插入 USB 总线的 Device 设备了。</p>
<p>但是 USB Device 有很多不同类型 (例如：U 盘、键盘鼠标、无线网卡 …) ，这些功能都是在 USB Device 中以 Interface 为单位提供的。所以要使用 USB Device 的具体功能，还需要配置不同类型 USB Interface 的驱动。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1121-u-盘-配置">1.1.2.1. U 盘 配置<a href="#1121-u-盘-配置" class="hash-link" aria-label="Direct link to 1.1.2.1. U 盘 配置" title="Direct link to 1.1.2.1. U 盘 配置">​</a></h5>
<ul>
<li>U 盘是 USB 2.0 设备，所以首先得配置好上节中的 EHCI，再进行下面的配置。</li>
<li>在 Linux Kernel Kconfig 中使能对 USB Mass Storage 类型的 USB Interface 驱动的支持。</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Mass Storage support</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>还需要使能其他相关配置：</li>
</ul>
<p>块设备：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] Block devices  ---&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>SCSI 设备：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; SCSI device support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt; SCSI device support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] legacy /proc/scsi/ support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *** SCSI support type (disk, tape, CD-ROM) ***</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt; SCSI disk support</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>文件系统：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; File systems &gt; DOS/FAT/EXFAT/NT Filesystems</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt; VFAT (Windows-95) fs support</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>插入 U 盘，通过 <code>mount</code> 命令将 U 盘挂载到合适的目录下就可以操作了：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1591.469696] usb 1-1: new high-speed USB device number 3 using aic-ehci</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1591.674435] usb-storage 1-1:1.0: USB Mass Storage device detected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1591.682567] scsi host0: usb-storage 1-1:1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1592.692021] scsi 0:0:0:0: Direct-Access     SanDisk  Cruzer Blade     1.00 PQ: 0 ANSI: 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1592.714329] sd 0:0:0:0: [sda] 30842880 512-byte logical blocks: (15.8 GB/14.7 GiB)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1592.724171] sd 0:0:0:0: [sda] Write Protect is off</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1592.730166] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn&#x27;t support DPO or FUA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1592.751720]  sda: sda1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 1592.768330] sd 0:0:0:0: [sda] Attached SCSI removable disk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # mount -t vfat /dev/sda1 /mnt/u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # ls /mnt/u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System Volume Information  u-boot-spl-dtb.bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">u-boot-dtb.bin             vmlinux</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">u-boot-dtb.img             zImage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">u-boot-spl-dtb.aic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1122-usb-键盘鼠标-配置">1.1.2.2. USB 键盘/鼠标 配置<a href="#1122-usb-键盘鼠标-配置" class="hash-link" aria-label="Direct link to 1.1.2.2. USB 键盘/鼠标 配置" title="Direct link to 1.1.2.2. USB 键盘/鼠标 配置">​</a></h5>
<ul>
<li>U 盘是 USB 1.0/1.1 设备，所以首先得配置好上节中的 OHCI，再进行下面的配置。</li>
<li>在 Linux Kernel Kconfig 中使能对 USB HID 类型的 USB Interface 驱动的支持。</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; HID support &gt; USB HID support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt; USB HID transport layer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>插入键盘鼠标，可以通过 <code>/dev/input/event</code> 文件读取到键盘鼠标上报的数据：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   14.210983] usb 2-1: new low-speed USB device number 2 using aic-ohci</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   14.478006] random: fast init done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   14.497013] input: PixArt Dell MS116 USB Optical Mouse as /devices/platform/soc/10220400.usb/usb2/2-1/2-1:1.0/0003:413C:301A.0001/input/input2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   14.510871] hid-generic 0003:413C:301A.0001: input: USB HID v1.11 Mouse [PixArt Dell MS116 USB Optical Mouse] on usb-10220400.usb-1/input0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # hexdump /dev/input/event2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000000 e138 5e0b 4c30 0004 0004 0004 0001 0009</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000010 e138 5e0b 4c30 0004 0001 0110 0001 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000020 e138 5e0b 4c30 0004 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000030 e138 5e0b d657 0007 0004 0004 0001 0009</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000040 e138 5e0b d657 0007 0001 0110 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000050 e138 5e0b d657 0007 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000060 e139 5e0b 9085 0003 0004 0004 0001 0009</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000070 e139 5e0b 9085 0003 0001 0110 0001 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000080 e139 5e0b 9085 0003 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000090 e139 5e0b a3bc 0005 0004 0004 0001 0009</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">00000a0 e139 5e0b a3bc 0005 0001 0110 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">00000b0 e139 5e0b a3bc 0005 0000 0000 0000 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="12-usb-device-配置">1.2. USB Device 配置<a href="#12-usb-device-配置" class="hash-link" aria-label="Direct link to 1.2. USB Device 配置" title="Direct link to 1.2. USB Device 配置">​</a></h3>
<p>首先要配置好 USB Device Controller。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="121-usb-device-controller-配置">1.2.1. USB Device Controller 配置<a href="#121-usb-device-controller-配置" class="hash-link" aria-label="Direct link to 1.2.1. USB Device Controller 配置" title="Direct link to 1.2.1. USB Device Controller 配置">​</a></h4>
<ul>
<li>Linux Kernel Kconfig 文件中使能相应 UDC Driver：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support &gt; USB Peripheral Controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt; ArtinChip USB2.0 Device Controller</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>DTS 文件中配置相应 UDC Device:</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">aicudc: udc@10200000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compatible = &quot;artinchip,aic-udc-v1.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reg = &lt;0x0 0x10200000 0x0 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interrupts-extended = &lt;&amp;plic0 34 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clocks = &lt;&amp;cmu CLK_USBD&gt;, &lt;&amp;cmu CLK_USB_PHY0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    clock-names = &quot;udc_clk&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resets = &lt;&amp;rst RESET_USBD&gt;, &lt;&amp;rst RESET_USBPHY0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reset-names = &quot;aicudc&quot;, &quot;aicudc-ecc&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="122-usb-gadget-配置">1.2.2. USB Gadget 配置<a href="#122-usb-gadget-配置" class="hash-link" aria-label="Direct link to 1.2.2. USB Gadget 配置" title="Direct link to 1.2.2. USB Gadget 配置">​</a></h4>
<p>为了方便 Linux 系统模拟成各种类型的 USB Device，Linux 设计了一个 <code>Gadget Device</code> 。为了方便用户使用 ，Linux 又将 <code>ConfigFS</code> 引入 USB Device 子系统，用来灵活配置 <code>Gadget Device</code>。</p>
<p>所以在使用 USB Device 时，在 Linux Kernel 中把这两者都配置成使能。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1221-gadget-配置">1.2.2.1. Gadget 配置<a href="#1221-gadget-配置" class="hash-link" aria-label="Direct link to 1.2.2.1. Gadget 配置" title="Direct link to 1.2.2.1. Gadget 配置">​</a></h5>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget Support  ---&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1222-configfs-配置">1.2.2.2. ConfigFS 配置<a href="#1222-configfs-配置" class="hash-link" aria-label="Direct link to 1.2.2.2. ConfigFS 配置" title="Direct link to 1.2.2.2. ConfigFS 配置">​</a></h5>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget functions configurable through configfs</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="123-usb-interface-配置">1.2.3. USB Interface 配置<a href="#123-usb-interface-配置" class="hash-link" aria-label="Direct link to 1.2.3. USB Interface 配置" title="Direct link to 1.2.3. USB Interface 配置">​</a></h4>
<p>在 <code>Gadget Device</code> 基础之上，需要配置具体的 <code>Interface / Function</code> 才能提供具体的 USB Device 功能。</p>
<p>USB Gadget Device 可以模拟成各种功能的 USB 外设，例如：USB 串口、USB 网口、U 盘。。。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1231-acm-串口-配置">1.2.3.1. ACM 串口 配置<a href="#1231-acm-串口-配置" class="hash-link" aria-label="Direct link to 1.2.3.1. ACM 串口 配置" title="Direct link to 1.2.3.1. ACM 串口 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中使能 <code>CDC ACM</code> 类型的 <code>Gadget functions</code> ：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget functions configurable through configfs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Abstract Control Model (CDC ACM)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] Block devices  ---&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>通过用户态的 configfs 文件接口创建包含 <code>ACM</code> 串口功能的 USB Device：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x1d6b&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x0104&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls strings/0x409/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;AIC Inc.&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Bar Gadget&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/acm.GS0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls configs/c.1/strings/0x409/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;ACM&quot; &gt; configs/c.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/acm.GS0 configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo `ls /sys/class/udc` &gt; UDC</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>
<p>用户使用：</p>
<blockquote>
<ol>
<li>
<p>将单板的 USB Device 端口和 Windows PC 的 USB Host 端口连接，在 Windows PC 设备管理器会看到一个新的USB串口节点：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/serial_win_res-17067633659793.png" alt="image0" class="img_ev3q"></p>
</li>
<li>
<p>在 PC 端使用串口终端工具打开 COM12，波特率使用 115200。</p>
</li>
<li>
<p>在单板端执行： <code>echo abd &gt; /dev/ttyGS0</code> ，在 PC 端串口就会收到该字符串：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/serial_win_term-17067633720245.png" alt="image1" class="img_ev3q"></p>
</li>
<li>
<p>在单板端执行 <code>cat /dev/ttyGS0</code> ，在 PC 端写一个字符串 “123412345” ，点回车后，在单板端也能收到该字符串。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1232-u-盘-配置">1.2.3.2. U 盘 配置<a href="#1232-u-盘-配置" class="hash-link" aria-label="Direct link to 1.2.3.2. U 盘 配置" title="Direct link to 1.2.3.2. U 盘 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中 ：</li>
</ul>
<p>使能 <code>Mass storage</code> 类型的 <code>Gadget functions</code> ：:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget functions configurable through configfs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Mass storage</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>使能环回块设备：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   Loopback device support</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>Busybox 中使能 <code>losetup</code> 命令：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt;  Linux System Utilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] losetup (5.5 kb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>通过用户态的 configfs 文件接口创建包含 <code>Mass storage</code> 存储功能的 USB Device：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dd if=/dev/zero of=/tmp/mass.img bs=128K count=132</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">losetup /dev/loop0 /tmp/mass.img</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir /tmp/media</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkfs.vfat /dev/loop0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mount -t vfat /dev/loop0 /tmp/media/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cp /linuxrc /tmp/media</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sync</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g_mass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x200&quot; &gt; bcdUSB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x100&quot; &gt; bcdDevice</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x1234&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x5678&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/mass_storage.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo /dev/loop0 &gt; functions/mass_storage.0/lun.0/file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789ABCDEF&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;river&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;river_msc&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c1.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;abc&quot; &gt; configs/c1.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/mass_storage.0 configs/c1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo `ls /sys/class/udc` &gt; UDC</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>
<p>用户使用：</p>
<blockquote>
<ol>
<li>将单板的 USB Device 端口和 Windows PC 的 USB Host 端口连接，在 Windows PC 上会看到一个新增的 U 盘，可以正常读写。</li>
</ol>
</blockquote>
</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1233-ncm-网口-配置">1.2.3.3. NCM 网口 配置<a href="#1233-ncm-网口-配置" class="hash-link" aria-label="Direct link to 1.2.3.3. NCM 网口 配置" title="Direct link to 1.2.3.3. NCM 网口 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中 ：</li>
</ul>
<p>使能 <code>CDC NCM</code> 类型的 <code>Gadget functions</code> ：:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget functions configurable through configfs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Network Control Model (CDC NCM)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>使能 TCP/IP 支持：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Networking support &gt; Networking options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] TCP/IP networking</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>通过用户态的 configfs 文件接口创建包含 <code>CDC NCM</code> 以太网功能的 USB Device：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g_ncm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g_ncm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0xA55A&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x0111&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Xyz Inc.&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;NCM gadget&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/ncm.usb0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;NCM&quot; &gt; configs/c.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/ncm.usb0 configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo `ls /sys/class/udc` &gt; UDC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ifconfig usb0 up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ifconfig usb0 173.11.1.1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>
<p>用户使用：</p>
<blockquote>
<ol>
<li>
<p>将单板的 USB Device 端口和 Ubuntu PC 的 USB Host 端口连接，在 Ubuntu PC 会看到一个新的网络接口，名字随机，类似： <code>enx0afcc15d3417</code> 。</p>
</li>
<li>
<p>配置 Ubuntu PC 端的网口为同一网段地址， <code>sudo ifconfig enx0afcc15d3417 173.11.1.2</code>。</p>
</li>
<li>
<p>两个网口相互可以 ping 通：</p>
</li>
</ol>
<blockquote>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ubuntu@ubuntu $ ping 173.11.1.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PING 173.11.1.1 (173.11.1.1) 56(84) bytes of data.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64 bytes from 173.11.1.1: icmp_seq=1 ttl=64 time=10.3 ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64 bytes from 173.11.1.1: icmp_seq=2 ttl=64 time=5.02 ms</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
</blockquote>
</blockquote>
</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1234-ecm-网口-配置">1.2.3.4. ECM 网口 配置<a href="#1234-ecm-网口-配置" class="hash-link" aria-label="Direct link to 1.2.3.4. ECM 网口 配置" title="Direct link to 1.2.3.4. ECM 网口 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中 ：</li>
</ul>
<p>使能 <code>CDC ECM</code> 类型的 <code>Gadget functions</code> ：:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget functions configurable through configfs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Ethernet Control Model (CDC ECM)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>使能 TCP/IP 支持：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Networking support &gt; Networking options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] TCP/IP networking</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>通过用户态  的 configfs 文件接口创建包含 <code>CDC ECM</code> 以太网功能的 USB Device：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g_ecm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g_ecm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x1d6b&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x0104&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;AIC Inc.&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Bar Gadget&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/ecm.usb0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;ECM&quot; &gt; configs/c.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/ecm.usb0 configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo `ls /sys/class/udc` &gt; UDC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ifconfig usb0 up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ifconfig usb0 173.11.1.1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>用户使用：和上一节 NCM 网口 一样。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="1235-adbd-配置">1.2.3.5. ADBD 配置<a href="#1235-adbd-配置" class="hash-link" aria-label="Direct link to 1.2.3.5. ADBD 配置" title="Direct link to 1.2.3.5. ADBD 配置">​</a></h5>
<ul>
<li>Linux Kernel Kconfig 文件中 ：</li>
</ul>
<p>使能 <code>FunctionFS</code> 类型的 <code>Gadget functions</code> ：:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support &gt; USB Gadget Support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Gadget functions configurable through configfs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*]     Function filesystem (FunctionFS)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>使能 TCP/IP 支持：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Networking support &gt; Networking options</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> [*] TCP/IP networking</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>通过用户态的 configfs 文件接口创建 <code>FunctionFS</code> 中的 USB Device，挂载完 FunctionFS 文件系统以后， <code>adbd</code> 通过 <code>/dev/usb-ffs/adb</code> 中映射成文件的 endpoint 直接和 USB Host 进行通讯：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mkdir /dev/pts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mount -t devpts none /dev/pts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g_adb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g_adb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x18d1&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x4e26&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/ffs.adb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789ABCDEF&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;AIC Inc.&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;FunctionFS gadget (adb)&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Conf 1&quot; &gt; configs/c.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo 120 &gt; configs/c.1/MaxPower</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/ffs.adb configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir -p /dev/usb-ffs/adb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mount -o uid=2000,gid=2000 -t functionfs adb /dev/usb-ffs/adb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ifconfig lo up</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ifconfig</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /root</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">adbd&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sleep 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo `ls /sys/class/udc/` &gt; /sys/kernel/config/usb_gadget/g_adb/UDC</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>
<p>用户使用：</p>
<blockquote>
<ol>
<li>将单板的 USB Device 端口和 PC 的 USB Host 端口连接，在 PC 端运行 <code>adb shell</code> 命令即可进行 adb 操作。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="13-usb-otg-配置">1.3. USB OTG 配置<a href="#13-usb-otg-配置" class="hash-link" aria-label="Direct link to 1.3. USB OTG 配置" title="Direct link to 1.3. USB OTG 配置">​</a></h3>
<p>USB Host 0 和 USB Device 0 共享 1 路 phy。要么同时只能启用其中一种功能，要么启用 USB OTG 功能通过 <code>id</code> 管脚的值来动态切 换对外功能。</p>
<ul>
<li>Linux Kernel Kconfig 文件中使能相应 OTG Driver：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  [*]   OTG support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  [*]     Support for Artinchip on-chip OTG Switch</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>DTS 文件中配置相应 OTG Device:</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">otg: usb-otg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    compatible = &quot;artinchip,aic-otg-v2.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&amp;otg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    otg-mode = &quot;auto&quot;;      //  = auto/host/device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    id-gpios = &lt;&amp;gpio_f 15 GPIO_ACTIVE_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vbus-en-gpios = &lt;&amp;gpio_a 7 GPIO_ACTIVE_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dp-sw-gpios = &lt;&amp;gpio_e 14 GPIO_ACTIVE_LOW&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="131-otg-模式配置">1.3.1. OTG 模式配置<a href="#131-otg-模式配置" class="hash-link" aria-label="Direct link to 1.3.1. OTG 模式配置" title="Direct link to 1.3.1. OTG 模式配置">​</a></h4>
<p>OTG 可以配置成 <code>Auto 模式</code> 或者 <code>Force 模式</code> ：</p>
<ul>
<li><code>Auto 模式</code>。根据 <code>id</code> 管脚的电平来决定当前 OTG 端口工作模式为 <code>Host</code> / <code>Device</code> ，通常情况下 <code>id = low</code> 对应 <code>Host</code> 模式， <code>id = high</code> 对应 <code>Device</code> 模式。</li>
<li><code>Force 模式</code>。手工配置工作模式，通过配置 <code>/sys/devices/platform/soc/soc\:usb-otg/otg_mode</code> 文件节点的值来改变当前 OTG 端口的工作模式， <code>host</code> 对应 <code>Host</code> 模式， <code>device</code> 对应 <code>Device</code> 模式。另外 <code>auto</code> 对应 <code>Auto</code> 模式，需要使用 <code>id</code> 管脚来进行判断。</li>
</ul>
<p>两种模式对应 DTS 文件中的 <code>otg</code> 节点的不同配置：</p>
<table><thead><tr><th>Mode</th><th>DTS <code>otg-mode</code> 属性</th><th>DTS <code>xxx-gpios</code> 属性</th><th>运行时 <code>Host</code> / <code>Device</code> 切换方法</th></tr></thead><tbody><tr><td>Auto</td><td><code>otg-mode = &quot;auto&quot;;</code> (如果没有配置 <code>otg-mode</code> 属性, 默认也是 Auto 模式)</td><td><code>id-gpios</code> 属性必须配置； <code>vbus-en-gpios</code> 和 <code>dp-sw-gpios</code> 属性根据硬件配置选配。</td><td>OTG 驱动根据 <code>id-gpios</code> 管脚的电平变化 自动切换 USB 工作模式为 <code>Host</code> / <code>Device</code>。</td></tr><tr><td>Force</td><td><code>otg-mode = &quot;device&quot;;</code> 或者 <code>otg-mode = &quot;host&quot;;</code></td><td><code>id-gpios</code> 属性不需要配置； <code>vbus-en-gpios</code> 和 <code>dp-sw-gpios</code> 属性根据硬件配置选配。</td><td>需要配置文件节点来手工切换： <code>echo devices &gt; /sys/devices/platform/soc/soc\:usb-otg/otg_mode</code> 或者 <code>echo host &gt; /sys/devices/platform/soc/soc\:usb-otg/otg_mode</code></td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="132-otg-相关-gpio">1.3.2. OTG 相关 GPIO<a href="#132-otg-相关-gpio" class="hash-link" aria-label="Direct link to 1.3.2. OTG 相关 GPIO" title="Direct link to 1.3.2. OTG 相关 GPIO">​</a></h4>
<p>从上面配置可以看到和 OTG 功能相关的 GPIO 管脚有 3 个：</p>
<ul>
<li>
<p><code>id-gpios</code> 。用来检测当前插入的是不是 OTG 线，如果为 OTG 线则需要把本机切换到 USB Host 模式，否则本机切换到 USB Device 模式。该管脚在 <code>Auto 模式</code> 模式下是必须配置的，如果缺少该管脚 OTG 只能工作在 <code>Force 模式</code> 手工进行切换。</p>
</li>
<li>
<p><code>vbus-en-gpios</code> 。该管脚是用来控制 VBUS 的 5V 输出的，通常情况下：切换到 USB Host 模式时需要使能本机端的 VBUS 5V 输出给对端 Device 供电，切换到 USB Device 模式时需要关闭本机端的 VBUS 5V 输出转而对端 Host 的供电。（实际使用上来说，不论本端是 Host/Device 模式，也可以在 VBUS 上一直供电 5V 两边 VBUS 无压差则无漏电，这种情况下 <code>vbus-en-gpios</code> 无需配置。）</p>
</li>
<li>
<p><code>dp-sw-gpios</code> 。该管脚是在 OTG 外出两个独立 Host、Device 端口时，用来控制外部 Switch 的。非该模式时， <code>dp-sw-gpios</code> 无需配置。</p>
<blockquote>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/otg_gpio-17067633468021.png" alt="image2" class="img_ev3q"></p>
</blockquote>
</li>
</ul>
<p>3 个 GPIO 管脚的具体使用场景如上图所示，用户根据自己的使用场景来选择配置哪些 GPIO。每个 GPIO 的 输入输出正反电平有效，可以通过 DTS 中的 <code>GPIO_ACTIVE_HIGH</code> 和 <code>GPIO_ACTIVE_LOW</code> 来配置：</p>
<table><thead><tr><th>GPIO Name</th><th>Direction</th><th>GPIO_ACTIVE_HIGH</th><th>GPIO_ACTIVE_LOW</th></tr></thead><tbody><tr><td><code>id-gpios</code></td><td>input</td><td>输入低电平 = Host，输入高电平 = Device</td><td>输入低电平 = Device，输入高电平 = Host</td></tr><tr><td><code>vbus-en-gpios</code></td><td>output</td><td>Host (VBUS on) = 输出高电平Device (VBUS off) = 输出低电平</td><td>Host (VBUS on) = 输出低电平Device (VBUS off) = 输出高电平</td></tr><tr><td><code>dp-sw-gpios</code></td><td>output</td><td>Host = 输出高电平Device = 输出低电平</td><td>Host = 低电平Device = 高电平</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-调试指南">2. 调试指南<a href="#2-调试指南" class="hash-link" aria-label="Direct link to 2. 调试指南" title="Direct link to 2. 调试指南">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="21-usb-host-调试">2.1. USB Host 调试<a href="#21-usb-host-调试" class="hash-link" aria-label="Direct link to 2.1. USB Host 调试" title="Direct link to 2.1. USB Host 调试">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="211-查看-usb-设备">2.1.1. 查看 USB 设备<a href="#211-查看-usb-设备" class="hash-link" aria-label="Direct link to 2.1.1. 查看 USB 设备" title="Direct link to 2.1.1. 查看 USB 设备">​</a></h4>
<p>在单板的 USB Host 端口有设备插入或者拔出时，单板串口会有打印提示：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6792.678130] usb 1-1: new high-speed USB device number 2 using aic-ehci</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6792.884601] usb-storage 1-1:1.0: USB Mass Storage device detected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6792.910596] scsi host0: usb-storage 1-1:1.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6793.970429] scsi 0:0:0:0: Direct-Access     SanDisk  Cruzer Blade     1.00 PQ: 0 ANSI: 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6793.995300] sd 0:0:0:0: [sda] 30842880 512-byte logical blocks: (15.8 GB/14.7 GiB)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6794.018466] sd 0:0:0:0: [sda] Write Protect is off</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6794.025383] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn&#x27;t support DPO or FUA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6794.055267]  sda: sda1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6794.074720] sd 0:0:0:0: [sda] Attached SCSI removable disk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[ 6806.436142] usb 1-1: USB disconnect, device number 2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>也可以使用 <code>lsusb</code> 命令查看目前系统 USB 总线的情况：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # lsusb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bus 001 Device 001: ID 1d6b:0002</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bus 001 Device 003: ID 0781:5567</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果是 PC 上的 Linux 发行版， <code>lsusb -v</code> 命令可以查看 USB 设备的详细信息。但是单板上使用的 <code>lsusb -v</code> 被进行了简化。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="212-sysfs-节点">2.1.2. Sysfs 节点<a href="#212-sysfs-节点" class="hash-link" aria-label="Direct link to 2.1.2. Sysfs 节点" title="Direct link to 2.1.2. Sysfs 节点">​</a></h4>
<p>也可以使用 <code>/sys/kernel/debug/usb/devices</code> 文件节点查看 USB 设备的详细信息：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # mount -t debugfs none /sys/kernel/debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # cat /sys/kernel/debug/usb/devices</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T:  Bus=01 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480  MxCh= 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">B:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">D:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">P:  Vendor=1d6b ProdID=0002 Rev= 5.10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Manufacturer=Linux 5.10.44-00071-g935288d48127-dirty ehci_hcd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Product=EHCI Host Controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  SerialNumber=10220000.usb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="213-usb-总线分析仪">2.1.3. USB 总线分析仪<a href="#213-usb-总线分析仪" class="hash-link" aria-label="Direct link to 2.1.3. USB 总线分析仪" title="Direct link to 2.1.3. USB 总线分析仪">​</a></h4>
<p>在 USB 设备不能正常枚举或者 USB 通讯过程中出现问题时，我们一般使用 USB 总线分析仪，接入到 USB 总线上进行旁路抓包分析。</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_analy_instrument-17067634244437.png" alt="image0" class="img_ev3q"></p>
<p>抓包数据的分析界面如下图所示：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_analy_ui-17067634311569.png" alt="image1" class="img_ev3q"></p>
<p>USB 总线分析仪对抓取的数据包进行了解析，用起来非常方便。市面上这类仪器大同小异，非常容易上手。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="214-usbmon">2.1.4. usbmon<a href="#214-usbmon" class="hash-link" aria-label="Direct link to 2.1.4. usbmon" title="Direct link to 2.1.4. usbmon">​</a></h4>
<p>在没有外部 USB 分析仪的情况下，也可以使用 Linux 内核自带的 USB 抓包模块 usbmon 来抓取数据包进行分析。</p>
<ul>
<li>首先得打开 Linux 内核中的 usbmon 配置：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&gt; Device Drivers &gt; USB support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> &lt;*&gt;   USB Monitor</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>重新编译内核后就可以进行抓包了：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # mount -t debugfs none /sys/kernel/debug</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # ls /sys/kernel/debug/usb/usbmon/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0s  0u  1s  1t  1u  2s  2t  2u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # cat /sys/kernel/debug/usb/usbmon/0u</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c1b0e380 68846726 C Ii:1:001:1 0:2048 1 = 02</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c1b0e380 68846851 S Ii:1:001:1 -115:2048 4 &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68847426 S Ci:1:001:0 s a3 00 0000 0001 0004 4 &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68847507 C Ci:1:001:0 0 4 = 01050100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68847595 S Co:1:001:0 s 23 01 0010 0001 0000 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68847652 C Co:1:001:0 0 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68847732 S Ci:1:001:0 s a3 00 0000 0001 0004 4 &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68847790 C Ci:1:001:0 0 4 = 01050000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68890082 S Ci:1:001:0 s a3 00 0000 0001 0004 4 &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68890154 C Ci:1:001:0 0 4 = 01050000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68940072 S Ci:1:001:0 s a3 00 0000 0001 0004 4 &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68940142 C Ci:1:001:0 0 4 = 01050000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68990067 S Ci:1:001:0 s a3 00 0000 0001 0004 4 &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c7a15900 68990129 C Ci:1:001:0 0 4 = 01050000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="22-usb-device-调试">2.2. USB Device 调试<a href="#22-usb-device-调试" class="hash-link" aria-label="Direct link to 2.2. USB Device 调试" title="Direct link to 2.2. USB Device 调试">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="221-查看-usb-设备">2.2.1. 查看 USB 设备<a href="#221-查看-usb-设备" class="hash-link" aria-label="Direct link to 2.2.1. 查看 USB 设备" title="Direct link to 2.2.1. 查看 USB 设备">​</a></h4>
<p>当单板充当 USB Device 连接到 PC 主机 USB Host 端口时，可以在主机上查看 USB 设备有没有成功被枚举：</p>
<ul>
<li>
<p>Linux 主机，可以通过 <code>lsusb</code> 命令进行查看。</p>
</li>
<li>
<p>Windows 主机，可以通过 <code>设备管理器</code> 命令进行查看：</p>
<blockquote>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/dev_manager-170676345576411.png" alt="image2" class="img_ev3q"></p>
</blockquote>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="222-sysfs-节点">2.2.2. Sysfs 节点<a href="#222-sysfs-节点" class="hash-link" aria-label="Direct link to 2.2.2. Sysfs 节点" title="Direct link to 2.2.2. Sysfs 节点">​</a></h4>
<p>在单板上也可以通过 <code>/sys/kernel/debug/usb/xxxx.usb/</code> 文件夹下的文件节点，对 UDC 驱动进行配置：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # ls /sys/class/udc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10200000.usb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # ls /sys/kernel/debug/usb/10200000.usb/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dr_mode    ep1out     ep3in      ep4out     params     testmode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ep0        ep2in      ep3out     fifo       regdump</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ep1in      ep2out     ep4in      hw_params  state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>例如可以 dump 寄存器：:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] # cat /sys/kernel/debug/usb/10200000.usb/regdump</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GOTGCTL = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GOTGINT = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GAHBCFG = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GUSBCFG = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GRSTCTL = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GINTSTS = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GINTMSK = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GRXSTSR = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GRXFSIZ = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GNPTXFSIZ = 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GNPTXSTS = 0x00000000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="223-抓包工具">2.2.3. 抓包工具<a href="#223-抓包工具" class="hash-link" aria-label="Direct link to 2.2.3. 抓包工具" title="Direct link to 2.2.3. 抓包工具">​</a></h4>
<p>和 USB Host 调试一样，抓包可以使用专门的 USB 总线分析仪或者在 Linux 主机上使用 usbmon 进行抓包。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-测试指南">3. 测试指南<a href="#3-测试指南" class="hash-link" aria-label="Direct link to 3. 测试指南" title="Direct link to 3. 测试指南">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-测试方案介绍">3.1. 测试方案介绍<a href="#31-测试方案介绍" class="hash-link" aria-label="Direct link to 3.1. 测试方案介绍" title="Direct link to 3.1. 测试方案介绍">​</a></h3>
<p>在测试 USB 时，普通的做法是找一些 U 盘、鼠标、键盘 等外设来做一些测试，但是这些测试还是偏上层偏功能的。相比较 HC (USB Host Controller) 和 UDC (USB Device Controller) 按照USB协议提供的完整功能来说，这种测试验证时不充分的。</p>
<p>在 Linux Kernel 中对 HC/UDC 有一套专有的测试方案，在底层对 control/bulk/int/iso 几种 endpoint 进行针对性的功能和压力测试。</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_test_diagram-170676351834313.png" alt="image0" class="img_ev3q"></p>
<p>上图的测试方案由几部分组成：</p>
<ul>
<li>1、Device 侧的 <code>gadget zero</code> 测试设备，提供了测试通道。</li>
<li>2、Host 侧的 <code>usbtest.ko</code> 测试驱动，封装了 30 个 endpoint 层级的测试用例。</li>
<li>3、Host 侧的 <code>testusb</code> 用户程序，用来调用 <code>usbtest.ko</code> 提供的测试用例。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-device-侧-gadget-zero">3.2. Device 侧 <code>gadget zero</code><a href="#32-device-侧-gadget-zero" class="hash-link" aria-label="Direct link to 32-device-侧-gadget-zero" title="Direct link to 32-device-侧-gadget-zero">​</a></h3>
<p>提供测试需要的Device设备有很多种方式，例如可用使用专门的测试 Device 里面烧录专有的测试 Firmware。节约成本的方式还是使用 Linux gadget 功能来动态模拟 USB Device 设备。针对 USB 测试，Linux 专门提供了 <code>gadget zero</code> 设备。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="321-device-创建">3.2.1. Device 创建<a href="#321-device-创建" class="hash-link" aria-label="Direct link to 3.2.1. Device 创建" title="Direct link to 3.2.1. Device 创建">​</a></h4>
<p><code>gadget zero</code> 的核心是创建一个 <code>Composite Device</code> ，其包含了两个 <code>Configuration</code> ，其中一个 <code>Configuration 0</code> 包含 <code>SourceSink Function/Interface</code> ，另一个 <code>Configuration 1</code> 包含 <code>Loopback Function/Interface</code> 。某一时刻只能选择使用一个 <code>Configuration</code> ，通常情况下使用 <code>Configuration 0</code> 即 <code>SourceSink</code> 的功能。</p>
<p><code>gadget zero</code> Device 由两种方式创建：</p>
<ul>
<li>1、通过 <code>zero_driver</code> 创建，只要把对应驱动文件 <code>drivers\usb\gadget\legacy\zero.c</code> 编译进内核即可。</li>
<li>2、通过 <code>functionfs</code> 动态创建，这种方式更灵活，实例命令如下：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x04e8&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x2d01&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/Loopback.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/SourceSink.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.2/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x0525&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0xa4a0&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Samsung Inc.&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Bar Gadget&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Conf 1&quot; &gt; configs/c.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Conf 2&quot; &gt; configs/c.2/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo 120 &gt; configs/c.1/MaxPower</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// SourceSink：驱动 set configuration 会选取 第一个 configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/Loopback.0 configs/c.2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/SourceSink.0 configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo 4100000.udc-controller &gt; UDC</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>整个过程就是创建了一个 <code>Vendor ID = 0x0525</code> 、 <code>Product ID = 0xa4a0</code> 的 <code>Composite Device</code> ，在 Host 侧可以查看这个设备：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ lsusb -s 1:3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bus 001 Device 003: ID 0525:a4a0 Netchip Technology, Inc. Linux-USB &quot;Gadget Zero&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ lsusb -v -s 1:3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Bus 001 Device 003: ID 0525:a4a0 Netchip Technology, Inc. Linux-USB &quot;Gadget Zero&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Couldn&#x27;t open device, some information will be missing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Device Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bLength                18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bDescriptorType         1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bcdUSB               2.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bDeviceClass            0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bDeviceSubClass         0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bDeviceProtocol         0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bMaxPacketSize0        64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">idVendor           0x0525 Netchip Technology, Inc.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">idProduct          0xa4a0 Linux-USB &quot;Gadget Zero&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bcdDevice            5.10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iManufacturer           1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iProduct                2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iSerial                 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bNumConfigurations      2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Configuration Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength                 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType         2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wTotalLength       0x0045</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bNumInterfaces          1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bConfigurationValue     1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iConfiguration          4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bmAttributes         0x80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (Bus Powered)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MaxPower              120mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Interface Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength                 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType         4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceNumber        0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bAlternateSetting       0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bNumEndpoints           2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceClass       255 Vendor Specific Class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceSubClass      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceProtocol      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iInterface              0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x81  EP 1 IN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0200  1x 512 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x01  EP 1 OUT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0200  1x 512 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Interface Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength                 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType         4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceNumber        0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bAlternateSetting       1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bNumEndpoints           4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceClass       255 Vendor Specific Class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceSubClass      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceProtocol      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iInterface              0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x81  EP 1 IN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0200  1x 512 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x01  EP 1 OUT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0200  1x 512 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x82  EP 2 IN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Isochronous</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0400  1x 1024 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x02  EP 2 OUT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Isochronous</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0400  1x 1024 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Configuration Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength                 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType         2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wTotalLength       0x0020</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bNumInterfaces          1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bConfigurationValue     2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iConfiguration          5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bmAttributes         0x80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (Bus Powered)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MaxPower                2mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Interface Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength                 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType         4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceNumber        0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bAlternateSetting       0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bNumEndpoints           2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceClass       255 Vendor Specific Class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceSubClass      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterfaceProtocol      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    iInterface              6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x81  EP 1 IN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0200  1x 512 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bLength                 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bDescriptorType         5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bEndpointAddress     0x01  EP 1 OUT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bmAttributes            2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Transfer Type            Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Synch Type               None</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Usage Type               Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wMaxPacketSize     0x0200  1x 512 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bInterval               0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="322-sourcesink-function">3.2.2. SourceSink Function<a href="#322-sourcesink-function" class="hash-link" aria-label="Direct link to 3.2.2. SourceSink Function" title="Direct link to 3.2.2. SourceSink Function">​</a></h4>
<p><code>SourceSink Function</code> 的主要功能是提供了一组 USB 测试 endpoint，其中:</p>
<ul>
<li><code>Sink</code>。sinks bulk packets OUT to the peripheral。意思是把数据从 Host 引流到 Device，即 <code>OUT</code> 方向。</li>
<li><code>Source</code>。sources them IN to the host。意思是把从 Device 发送数据到 Device，即 <code>IN</code> 方向。</li>
</ul>
<p>具体提供了 4 组 测试 endpoint：</p>
<table><thead><tr><th>Endpoint</th><th>Type</th><th>Direction</th><th>Descript|</th></tr></thead><tbody><tr><td>in_ep</td><td>bulk</td><td>IN</td><td>Source 发送数据到 Host， 注意这数据是 Device 主动生成的</td></tr><tr><td>out_ep</td><td>bulk</td><td>OUT</td><td>Sink 接收 Host 的数据</td></tr><tr><td>iso_in_ep</td><td>iso</td><td>IN</td><td>Source 发送数据到 Host</td></tr><tr><td>iso_out_ep</td><td>iso</td><td>OUT</td><td>Sink 接收 Host 的数据</td></tr></tbody></table>
<p>主要流程如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\function\f_sourcesink.c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sourcesink_bind()：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sourcesink_bind(struct usb_configuration *c, struct usb_function *f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 从 gadget 中分配 2 个 bulk endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* allocate bulk endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ss-&gt;in_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_source_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ss-&gt;out_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_sink_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 如果支持ISO，再从 gadget 中分配 2 个 iso endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* allocate iso endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ss-&gt;iso_in_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_iso_source_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ss-&gt;iso_in_ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto no_iso;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ss-&gt;iso_out_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_iso_sink_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ss-&gt;iso_out_ep) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sourcesink_set_alt() → enable_source_sink() → usb_ep_enable()/source_sink_start_ep()：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 启动上述 endpoint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">→ source_sink_complete():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// urb 的 complete() 函数，urb 发送/接收完成后，重新挂载 urb</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>还支持一些参数调整：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># ls functions/SourceSink.0/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bulk_buflen     iso_qlen        isoc_maxburst   isoc_mult</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bulk_qlen       isoc_interval   isoc_maxpacket  pattern</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="323-loopback-function">3.2.3. Loopback Function<a href="#323-loopback-function" class="hash-link" aria-label="Direct link to 3.2.3. Loopback Function" title="Direct link to 3.2.3. Loopback Function">​</a></h4>
<p><code>Loopback Function</code> 提供的功能更为简单，它分配了两个 bulk endpoint，所做的就是把 <code>out_ep</code> 接收到的数据 转发到 <code>in_ep</code>。</p>
<p>主要流程如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\function\f_loopback.c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">loopback_bind()：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int loopback_bind(struct usb_configuration *c, struct usb_function *f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 从 gadget 中分配 2 个 bulk endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* allocate endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop-&gt;in_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_loop_source_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop-&gt;out_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_loop_sink_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">loopback_set_alt() → enable_loopback() → alloc_requests():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int alloc_requests(struct usb_composite_dev *cdev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            struct f_loopback *loop)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; loop-&gt;qlen &amp;&amp; result == 0; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        in_req = usb_ep_alloc_request(loop-&gt;in_ep, GFP_ATOMIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!in_req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out_req = lb_alloc_ep_req(loop-&gt;out_ep, loop-&gt;buflen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!out_req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto fail_in;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        in_req-&gt;complete = loopback_complete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out_req-&gt;complete = loopback_complete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        in_req-&gt;buf = out_req-&gt;buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* length will be set in complete routine */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        in_req-&gt;context = out_req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        out_req-&gt;context = in_req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (2) 先启动 OUT endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result = usb_ep_queue(loop-&gt;out_ep, out_req, GFP_ATOMIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (result) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ERROR(cdev, &quot;%s queue req --&gt; %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    loop-&gt;out_ep-&gt;name, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto fail_out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void loopback_complete(struct usb_ep *ep, struct usb_request *req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct f_loopback       *loop = ep-&gt;driver_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_composite_dev *cdev = loop-&gt;function.config-&gt;cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                     status = req-&gt;status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (status) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case 0:                         /* normal completion? */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ep == loop-&gt;out_ep) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            * We received some data from the host so let&#x27;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            * queue it so host can read the from our in ep</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            struct usb_request *in_req = req-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            in_req-&gt;zero = (req-&gt;actual &lt; req-&gt;length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            in_req-&gt;length = req-&gt;actual;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ep = loop-&gt;in_ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            req = in_req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            * We have just looped back a bunch of data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            * to host. Now let&#x27;s wait for some more data.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            req = req-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ep = loop-&gt;out_ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (3) 环回的关键：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                OUT endpoint 接收到的数据 转发到 IN endpoint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                IN endpoint 数据发送完成后 req 重新挂载到 OUT endpoint</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* queue the buffer back to host or for next bunch of data */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        status = usb_ep_queue(ep, req, GFP_ATOMIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>也支持一些参数调整：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># ls functions/Loopback.0/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bulk_buflen  qlen</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-host-侧-usbtestko">3.3. Host 侧 <code>usbtest.ko</code><a href="#33-host-侧-usbtestko" class="hash-link" aria-label="Direct link to 33-host-侧-usbtestko" title="Direct link to 33-host-侧-usbtestko">​</a></h3>
<p>在 Host 侧的 <code>usbtest.ko</code> 它就是一个标准的 <code>usb interface driver</code>。它根据 <code>Vendor ID = 0x0525</code> 、 <code>Product ID = 0xa4a0</code> 适配上一节 <code>Composite Device</code> 中的 <code>SourceSink Interface</code> 或者 <code>Loopback Interface</code>。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_device_id id_table[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* &quot;Gadget Zero&quot; firmware runs under Linux */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { USB_DEVICE(0x0525, 0xa4a0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .driver_info = (unsigned long) &amp;gz_info,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_DEVICE_TABLE(usb, id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct usb_driver usbtest_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name =         &quot;usbtest&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .id_table =     id_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .probe =        usbtest_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .unlocked_ioctl = usbtest_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disconnect =   usbtest_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .suspend =      usbtest_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .resume =       usbtest_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="331-testcase">3.3.1. TestCase<a href="#331-testcase" class="hash-link" aria-label="Direct link to 3.3.1. TestCase" title="Direct link to 3.3.1. TestCase">​</a></h4>
<p>其在 <code>SourceSink Interface</code> 提供的 4 个测试 endpoint、或者 <code>Loopback Interface</code> 提供的 2 个测试 endpoint + <code>Composite Device</code> 本身的 ep0 control endpoint 基础之上，提供了 30 个 testcase：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\misc\usbtest.c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usbtest_do_ioctl()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<table><thead><tr><th>index</th><th>type</th><th>iterations</th><th>vary</th><th>sglen</th><th>unaligned</th><th>testcase</th><th>descript</th></tr></thead><tbody><tr><td>0</td><td>nop</td><td></td><td></td><td></td><td></td><td>“TEST 0: NOPn”</td><td></td></tr><tr><td>1</td><td>bulk</td><td>Y</td><td></td><td></td><td></td><td>“TEST 1: write %d bytes %u timesn”, param-&gt;length, param-&gt;iterations</td><td>Simple non-queued bulk I/O tests</td></tr><tr><td>2</td><td>bulk</td><td>Y</td><td></td><td></td><td></td><td>“TEST 2: read %d bytes %u timesn”, param-&gt;length, param-&gt;iterations</td><td></td></tr><tr><td>3</td><td>bulk</td><td>Y</td><td>Y</td><td></td><td></td><td>“TEST 3: write/%d 0..%d bytes %u timesn”, param-&gt;vary, param-&gt;length, param-&gt;iterations</td><td></td></tr><tr><td>4</td><td>bulk</td><td>Y</td><td>Y</td><td></td><td></td><td>“TEST 4: read/%d 0..%d bytes %u timesn”, param-&gt;vary, param-&gt;length, param-&gt;iterations</td><td></td></tr><tr><td>5</td><td>bulk</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 5: write %d sglists %d entries of %d bytesn”, param-&gt;iterations,param-&gt;sglen, param-&gt;length</td><td>Queued bulk I/O tests</td></tr><tr><td>6</td><td>bulk</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 6: read %d sglists %d entries of %d bytesn”, param-&gt;iterations,param-&gt;sglen, param-&gt;length</td><td></td></tr><tr><td>7</td><td>bulk</td><td>Y</td><td>Y</td><td>Y</td><td></td><td>“TEST 7: write/%d %d sglists %d entries 0..%d bytesn”, param-&gt;vary, param-&gt;iterations,param-&gt;sglen, param-&gt;length</td><td></td></tr><tr><td>8</td><td>bulk</td><td>Y</td><td>Y</td><td>Y</td><td></td><td>“TEST 8: read/%d %d sglists %d entries 0..%d bytesn”, param-&gt;vary, param-&gt;iterations,param-&gt;sglen, param-&gt;length</td><td></td></tr><tr><td>9</td><td>control</td><td>Y</td><td></td><td></td><td></td><td>“TEST 9: ch9 (subset) control tests, %d timesn”, param-&gt;iterations</td><td>non-queued sanity tests for control (chapter 9 subset)</td></tr><tr><td>10</td><td>control</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 10: queue %d control calls, %d timesn”, param-&gt;sglen, param-&gt;iterations)</td><td>queued control messaging</td></tr><tr><td>11</td><td>bulk</td><td>Y</td><td></td><td></td><td></td><td>“TEST 11: unlink %d reads of %dn”, param-&gt;iterations, param-&gt;length</td><td>simple non-queued unlinks (ring with one urb)</td></tr><tr><td>12</td><td>bulk</td><td>Y</td><td></td><td></td><td></td><td>“TEST 12: unlink %d writes of %dn”, param-&gt;iterations, param-&gt;length</td><td></td></tr><tr><td>13</td><td>control</td><td>Y</td><td></td><td></td><td></td><td>“TEST 13: set/clear %d haltsn” param-&gt;iterations</td><td>ep halt tests</td></tr><tr><td>14</td><td>control</td><td>Y</td><td>Y</td><td></td><td></td><td>“TEST 14: %d ep0out, %d..%d vary %dn”, param-&gt;iterations,realworld ? 1 : 0, param-&gt;length,param-&gt;vary</td><td>control write tests</td></tr><tr><td>15</td><td>iso</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 15: write %d iso, %d entries of %d bytesn”, param-&gt;iterations, param-&gt;sglen, param-&gt;length</td><td>iso write tests</td></tr><tr><td>16</td><td>iso</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 16: read %d iso, %d entries of %d bytesn”, param-&gt;iterations, param-&gt;sglen, param-&gt;length</td><td>iso read tests</td></tr><tr><td>17</td><td>bulk</td><td>Y</td><td></td><td></td><td>Y</td><td>“TEST 17: write odd addr %d bytes %u times core mapn” param-&gt;length, param-&gt;iterations</td><td>Tests for bulk I/O using DMA mapping by core and odd address</td></tr><tr><td>18</td><td>bulk</td><td>Y</td><td></td><td></td><td>Y</td><td>“TEST 18: read odd addr %d bytes %u times core mapn”, param-&gt;length, param-&gt;iterations</td><td></td></tr><tr><td>19</td><td>bulk</td><td>Y</td><td></td><td></td><td>Y</td><td>“TEST 19: write odd addr %d bytes %u times premappedn”, param-&gt;length, param-&gt;iterations</td><td>Tests for bulk I/O using premapped coherent buffer and odd address</td></tr><tr><td>20</td><td>bulk</td><td>Y</td><td></td><td></td><td>Y</td><td>“TEST 20: read odd addr %d bytes %u times premappedn”, param-&gt;length, param-&gt;iterations</td><td></td></tr><tr><td>21</td><td>control</td><td>Y</td><td>Y</td><td></td><td>Y</td><td>“TEST 21: %d ep0out odd addr, %d..%d vary %dn”, param-&gt;iterations,realworld ? 1 : 0, param-&gt;length, param-&gt;vary</td><td>control write tests with unaligned buffer</td></tr><tr><td>22</td><td>iso</td><td>Y</td><td></td><td>Y</td><td>Y</td><td>“TEST 22: write %d iso odd, %d entries of %d bytesn”, param-&gt;iterations, param-&gt;sglen, param-&gt;length</td><td>unaligned iso tests</td></tr><tr><td>23</td><td>iso</td><td>Y</td><td></td><td>Y</td><td>Y</td><td>“TEST 23: read %d iso odd, %d entries of %d bytesn”, param-&gt;iterations, param-&gt;sglen, param-&gt;length</td><td></td></tr><tr><td>24</td><td>bulk</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 24: unlink from %d queues of %d %d-byte writesn”, param-&gt;iterations, param-&gt;sglen, param-&gt;length</td><td>unlink URBs from a bulk-OUT queue</td></tr><tr><td>25</td><td>int</td><td>Y</td><td></td><td></td><td></td><td>“TEST 25: write %d bytes %u timesn”, param-&gt;length, param-&gt;iterations</td><td>Simple non-queued interrupt I/O tests</td></tr><tr><td>26</td><td>int</td><td>Y</td><td></td><td></td><td></td><td>“TEST 26: read %d bytes %u timesn”, param-&gt;length, param-&gt;iterations</td><td></td></tr><tr><td>27</td><td>bulk</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 27: bulk write %dMbytesn”, (param-&gt;iterations * param-&gt;sglen * param-&gt;length) / (1024 * 1024))</td><td>Performance test</td></tr><tr><td>28</td><td>bulk</td><td>Y</td><td></td><td>Y</td><td></td><td>“TEST 28: bulk read %dMbytesn”, (param-&gt;iterations * param-&gt;sglen * param-&gt;length) / (1024 * 1024))</td><td></td></tr><tr><td>29</td><td>bulk</td><td>Y</td><td></td><td></td><td></td><td>“TEST 29: Clear toggle between bulk writes %d timesn”, param-&gt;iterations</td><td>Test data Toggle/seq_nr clear between bulk out transfers</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="332-ioctl">3.3.2. Ioctl<a href="#332-ioctl" class="hash-link" aria-label="Direct link to 3.3.2. Ioctl" title="Direct link to 3.3.2. Ioctl">​</a></h4>
<p>usbtest.ko 以 ioctl 的形式向用户态提供对 testcase 的调用：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usbdev_file_operations → usbdev_ioctl() → usbdev_do_ioctl() → proc_ioctl_default() → proc_ioctl()：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int proc_ioctl(struct usb_dev_state *ps, struct usbdevfs_ioctl *ctl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*  (1) 找到对应的 usb interface device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else if (!(intf = usb_ifnum_to_if(ps-&gt;dev, ctl-&gt;ifno)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retval = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* talk directly to the interface&#x27;s driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (intf-&gt;dev.driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /*  (2) 找到 usb interface device 对应的 driver  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            driver = to_usb_driver(intf-&gt;dev.driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (driver == NULL || driver-&gt;unlocked_ioctl == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retval = -ENOTTY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* (3) 调用 driver 的 ioctl 函数 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            retval = driver-&gt;unlocked_ioctl(intf, ctl-&gt;ioctl_code, buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (retval == -ENOIOCTLCMD)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                retval = -ENOTTY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usbtest_ioctl() → usbtest_do_ioctl()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="34-host-侧-testusb">3.4. Host 侧 <code>testusb</code><a href="#34-host-侧-testusb" class="hash-link" aria-label="Direct link to 34-host-侧-testusb" title="Direct link to 34-host-侧-testusb">​</a></h3>
<p>testusb 源码包含在 linux 内核当中， 路径为 <code>linux-5.10\tools\usb\testusb.c</code> 。可以通过 luban 编译，或者简单编译：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gcc -Wall -g -lpthread -o testusb testusb.c</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>就可以启动测试了：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ sudo ./testusb -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unknown speed       /dev/bus/usb/001/002</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 0,    0.000011 secs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 1,    1.625031 secs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 2 --&gt; 110 (Connection timed out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 3,    1.639717 secs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 4 --&gt; 110 (Connection timed out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 5,    1.915198 secs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 6 --&gt; 110 (Connection timed out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 7,    1.928419 secs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 8 --&gt; 110 (Connection timed out)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/bus/usb/001/002 test 9,   13.835084 secs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo ./testusb -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo ./testusb -a -t1 -c1 -s512 -g32 -v32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo ./testusb -a -t29 -c1 -s512 -g32 -v32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// test 10 需要特别注意，容易挂死 host</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo ./testusb -a -t10 -c1 -s512 -g5 -v32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// test 28 需要特别注意，容易挂死 host</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo ./testusb -a -t28 -c1 -s512 -g32 -v32</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-设计说明">4. 设计说明<a href="#4-设计说明" class="hash-link" aria-label="Direct link to 4. 设计说明" title="Direct link to 4. 设计说明">​</a></h2>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_sw_stack-170676362740915.png" alt="image0" class="img_ev3q"></p>
<p>整个 USB 系统的软件栈如上图所示，本文仅描述其中的 HCD (Host Controller Driver) 和 DCD (Device Controller Driver)。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="41-usb-host-controller-driver">4.1. USB Host Controller Driver<a href="#41-usb-host-controller-driver" class="hash-link" aria-label="Direct link to 4.1. USB Host Controller Driver" title="Direct link to 4.1. USB Host Controller Driver">​</a></h3>
<p>下面以 EHCI 为例，说明 HCD 软件设计思想。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="411-源码说明">4.1.1. 源码说明<a href="#411-源码说明" class="hash-link" aria-label="Direct link to 4.1.1. 源码说明" title="Direct link to 4.1.1. 源码说明">​</a></h4>
<table><thead><tr><th>相关模块</th><th>源码路径</th></tr></thead><tbody><tr><td>EHCI</td><td>source\linux-5.10\drivers\usb\host\ehci-aic.c source\linux-5.10\drivers\usb\host\ehci-hcd.c source\linux-5.10\drivers\usb\host\ehci-mem.c source\linux-5.10\drivers\usb\host\ehci-q.c source\linux-5.10\drivers\usb\host\ehci-timer.c source\linux-5.10\drivers\usb\host\ehci-hub.c</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="412-模块架构">4.1.2. 模块架构<a href="#412-模块架构" class="hash-link" aria-label="Direct link to 4.1.2. 模块架构" title="Direct link to 4.1.2. 模块架构">​</a></h4>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hcd-170676364467717.png" alt="image1" class="img_ev3q"></p>
<p>从 HCD (Host Controller Driver) 的框架图中可以看到，HCD 主要提供了两大功能：</p>
<ol>
<li>普通 URB 数据收发功能。</li>
</ol>
<blockquote>
<p>将 USB Class Driver 下发的 URB，按照硬件控制器要求的格式，按分类发送到硬件 List 当中。</p>
</blockquote>
<ol>
<li>RootHub URB 的处理功能。</li>
</ol>
<blockquote>
<p>对于 RootHub Driver 下发的 ep0 控制命令 URB，系统不会发送到硬件控制器之上，而是转发给 HCD 使用软件来模拟执行。</p>
<p>对于 RootHub Driver 下发的端口状态查询 URB，通过响应中断进行上报。</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="413-关键流程">4.1.3. 关键流程<a href="#413-关键流程" class="hash-link" aria-label="Direct link to 4.1.3. 关键流程" title="Direct link to 4.1.3. 关键流程">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4131-初始化流程">4.1.3.1. 初始化流程<a href="#4131-初始化流程" class="hash-link" aria-label="Direct link to 4.1.3.1. 初始化流程" title="Direct link to 4.1.3.1. 初始化流程">​</a></h5>
<p>HCD 驱动的入口是 platform 驱动，初始化流程先获取 irq、reg、clk、reset 等资源并进行初始化，最后调用 usb_add_hcd() 向系统中注册。</p>
<p>大致的流程如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">|--&gt;ehci_platform_init()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;ehci_init_driver()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;platform_driver_register()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |--&gt;aic_ehci_platform_probe()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;hcd = usb_create_hcd()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;irq = platform_get_irq(dev, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;priv-&gt;clks[i] = of_clk_get(dev-&gt;dev.of_node, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;priv-&gt;rst[i] = devm_reset_control_get_shared_by_index(&amp;dev-&gt;dev, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;hcd-&gt;regs = devm_ioremap_resource(&amp;dev-&gt;dev, res_mem);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;aic_ehci_platform_power_on()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |--&gt;reset_control_deassert(priv-&gt;rst[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                |--&gt;clk_prepare_enable(priv-&gt;clks[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;usb_add_hcd(hcd, irq, IRQF_SHARED);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4132-普通-urb-处理流程">4.1.3.2. 普通 URB 处理流程<a href="#4132-普通-urb-处理流程" class="hash-link" aria-label="Direct link to 4.1.3.2. 普通 URB 处理流程" title="Direct link to 4.1.3.2. 普通 URB 处理流程">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_urb_flow-170676367501619.png" alt="image2" class="img_ev3q"></p>
<p>如上图所示，一个普通 urb 的处理分为两步：</p>
<ul>
<li>urb enqueue。首先调用 hcd 的 <code>.urb_enqueue()</code> 函数，将需要传输的数据插入到硬件控制器的链表当中。</li>
<li>urb complete。在链表中的一帧数据传输完成后硬件会产生 <code>complete</code> 中断，在中断服务程序中对相应 urb 发送 <code>complete</code> 信号，让 <code>usb_start_wait_urb()</code> 的流程继续执行。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4133-roothub-urb-处理流程">4.1.3.3. Roothub URB 处理流程<a href="#4133-roothub-urb-处理流程" class="hash-link" aria-label="Direct link to 4.1.3.3. Roothub URB 处理流程" title="Direct link to 4.1.3.3. Roothub URB 处理流程">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_roothub_urb_flow-170676368257721.png" alt="image3" class="img_ev3q"></p>
<p>如上图所示，roothub urb 的处理分为两种类型：</p>
<ul>
<li>ep0 control urb。对于 roothub control urb，HCD 需要使用软件来模拟，实际上 urb 没有发送到硬件控制器中，因为是软件模拟所以无需等待 <code>complete</code> 可以立即释放。</li>
<li>获取端口状态 urb。这类 urb 会阻塞等待端口状态改变，一旦端口状态改变会触发硬件中断，在中断处理中唤醒对应 urb 的 <code>complete</code> 信号，让 <code>usb_start_wait_urb()</code> 的流程继续执行。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="414-数据结构">4.1.4. 数据结构<a href="#414-数据结构" class="hash-link" aria-label="Direct link to 4.1.4. 数据结构" title="Direct link to 4.1.4. 数据结构">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4141-ehci_hc_driver">4.1.4.1. ehci_hc_driver<a href="#4141-ehci_hc_driver" class="hash-link" aria-label="Direct link to 4.1.4.1. ehci_hc_driver" title="Direct link to 4.1.4.1. ehci_hc_driver">​</a></h5>
<p>HCD 核心的数据结构为 hc_driver，EHCI 实现了以下的核心函数：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct hc_driver ehci_hc_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .description =          hcd_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .product_desc =         &quot;EHCI Host Controller&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .hcd_priv_size =        sizeof(struct ehci_hcd),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * generic hardware linkage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .irq =                  ehci_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .flags =                HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * basic lifecycle operations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reset =                ehci_setup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .start =                ehci_run,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .stop =                 ehci_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .shutdown =             ehci_shutdown,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * managing i/o requests and associated device resources</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .urb_enqueue =          ehci_urb_enqueue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .urb_dequeue =          ehci_urb_dequeue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .endpoint_disable =     ehci_endpoint_disable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .endpoint_reset =       ehci_endpoint_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .clear_tt_buffer_complete =     ehci_clear_tt_buffer_complete,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * scheduling support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .get_frame_number =     ehci_get_frame,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * root hub support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .hub_status_data =      ehci_hub_status_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .hub_control =          ehci_hub_control,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bus_suspend =          ehci_bus_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bus_resume =           ehci_bus_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .relinquish_port =      ehci_relinquish_port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .port_handed_over =     ehci_port_handed_over,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .get_resuming_ports =   ehci_get_resuming_ports,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * device support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .free_dev =             ehci_remove_device,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="415-接口设计">4.1.5. 接口设计<a href="#415-接口设计" class="hash-link" aria-label="Direct link to 4.1.5.   接口设计" title="Direct link to 4.1.5. 接口设计">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4151-ehci_urb_enqueue">4.1.5.1. ehci_urb_enqueue<a href="#4151-ehci_urb_enqueue" class="hash-link" aria-label="Direct link to 4.1.5.1. ehci_urb_enqueue" title="Direct link to 4.1.5.1. ehci_urb_enqueue">​</a></h5>
<table><thead><tr><th>函数原型</th><th>int ehci_urb_enqueue (struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)</th></tr></thead><tbody><tr><td>功能说明</td><td>接收上层传入的 urb，并将其压入 EHCI 的硬件队列。</td></tr><tr><td>参数定义</td><td>hcd：当前 hcd 控制结构 urb：当前 urb 控制结构 mem_flags：分配内存时使用的标志</td></tr><tr><td>返回值</td><td>0，成功； &lt; 0，失败</td></tr><tr><td>注意事项</td><td></td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4152-ehci_hub_control">4.1.5.2. ehci_hub_control<a href="#4152-ehci_hub_control" class="hash-link" aria-label="Direct link to 4.1.5.2. ehci_hub_control" title="Direct link to 4.1.5.2. ehci_hub_control">​</a></h5>
<table><thead><tr><th>函数原型</th><th>int ehci_hub_control (struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)</th></tr></thead><tbody><tr><td>功能说明</td><td>处理 roothub 相关的 control 命令。</td></tr><tr><td>参数定义</td><td>hcd：当前 hcd 控制结构 typeReq：setup token 中的对应字段 wValue：setup token 中的对应字段 wIndex：setup token 中的对应字段 buf：setup data 需要的数据 wLength：setup token 中的对应字段</td></tr><tr><td>返回值</td><td>0，成功； &lt; 0，失败</td></tr><tr><td>注意事项</td><td></td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4153-ehci_hub_status_data">4.1.5.3. ehci_hub_status_data<a href="#4153-ehci_hub_status_data" class="hash-link" aria-label="Direct link to 4.1.5.3. ehci_hub_status_data" title="Direct link to 4.1.5.3. ehci_hub_status_data">​</a></h5>
<table><thead><tr><th>函数原型</th><th>int ehci_hub_status_data (struct usb_hcd *hcd, char *buf)</th></tr></thead><tbody><tr><td>功能说明</td><td>查询 hub 端口状态。</td></tr><tr><td>参数定义</td><td>hcd：当前 hcd 控制结构 buf：返回获取的 hub 端口状态</td></tr><tr><td>返回值</td><td>&gt;0，成功获取端口状态的长度； = 0，失败</td></tr><tr><td>注意事项</td><td></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="42-usb-device-controller-driver">4.2. USB Device Controller Driver<a href="#42-usb-device-controller-driver" class="hash-link" aria-label="Direct link to 4.2. USB Device Controller Driver" title="Direct link to 4.2. USB Device Controller Driver">​</a></h3>
<p>Linux 利用 Device Controller Driver 把整个单板模拟成一个 USB Device 设备。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="421-源码说明">4.2.1. 源码说明<a href="#421-源码说明" class="hash-link" aria-label="Direct link to 4.2.1. 源码说明" title="Direct link to 4.2.1. 源码说明">​</a></h4>
<table><thead><tr><th>相关模块</th><th>源码路径</th></tr></thead><tbody><tr><td>AIC UDC</td><td>source\linux-5.10\drivers\usb\gadget\udc\aic_udc.c source\linux-5.10\drivers\usb\gadget\udc\aic_udc.h</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="422-模块架构">4.2.2. 模块架构<a href="#422-模块架构" class="hash-link" aria-label="Direct link to 4.2.2. 模块架构" title="Direct link to 4.2.2. 模块架构">​</a></h4>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd-170676372182523.png" alt="image4" class="img_ev3q"></p>
<p>从上述 DCD (Device Controller Driver) 的框架图中可以看到，DCD 主要提供了两大功能：</p>
<ol>
<li>普通 ep 的 usb request 处理。</li>
</ol>
<blockquote>
<p>DCD 提供了一个 endpoint 资源池，Gadget Function Driver 可以在这个资源池中分配需要的 endpoint，这部分的 endpoint 就称为 普通 ep。</p>
</blockquote>
<ol>
<li>ep0 的 usb request 处理。</li>
</ol>
<blockquote>
<p>因为 DCD 对外呈现为一个 USB Device，USB Device 的 ep0 是管理通道是需要特殊处理的。对 ep0 传达过来的 control 数据需要在 DCD 层开始解析。</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="423-关键流程">4.2.3. 关键流程<a href="#423-关键流程" class="hash-link" aria-label="Direct link to 4.2.3. 关键流程" title="Direct link to 4.2.3. 关键流程">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4231-初始化流程">4.2.3.1. 初始化流程<a href="#4231-初始化流程" class="hash-link" aria-label="Direct link to 4.2.3.1. 初始化流程" title="Direct link to 4.2.3.1. 初始化流程">​</a></h5>
<p>DCD 驱动的入口是 platform 驱动，初始化流程先获取 irq、reg、clk、reset 等资源并进行初始化，最后调用 usb_add_gadget_udc() 向系统中注册。</p>
<p>大致的流程如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">|--&gt;aic_udc_probe()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;gg-&gt;regs = devm_ioremap_resource(&amp;dev-&gt;dev, res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;gg-&gt;reset = devm_reset_control_get_optional(gg-&gt;dev, &quot;aicudc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;gg-&gt;reset_ecc = devm_reset_control_get_optional_shared(gg-&gt;dev,&quot;aicudc-ecc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;gg-&gt;clks[i] = of_clk_get(gg-&gt;dev-&gt;of_node, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;aic_gadget_init(gg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        |--&gt;aic_low_hw_enable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;clk_prepare_enable(gg-&gt;clks[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;reset_control_deassert(gg-&gt;reset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            |--&gt;reset_control_deassert(gg-&gt;reset_ecc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;res = platform_get_resource(dev, IORESOURCE_IRQ, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;gg-&gt;irq = res-&gt;start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    |--&gt;usb_add_gadget_udc(gg-&gt;dev, &amp;gg-&gt;gadget);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4232-ep-分配流程">4.2.3.2. ep 分配流程<a href="#4232-ep-分配流程" class="hash-link" aria-label="Direct link to 4.2.3.2. ep 分配流程" title="Direct link to 4.2.3.2. ep 分配流程">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd_ep_pool-170676374509225.png" alt="image5" class="img_ev3q"></p>
<p>如上图所示，ep 资源的操作分为两部分：</p>
<ul>
<li>ep 资源池初始化。在 udc 驱动初始化的时候同时初始化了 ep 资源池，这样就决定了当前有多少个 ep 资源可用。</li>
<li>ep 资源的分配。gadget composite device 可以配置多个 interface 即 gadget function driver，当 function driver 启用时，会从资源池中分配需要的 ep。如果配置的 function driver 过多，就可能会分配失败。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4233-普通-ep-的-request-处理">4.2.3.3. 普通 ep 的 request 处理<a href="#4233-普通-ep-的-request-处理" class="hash-link" aria-label="Direct link to 4.2.3.3. 普通 ep 的 request 处理" title="Direct link to 4.2.3.3. 普通 ep 的 request 处理">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd_ep_queue-170676375463427.png" alt="image6" class="img_ev3q"></p>
<p>如上图所示，对于普通 ep 的 reuqest 数据收发分为两步：</p>
<ul>
<li>request enqueue。首先调用 udc 的 <code>.queue()</code> 函数，将需要传输的数据插入到硬件控制器对应的 ep 寄存器当中。</li>
<li>complete callback。ep 数据收发完成会产生 <code>transfer complete</code> 中断，在中断服务程序中调用 <code>complete</code> 回调函数，结束整个 request 传输。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4234-ep0-的-request-处理">4.2.3.4. ep0 的 request 处理<a href="#4234-ep0-的-request-处理" class="hash-link" aria-label="Direct link to 4.2.3.4. ep0 的 request 处理" title="Direct link to 4.2.3.4. ep0 的 request 处理">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd_ep0_queue-170676376089229.png" alt="image7" class="img_ev3q"></p>
<p>如上图所示，对于 ep0 的 reuqest 数据收发和 普通 ep 基本一样，只是对数据的回调处理稍有不同。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="424-数据结构">4.2.4. 数据结构<a href="#424-数据结构" class="hash-link" aria-label="Direct link to 4.2.4. 数据结构" title="Direct link to 4.2.4. 数据结构">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4241-aic_usb_ep_ops">4.2.4.1. aic_usb_ep_ops<a href="#4241-aic_usb_ep_ops" class="hash-link" aria-label="Direct link to 4.2.4.1. aic_usb_ep_ops" title="Direct link to 4.2.4.1. aic_usb_ep_ops">​</a></h5>
<p>AIC UDC 驱动核心的数据结构为 usb_ep_ops， 实现了 op 操作的相关函数：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_ep_ops aic_usb_ep_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .enable                 = aic_ep_enable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disable                = aic_ep_disable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .alloc_request          = aic_ep_alloc_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .free_request           = aic_ep_free_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .queue                  = aic_ep_queue_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .dequeue                = aic_ep_dequeue_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .set_halt               = aic_ep_sethalt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="425-接口设计">4.2.5. 接口设计<a href="#425-接口设计" class="hash-link" aria-label="Direct link to 4.2.5. 接口设计" title="Direct link to 4.2.5. 接口设计">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4251-aic_ep_queue_request">4.2.5.1. aic_ep_queue_request<a href="#4251-aic_ep_queue_request" class="hash-link" aria-label="Direct link to 4.2.5.1. aic_ep_queue_request" title="Direct link to 4.2.5.1. aic_ep_queue_request">​</a></h5>
<table><thead><tr><th>函数原型</th><th>int aic_ep_queue_request(struct usb_ep *ep, struct usb_request *req, gfp_t gfp_flags)</th></tr></thead><tbody><tr><td>功能说明</td><td>接收上层传入的 request，并将其配置到 ep 寄存器中。</td></tr><tr><td>参数定义</td><td>ep：当前 ep 控制结构 req：当前 request 控制结构 gfp_flags：分配内存时使用的标志</td></tr><tr><td>返回值</td><td>0，成功； &lt; 0，失败</td></tr><tr><td>注意事项</td><td></td></tr></tbody></table>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="4252-aic_ep0_process_control">4.2.5.2. aic_ep0_process_control<a href="#4252-aic_ep0_process_control" class="hash-link" aria-label="Direct link to 4.2.5.2. aic_ep0_process_control" title="Direct link to 4.2.5.2. aic_ep0_process_control">​</a></h5>
<table><thead><tr><th>函数原型</th><th>void aic_ep0_process_control(struct aic_usb_gadget *gg, struct usb_ctrlrequest *ctrl)</th></tr></thead><tbody><tr><td>功能说明</td><td>处理 ep0 接收到的 control 数据包。</td></tr><tr><td>参数定义</td><td>gg：当前 gadget 控制结构 ctrl：当前 control 数据包</td></tr><tr><td>返回值</td><td>0，成功； &lt; 0，失败</td></tr><tr><td>注意事项</td><td></td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-usb-host-子系统代码架构">5. USB Host 子系统代码架构<a href="#5-usb-host-子系统代码架构" class="hash-link" aria-label="Direct link to 5. USB Host 子系统代码架构" title="Direct link to 5. USB Host 子系统代码架构">​</a></h2>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_flow_detail_host-170676415011331.png" alt="image0" class="img_ev3q"></p>
<p>整个 USB 系统的通讯模型如上图所示，Host 框架见左侧彩图部分。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-usb-core">5.1. USB Core<a href="#51-usb-core" class="hash-link" aria-label="Direct link to 5.1. USB Core" title="Direct link to 5.1. USB Core">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="511-layer">5.1.1. Layer<a href="#511-layer" class="hash-link" aria-label="Direct link to 5.1.1. Layer" title="Direct link to 5.1.1. Layer">​</a></h4>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_host_drv_dev-170676416810133.png" alt="image1" class="img_ev3q"></p>
<p>由前几节可知USB将 <code>Device</code> 进一步细分成了3个层级： <code>Configuration</code> 配置、 <code>Interface</code> 接口、 <code>Endpoint</code> 端点。</p>
<p>USB Core 为其中两个层次提供了 <code>Device + Driver</code> 的设备驱动模型，这两个层次分别是 <code>USB Device Layer</code> 和 <code>USB Interface Layer</code> 层，一个 <code>USB Device</code> 包含一个或多个 <code>USB Interface</code>。其中：</p>
<ul>
<li><code>USB Device Layer</code> 层。这一层的 <code>Device</code> 由 <code>Hub</code> 创建， <code>Hub</code> 本身也是一种 <code>USB Device</code> ；这一层的 <code>Driver</code> 完成的功能非常简单，基本就是帮 <code>USB Device</code> 创建其包含的所有子 <code>USB Interface</code> 的 <code>Device</code> ，大部分场景下都是使用 <code>usb_generic_driver</code>。</li>
<li><code>USB Interface Layer</code> 层。这一层的 <code>Device</code> 由上一级 <code>USB Device</code> 在驱动 probe() 时创建；而这一层的 <code>Driver</code> 就是普通的业务 Usb 驱动，即 Usb 协议中所说的 <code>Client Software</code>。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="512-urb-usb-request-block">5.1.2. URB (USB Request Block)<a href="#512-urb-usb-request-block" class="hash-link" aria-label="Direct link to 5.1.2. URB (USB Request Block)" title="Direct link to 5.1.2. URB (USB Request Block)">​</a></h4>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_host_urb-170676417587035.png" alt="image2" class="img_ev3q"></p>
<p>USB Core 除了提供上一节描述的设备驱动模型以外，另一个重要的作用就是要给 <code>USB Interface</code> Driver 提供读写 USB 数据的 API，这一任务是围绕着 <code>USB Request Block</code> 来完成的。</p>
<p><code>USB Interface</code> Driver 适配成功以后，会从配置信息中获取到当前 Interface 包含了多少个 <code>Endpoint</code> ，以及每个 <code>Endpoint</code> 的地址、传输类型、最大包长等其他信息。 <code>Endpoint</code> 是 USB 总线传输中最小的 <code>寻址单位</code> ，Interface Driver 利用对几个 <code>Endpoint</code> 的读写来驱动具体的设备功能。</p>
<p>对某个 <code>Endpoint</code> 发起一次读写操作，具体工作使用 <code>struct urb</code> 数据结构来承担。</p>
<p>以下是一个对 <code>Endpoint 0</code> 使用 urb 发起读写的一个简单实例：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int usb_internal_control_msg(struct usb_device *usb_dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    unsigned int pipe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    struct usb_ctrlrequest *cmd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    void *data, int len, int timeout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct urb *urb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 分配一个 urb 内存空间 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    urb = usb_alloc_urb(0, GFP_NOIO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 填充 urb 内容，最核心的有3方面：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            1、总线地址：Device Num + Endpoint Num</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            2、数据：data + len</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            3、回调函数：usb_api_blocking_completion</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                len, usb_api_blocking_completion, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 发送 urb 请求，并且等待请求完成 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retv = usb_start_wait_urb(urb, timeout, &amp;length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (retv &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return retv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct api_context ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long expire;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    init_completion(&amp;ctx.done);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    urb-&gt;context = &amp;ctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    urb-&gt;actual_length = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3.1) 把 urb 请求挂载到 hcd 的队列当中 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retval = usb_submit_urb(urb, GFP_NOIO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (unlikely(retval))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3.2) 当 urb 执行完成后，首先会调用 urb 的回调函数，然后会发送 completion 信号解除这里的阻塞 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!wait_for_completion_timeout(&amp;ctx.done, expire)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_kill_urb(urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dev_dbg(&amp;urb-&gt;dev-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;%s timed out on ep%d%s len=%u/%u\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            current-&gt;comm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_urb_dir_in(urb) ? &quot;in&quot; : &quot;out&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            urb-&gt;actual_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            urb-&gt;transfer_buffer_length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retval = ctx.status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (actual_length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *actual_length = urb-&gt;actual_length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_free_urb(urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return retval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5121-normal-device-urb_enqueue">5.1.2.1. Normal Device urb_enqueue<a href="#5121-normal-device-urb_enqueue" class="hash-link" aria-label="Direct link to 5.1.2.1. Normal Device urb_enqueue" title="Direct link to 5.1.2.1. Normal Device urb_enqueue">​</a></h5>
<p>对普通的 Usb device 来说，urb 最后会提交到 Host Controller 的收发队列上面，由 HC 完成实际的 USB 传输：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_submit_urb() → usb_hcd_submit_urb():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 如果是 roothub 走特殊的路径 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (is_root_hub(urb-&gt;dev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        status = rh_urb_enqueue(hcd, urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 如果是普通 device 调用对应的 hcd 的 urb_enqueue() 函数 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        status = map_urb_for_dma(hcd, urb, mem_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (likely(status == 0)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            status = hcd-&gt;driver-&gt;urb_enqueue(hcd, urb, mem_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (unlikely(status))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unmap_urb_for_dma(hcd, urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5122-roothub-device-urb_enqueue">5.1.2.2. Roothub Device urb_enqueue<a href="#5122-roothub-device-urb_enqueue" class="hash-link" aria-label="Direct link to 5.1.2.2. Roothub Device urb_enqueue" title="Direct link to 5.1.2.2. Roothub Device urb_enqueue">​</a></h5>
<p>特别需要注意的是 roothub 它是一个虚拟的 usb device，实际上它并不在usb总线上而是在 host 内部，所以相应的 urb 需要特殊处理，而不能使用 hcd 把数据发送到 Usb 总线上去。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_submit_urb() → usb_hcd_submit_urb() → rh_urb_enqueue():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 对于 int 类型的数据，被挂载到 hcd-&gt;status_urb 指针上面</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            通常 roothub 驱动用这个 urb 来查询 roothub 的端口状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (usb_endpoint_xfer_int(&amp;urb-&gt;ep-&gt;desc))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rh_queue_status (hcd, urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 对于 control 类型的数据，是想读取 roothub ep0 上的配置信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            使用软件来模拟这类操作的响应</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return rh_call_control (hcd, urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|→</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.1) 将 urb 挂载到对应的 ep 链表中 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retval = usb_hcd_link_urb_to_ep(hcd, urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (retval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto done;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.2) 将 urb 赋值给 hcd-&gt;status_urb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            在 hcd 驱动中，会通过这些接口来通知 roothub 的端口状态变化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hcd-&gt;status_urb = urb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    urb-&gt;hcpriv = hcd;      /* indicate it&#x27;s queued */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!hcd-&gt;uses_new_polling)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mod_timer(&amp;hcd-&gt;rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|→</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.1) 软件模拟对 roothub 配置读写的响应 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-usb-device-layer">5.2. USB Device Layer<a href="#52-usb-device-layer" class="hash-link" aria-label="Direct link to 5.2. USB Device Layer" title="Direct link to 5.2. USB Device Layer">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="521-device-struct-usb_device">5.2.1. Device (struct usb_device)<a href="#521-device-struct-usb_device" class="hash-link" aria-label="Direct link to 5.2.1. Device (struct usb_device)" title="Direct link to 5.2.1. Device (struct usb_device)">​</a></h4>
<p><code>USB Device</code> Device 对应的数据结构为 <code>struct usb_device</code> ，会在两种情况下被创建：</p>
<ul>
<li>roothub device。在 HCD 驱动注册时创建：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* (1) 首先创建和初始化 `usb_device` 结构： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_add_hcd() → usb_alloc_dev():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_device *usb_alloc_dev(struct usb_device *parent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct usb_bus *bus, unsigned port1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.1) dev 总线初始  化为 usb_bus_type */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.bus = &amp;usb_bus_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.2) dev 类型初始化为 usb_device_type，标明自己是一个 usb device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.type = &amp;usb_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.groups = usb_device_groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (2) 然后注册  `usb_device` 结构： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_add_hcd() → register_root_hub() → usb_new_device() → device_add()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>普通 usb device。在 Hub 检测到端口有设备 attach 时创建：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* (1) 首先创建和初始化 `usb_device` 结构： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hub_event() → port_event() → hub_port_connect_change() → hub_port_connect() → usb_alloc_dev()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (2) 然后注册  `usb_device` 结构： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hub_event() → port_event() → hub_port_connect_change() → hub_port_connect() → usb_new_device() → device_add()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="522-driver-struct-usb_device_driver">5.2.2. Driver (struct usb_device_driver)<a href="#522-driver-struct-usb_device_driver" class="hash-link" aria-label="Direct link to 5.2.2. Driver (struct usb_device_driver)" title="Direct link to 5.2.2. Driver (struct usb_device_driver)">​</a></h4>
<p><code>USB Device</code> Driver 对应的数据结构为 <code>struct usb_device_driver</code>，使用 <code>usb_register_device_driver()</code> 函数进行注册：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register_device_driver(struct usb_device_driver *new_udriver,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct module *owner)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 设置for_devices标志为1，表面这个驱动时给 usb device 使用的 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.for_devices = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.driver.name = new_udriver-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.driver.owner = owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.driver.dev_groups = new_udriver-&gt;dev_groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>注册的 <code>USB Device</code> Driver 驱动非常少，一般情况下所有的 <code>USB Device</code> Device 都会适配到 <code>usb_generic_driver</code>。因为这一层次驱动的目的很单纯，就是给 <code>USB Device</code> 下所有的 <code>Interface</code> 创建对应的 <code>USB Interface</code> Device。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_init() → usb_register_device_driver() :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int __init usb_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_device_driver usb_generic_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name = &quot;usb&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .match = usb_generic_driver_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .probe = usb_generic_driver_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disconnect = usb_generic_driver_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef      CONFIG_PM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .suspend = usb_generic_driver_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .resume = usb_generic_driver_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .supports_autosuspend = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>驱动 probe() 过程：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_probe_device() → usb_generic_driver_probe() → usb_set_configuration():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_set_configuration(struct usb_device *dev, int configuration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 创建和初始化 `struct usb_interface` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; nintf; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (1.1) dev 总线初始化为 usb_bus_type */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.bus = &amp;usb_bus_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (1.2) dev 类型初始化为 usb_if_device_type，标明自己是一个 usb interface */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.type = &amp;usb_if_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.groups = usb_interface_groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 注册 `struct usb_interface` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; nintf; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = device_add(&amp;intf-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="523-bus-usb_bus_type">5.2.3. Bus (usb_bus_type)<a href="#523-bus-usb_bus_type" class="hash-link" aria-label="Direct link to 5.2.3. Bus (usb_bus_type)" title="Direct link to 5.2.3. Bus (usb_bus_type)">​</a></h4>
<p>可以看到 <code>struct usb_device</code> 和 <code>struct usb_interface</code> 使用的总线都是 <code>usb_bus_type</code>。他们是通过字段 <code>dev.type</code> 来区分的：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* (1) `struct usb_device` 的 `dev.type` 值为 `usb_device_type`： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_add_hcd() → usb_alloc_dev():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_device *usb_alloc_dev(struct usb_device *parent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct usb_bus *bus, unsigned port1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.type = &amp;usb_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (2) `struct usb_interface` 的 `dev.type` 值为 `usb_if_device_type` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_probe_device() → usb_generic_driver_probe() → usb_set_configuration():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_set_configuration(struct usb_device *dev, int configuration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; nintf; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.type = &amp;usb_if_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline int is_usb_device(const struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 判断当前 Device 是否为 Usb Device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dev-&gt;type == &amp;usb_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline int is_usb_interface(const struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (4) 判断当前 Device 是否为 Usb Interface */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dev-&gt;type == &amp;usb_if_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>另外 <code>struct usb_device_driver</code> 和 <code>struct usb_driver</code> 使用的总线都是 <code>usb_bus_type</code>。他们是通过字段 <code>drvwrap.for_devices</code> 来区分的：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* (1) `struct usb_device_driver` 的 `drvwrap.for_devices` 值为 1： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register_device_driver(struct usb_device_driver *new_udriver,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct module *owner)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_udriver-&gt;drvwrap.for_devices = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (2) `struct usb_driver` 的 `drvwrap.for_devices` 值为 0： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register_driver(struct usb_driver *new_driver, struct module *owner,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const char *mod_name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.for_devices = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (3) 判断当前 Driver 是适配 Usb Device 还是 Usb Interface */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline int is_usb_device_driver(struct device_driver *drv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return container_of(drv, struct usbdrv_wrap, driver)-&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for_devices;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 <code>usb_bus_type</code> 的 <code>match()</code> 函数中利用 <code>dev.type</code> 进行判别分开处理：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct bus_type usb_bus_type = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name =         &quot;usb&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .match =        usb_device_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .uevent =       usb_uevent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .need_parent_lock =     true,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int usb_device_match(struct device *dev, struct device_driver *drv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* devices and interfaces are handled separately */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) Device 是 `Usb Device` 的处理 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (is_usb_device(dev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct usb_device *udev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct usb_device_driver *udrv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* interface drivers never match devices */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (1.1) 只查找 `Usb Device` 的 Driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!is_usb_device_driver(drv))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        udev = to_usb_device(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        udrv = to_usb_device_driver(drv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* If the device driver under consideration does not have a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * id_table or a match function, then let the driver&#x27;s probe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * function decide.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!udrv-&gt;id_table &amp;&amp; !udrv-&gt;match)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return usb_driver_applicable(udev, udrv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) Device 是 `Usb Interface` 的处理 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (is_usb_interface(dev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct usb_interface *intf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct usb_driver *usb_drv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const struct usb_device_id *id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* device drivers never match interfaces */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (2.1) 只查找 `Usb Interface` 的 Driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (is_usb_device_driver(drv))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf = to_usb_interface(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_drv = to_usb_driver(drv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        id = usb_match_dynamic_id(intf, usb_drv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-usb-interface-layer">5.3. USB Interface Layer<a href="#53-usb-interface-layer" class="hash-link" aria-label="Direct link to 5.3. USB Interface Layer" title="Direct link to 5.3. USB Interface Layer">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="531-device-struct-usb_interface">5.3.1. Device (struct usb_interface)<a href="#531-device-struct-usb_interface" class="hash-link" aria-label="Direct link to 5.3.1. Device (struct usb_interface)" title="Direct link to 5.3.1. Device (struct usb_interface)">​</a></h4>
<p>如上一节描述， <code>USB Interface</code> Device 对应的数据结构为 <code>struct usb_interface</code> ，会在 <code>USB Device</code> Driver 驱动 probe() 时 被创建：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_probe_device() → usb_generic_driver_probe() → usb_set_configuration():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_set_configuration(struct usb_device *dev, int configuration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 创建和初始化 `struct usb_interface` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; nintf; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (1.1) dev 总线初始化为 usb_bus_type */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.bus = &amp;usb_bus_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (1.2) dev 类型初始化为 usb_if_device_type，标明自己是一个 usb interface */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.type = &amp;usb_if_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        intf-&gt;dev.groups = usb_interface_groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 注册 `struct usb_interface` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; nintf; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = device_add(&amp;intf-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="532-driver-struct-usb_driver">5.3.2. Driver (struct usb_driver)<a href="#532-driver-struct-usb_driver" class="hash-link" aria-label="Direct link to 5.3.2. Driver (struct usb_driver)" title="Direct link to 5.3.2. Driver (struct usb_driver)">​</a></h4>
<p><code>USB Interface</code> 这一层次的驱动就非常的多了，这一层主要是在 USB 传输层之上，针对 USB Device 的某个功能 <code>Function</code> 开发对应的 USB 功能业务驱动，即常说的 <code>USB Client Software</code>。在 USB 定义中，一个 <code>Interface</code> 就是一个 <code>Function</code>。</p>
<p><code>USB Interface</code> Driver 对应的数据结构为 <code>struct usb_driver</code> ，使用 <code>usb_register_driver()</code> 函数进行注册：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register_driver(struct usb_driver *new_driver, struct module *owner,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const char *mod_name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 设置for_devices标志为0，表面这个驱动时给 usb interface 使用的 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.for_devices = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.name = new_driver-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.owner = owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.mod_name = mod_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new_driver-&gt;drvwrap.driver.dev_groups = new_driver-&gt;dev_groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spin_lock_init(&amp;new_driver-&gt;dynids.lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>一个最简单的 <code>Usb Interface Driver</code> 是 <code>usb_mouse_driver</code> :</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_device_id usb_mouse_id_table[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        USB_INTERFACE_PROTOCOL_MOUSE) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { }     /* Terminating entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_DEVICE_TABLE (usb, usb_mouse_id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct usb_driver usb_mouse_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name           = &quot;usbmouse&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .probe          = usb_mouse_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disconnect     = usb_mouse_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .id_table       = usb_mouse_id_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_usb_driver(usb_mouse_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>首先根据得到的 endpoint 准备好 urb，创建好 input 设备：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int usb_mouse_probe(struct usb_interface *intf, const struct usb_device_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_device *dev = interface_to_usbdev(intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_host_interface *interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_endpoint_descriptor *endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_mouse *mouse;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct input_dev *input_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int pipe, maxp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int error = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    interface = intf-&gt;cur_altsetting;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (interface-&gt;desc.bNumEndpoints != 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 得到当前 interface 中的第一个 endpoint，mouse设备只需一个 endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    endpoint = &amp;interface-&gt;endpoint[0].desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!usb_endpoint_is_int_in(endpoint))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse = kzalloc(sizeof(struct usb_mouse), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.1) 分配 input device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev = input_allocate_device();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!mouse || !input_dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;data = usb_alloc_coherent(dev, 8, GFP_ATOMIC, &amp;mouse-&gt;data_dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!mouse-&gt;data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3.1) 分配 urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;irq = usb_alloc_urb(0, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!mouse-&gt;irq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;usbdev = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;dev = input_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dev-&gt;manufacturer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        strlcpy(mouse-&gt;name, dev-&gt;manufacturer, sizeof(mouse-&gt;name));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dev-&gt;product) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dev-&gt;manufacturer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            strlcat(mouse-&gt;name, &quot; &quot;, sizeof(mouse-&gt;name));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        strlcat(mouse-&gt;name, dev-&gt;product, sizeof(mouse-&gt;name));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!strlen(mouse-&gt;name))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        snprintf(mouse-&gt;name, sizeof(mouse-&gt;name),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;USB HIDBP Mouse %04x:%04x&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            le16_to_cpu(dev-&gt;descriptor.idVendor),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            le16_to_cpu(dev-&gt;descriptor.idProduct));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_make_path(dev, mouse-&gt;phys, sizeof(mouse-&gt;phys));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    strlcat(mouse-&gt;phys, &quot;/input0&quot;, sizeof(mouse-&gt;phys));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.2) 初始化 input device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;name = mouse-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;phys = mouse-&gt;phys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_to_input_id(dev, &amp;input_dev-&gt;id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;dev.parent = &amp;intf-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_SIDE) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        BIT_MASK(BTN_EXTRA);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;relbit[0] |= BIT_MASK(REL_WHEEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_set_drvdata(input_dev, mouse);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;open = usb_mouse_open;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_dev-&gt;close = usb_mouse_close;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3.2) 初始化 urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_fill_int_urb(mouse-&gt;irq, dev, pipe, mouse-&gt;data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (maxp &gt; 8 ? 8 : maxp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_mouse_irq, mouse, endpoint-&gt;bInterval);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;irq-&gt;transfer_dma = mouse-&gt;data_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;irq-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.3) 注册 input device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    error = input_register_device(mouse-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_set_intfdata(intf, mouse);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fail3:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_free_urb(mouse-&gt;irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fail2:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_free_coherent(dev, 8, mouse-&gt;data, mouse-&gt;data_dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fail1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_free_device(input_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kfree(mouse);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>在 input device 被 open 时提交 urb 启动传输：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int usb_mouse_open(struct input_dev *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_mouse *mouse = input_get_drvdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mouse-&gt;irq-&gt;dev = mouse-&gt;usbdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 提交初始化好的 usb，开始查询数据 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (usb_submit_urb(mouse-&gt;irq, GFP_KERNEL))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -EIO;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>在传输完 urb 的回调函数中，根据读回的数据上报 input 事件，并且重新提交 urb 继续查询：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void usb_mouse_irq(struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_mouse *mouse = urb-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    signed char *data = mouse-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct input_dev *dev = mouse-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (urb-&gt;status) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case 0:                 /* success */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case -ECONNRESET:       /* unlink */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case -ENOENT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case -ESHUTDOWN:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* -EPIPE:  should clear the halt */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default:                /* error */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto resubmit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 根据 urb 读回的数据，上报 input event */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_key(dev, BTN_LEFT,   data[0] &amp; 0x01);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_key(dev, BTN_RIGHT,  data[0] &amp; 0x02);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_key(dev, BTN_MIDDLE, data[0] &amp; 0x04);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_key(dev, BTN_SIDE,   data[0] &amp; 0x08);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_key(dev, BTN_EXTRA,  data[0] &amp; 0x10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_rel(dev, REL_X,     data[1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_rel(dev, REL_Y,     data[2]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_report_rel(dev, REL_WHEEL, data[3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    input_sync(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">resubmit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 重新提交 urb 继续查询 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = usb_submit_urb (urb, GFP_ATOMIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (status)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dev_err(&amp;mouse-&gt;usbdev-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;can&#x27;t resubmit intr, %s-%s/input0, status %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mouse-&gt;usbdev-&gt;bus-&gt;bus_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mouse-&gt;usbdev-&gt;devpath, status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="533-usb-hub-driver">5.3.3. USB Hub Driver<a href="#533-usb-hub-driver" class="hash-link" aria-label="Direct link to 5.3.3. USB Hub Driver" title="Direct link to 5.3.3. USB Hub Driver">​</a></h4>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hub1-170676426846137.png" alt="image3" class="img_ev3q"></p>
<p>普通的 Usb Device 通过内部的 Interface 提供各种业务功能。而 Hub 这类特殊的 Usb Device 功能就一种，那就是监控端口的状态变化：</p>
<ul>
<li>在端口上有设备 attach 时，创建新的 usb device，给其适配驱动。如果是 hub device，子 usb 驱动会进一步扫描端口。</li>
<li>在端口上有设备 deattach 时，移除掉对应的 usb device。如果是 hub device 进一步移除其所有的子 usb device。</li>
</ul>
<p>Hub 也是标准的 Usb Device，它也是标准的流程被上一级设备发现后 <code>创建 Usb Device</code> → <code>创建 Usb Interface</code> ，然后被 <code>Usb Hub Interface</code> Driver 给适配到。系统中只有一个 Hub 驱动：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_device_id hub_id_table[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                | USB_DEVICE_ID_MATCH_PRODUCT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                | USB_DEVICE_ID_MATCH_INT_CLASS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .idVendor = USB_VENDOR_SMSC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .idProduct = USB_PRODUCT_USB5534B,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bInterfaceClass = USB_CLASS_HUB,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            | USB_DEVICE_ID_MATCH_INT_CLASS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .idVendor = USB_VENDOR_GENESYS_LOGIC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bInterfaceClass = USB_CLASS_HUB,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bDeviceClass = USB_CLASS_HUB},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bInterfaceClass = USB_CLASS_HUB},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    { }                                             /* Terminating entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_DEVICE_TABLE(usb, hub_id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct usb_driver hub_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name =         &quot;hub&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .probe =        hub_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disconnect =   hub_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .suspend =      hub_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .resume =       hub_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reset_resume = hub_reset_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .pre_reset =    hub_pre_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .post_reset =   hub_post_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .unlocked_ioctl = hub_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .id_table =     hub_id_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .supports_autosuspend = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>hub_driver 驱动启动以后，只做一件事情发送一个查询端口状态的 <code>urb</code> ：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">hub_probe() → hub_configure():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int hub_configure(struct usb_hub *hub,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_endpoint_descriptor *endpoint)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 分配 urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hub-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!hub-&gt;urb) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 初始化 urb，作用就是通过 ep0 查询 hub 的端口状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            urb 的回调函数是 hub_irq()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_fill_int_urb(hub-&gt;urb, hdev, pipe, *hub-&gt;buffer, maxp, hub_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hub, endpoint-&gt;bInterval);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 发送 urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hub_activate(hub, HUB_INIT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*  (3.1) 提交 urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5331-normal-hub-port-op">5.3.3.1. Normal Hub Port op<a href="#5331-normal-hub-port-op" class="hash-link" aria-label="Direct link to 5.3.3.1. Normal Hub Port op" title="Direct link to 5.3.3.1. Normal Hub Port op">​</a></h5>
<p>在普通的 hub 中，端口操作是通过标准的 urb 发起 usb ep0 读写。分为两类：</p>
<ul>
<li>通过轮询读取 Hub Class-specific Requests 配置来查询端口的状态：</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hub_get_port-170676429678339.png" alt="image4" class="img_ev3q"></p>
<ul>
<li>设置和使能端口也是通过 Hub Class-specific Requests 中相应的命令实现的：</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hub_set_port-170676430705641.png" alt="image5" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5332-roothub-port-op">5.3.3.2. RootHub Port op<a href="#5332-roothub-port-op" class="hash-link" aria-label="Direct link to 5.3.3.2. RootHub Port op" title="Direct link to 5.3.3.2. RootHub Port op">​</a></h5>
<p>而对于 roothub 来说，对端口的操作的 urb 都需要特殊处理 (以 EHCI 的驱动为例)：</p>
<ul>
<li>端口状态的变化可以通过 HCD 触发中断再上报：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ehci_irq() → usb_hcd_poll_rh_status() :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void usb_hcd_poll_rh_status(struct usb_hcd *hcd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 获取端口状态的变化 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    length = hcd-&gt;driver-&gt;hub_status_data(hcd, buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (length &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* try to complete the status urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (2) 通过回复 hcd-&gt;status_urb 来进行上报 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        urb = hcd-&gt;status_urb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (urb) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            clear_bit(HCD_FLAG_POLL_PENDING, &amp;hcd-&gt;flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hcd-&gt;status_urb = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            urb-&gt;actual_length = length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            memcpy(urb-&gt;transfer_buffer, buffer, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_hcd_unlink_urb_from_ep(hcd, urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_hcd_giveback_urb(hcd, urb, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            length = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            set_bit(HCD_FLAG_POLL_PENDING, &amp;hcd-&gt;flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hcd-&gt;driver-&gt;hub_status_data() → ehci_hub_status_data():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ehci_hub_status_data (struct usb_hcd *hcd, char *buf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.1) 通过 HCD 驱动，获取 roothub 端口的状态 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>设置和使能端口需要嫁接到 HCD 驱动相关函数上实现：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_hcd_submit_urb() → rh_urb_enqueue() → rh_call_control() → hcd-&gt;driver-&gt;hub_control() → ehci_hub_control():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int ehci_hub_control(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_hcd  *hcd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u16             typeReq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u16             wValue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u16             wIndex,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char            *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u16             wLength</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 通过 HCD 驱动，设置 roothub 的端口 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5333-device-attach">5.3.3.3. Device Attach<a href="#5333-device-attach" class="hash-link" aria-label="Direct link to 5.3.3.3. Device Attach" title="Direct link to 5.3.3.3. Device Attach">​</a></h5>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">hub_event() → port_event() → hub_port_connect_change() → hub_port_connect():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        u16 portchange)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i = 0; i &lt; PORT_INIT_TRIES; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (1) 给端口上新 Device 分配 `struct usb_device` 数据结构 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!udev) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dev_err(&amp;port_dev-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &quot;couldn&#x27;t allocate usb_device\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto done;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (2) 给新的 Device 分配一个新的 Address */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        choose_devnum(udev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (udev-&gt;devnum &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            status = -ENOTCONN;     /* Don&#x27;t retry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto loop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* reset (non-USB 3.0 devices) and get descriptor */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_lock_port(port_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (3) 使能端口，并且调用 hub_set_address() 给 Device 配置上新分配的 Address */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        status = hub_port_init(hub, udev, port1, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_unlock_port(port_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (4) 注册 `struct usb_device` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            status = usb_new_device(udev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5334-device-deattach">5.3.3.4. Device Deattach<a href="#5334-device-deattach" class="hash-link" aria-label="Direct link to 5.3.3.4. Device Deattach" title="Direct link to 5.3.3.4. Device Deattach">​</a></h5>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">hub_event() → port_event() → hub_port_connect_change() → hub_port_connect():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        u16 portchange)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 移除端口上的 `struct usb_device` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (udev) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hcd-&gt;usb_phy &amp;&amp; !hdev-&gt;parent)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_phy_notify_disconnect(hcd-&gt;usb_phy, udev-&gt;speed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_disconnect(&amp;port_dev-&gt;child);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="534-bus-usb_bus_type">5.3.4. Bus (usb_bus_type)<a href="#534-bus-usb_bus_type" class="hash-link" aria-label="Direct link to 5.3.4. Bus (usb_bus_type)" title="Direct link to 5.3.4. Bus (usb_bus_type)">​</a></h4>
<p><code>USB Interface</code> 这一层次总线也是 <code>usb_bus_type</code> ，上一节已经分析，这里就不重复解析了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="54-usb-host-controller-layer">5.4. USB Host Controller Layer<a href="#54-usb-host-controller-layer" class="hash-link" aria-label="Direct link to 5.4. USB Host Controller Layer" title="Direct link to 5.4. USB Host Controller Layer">​</a></h3>
<p>Usb Host Controller 提供了 endpoint 层级的数据收发，主要分为以下种类：</p>
<ul>
<li>Usb1.0 有两种控制器标准： <code>OHCI</code> 康柏的开放主机控制器接口， <code>UHCI</code> Intel 的通用主机控制器接口。它们的主要区别是 UHCI 更加依赖软件驱动，因此对 CPU 要求更高，但是自身的硬件会更廉价。</li>
<li>Usb2.0 只有一种控制器标准： <code>EHCI</code> 。因为 <code>EHCI</code> 只支持高速传输，所以EHCI控制器包括四个虚拟的全速或者慢速控制器。 <code>EHCI</code> 主要用于 USB 2.0，老的 USB 1.1 用 <code>OHCI</code> 和 <code>UHCI</code> 。 <code>EHCI</code> 为了兼容 USB 1.1，将老的 <code>OHCI</code> 和 <code>UHCI</code> 合并到 <code>EHCI</code> 规范里。</li>
<li>USB 3.0 控制器标准： <code>XHCI</code> 。 <code>XHCI</code> 是 Intel 最新开发的主机控制器接口，广泛用户 Intel 六代 Skylake 处理器对应的 100 系列主板上，支持 USB3.0 接口，往下也兼容 USB2.0 。 XHCI 英文全称 <code>eXtensible Host Controller Interface</code> ，是一种可扩展的主机控制器接口，是 Intel 开发的 USB 主机控制器。Intel 系列芯片的 USB 协议采用的就是 <code>XHCI</code> 主控，主要面向 USB 3.0 标准的，同时也兼容 2.0 以下的设备。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="541-aic-usb-host-controller">5.4.1. AIC USB Host Controller<a href="#541-aic-usb-host-controller" class="hash-link" aria-label="Direct link to 5.4.1. AIC USB Host Controller" title="Direct link to 5.4.1. AIC USB Host Controller">​</a></h4>
<p>ArtinChip 提供了兼 容标准 EHCI 的 USB Host Controller。</p>
<p><code>EHCI</code> 只支持 USB 2.0 高速传输，为了向下兼容 USB 1.1，它直接在内部集成最多4个全速或者慢速控制器 <code>OHCI</code>。在 <code>EHCI</code> 协议内称这种伴生的 <code>OHCI</code> 控制器为 <code>companion host controllers</code>。</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_ohci-170676434261143.png" alt="image6" class="img_ev3q"></p>
<p>由 <code>EHCI</code> 驱动根据端口速率情况来决定由谁来处理：</p>
<ul>
<li>每个端口有一个 <code>Owner</code> 属性，用来决定是 <code>EHCI</code> 管理还是 <code>OHCI</code> 管理。就是一个 <code>Switch</code> 开关，决定 USB 数据切到哪边处理。</li>
<li>初始状态时端口默认属于 <code>OHCI</code> 管理。所以对于硬件上从 <code>OHCI</code> 升级到 <code>EHCI</code> ，而软件上只有 <code>OHCI</code> 驱动而没有 <code>EHCI</code> 驱动的系统来说是透明的，它继续把 <code>EHCI</code> 当成 <code>OHCI</code> 硬件来使用就行了，保持完美的向前兼容。</li>
<li>如果系统软件上启用了 <code>EHCI</code> 驱动，它首先会把所有端口的 <code>Owner</code> 配置成 <code>EHCI</code> 管理。如果 <code>EHCI</code> 驱动发现端口连接且速率是全速或者慢速，则把端口的 <code>Owner</code> 配置成 <code>OHCI</code> 管理。</li>
</ul>
<p>对于 EHCI 这种包含两种控制器的兼容方式，软件上需要同时启动 EHCI Driver 和 OHCI Driver，才能完整的兼容 USB 1.0 和 USB 2.0：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_ohci_sw-170676434898945.png" alt="image7" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="542-ehci-内部结构">5.4.2. EHCI 内部结构<a href="#542-ehci-内部结构" class="hash-link" aria-label="Direct link to 5.4.2. EHCI 内部结构" title="Direct link to 5.4.2. EHCI 内部结构">​</a></h4>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule-170676435836747.png" alt="image8" class="img_ev3q"></p>
<p>EHCI 的核心就是把数据传输分成了两类来进行调度：</p>
<ul>
<li><code>Asynchronous Schedule</code>。用来传输对时间延迟要求不高的 Endpoint 数据，包括 <code>Control Transfer</code> 和 <code>Bulk Transfer</code>。</li>
<li><code>Periodic Schedule</code>。用来传输对时间延迟要求高的 Endpoint 数据，包括 <code>Isochronous Transfer</code> 和 <code>Interrupt Transfer</code>。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5421-asynchronous-queue-schedule">5.4.2.1. Asynchronous Queue Schedule<a href="#5421-asynchronous-queue-schedule" class="hash-link" aria-label="Direct link to 5.4.2.1. Asynchronous Queue Schedule" title="Direct link to 5.4.2.1. Asynchronous Queue Schedule">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_async-170676441968351.png" alt="image9" class="img_ev3q"></p>
<p><code>Asynchronous Schedule</code> 内部实现非常的简单就只有一级链表，链表中只有 <code>Queue Head</code> 类型的描述符。每个时间片内传输完 Period 数据以后，再尽可能的传输 Asynchronous 数据即可。</p>
<p>核心的描述符如下：</p>
<ul>
<li>Queue Head</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_qh-170676447313453.png" alt="image10" class="img_ev3q"></p>
<ul>
<li>Queue Element Transfer Descriptor (qTD)</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_qtd-170676448884155.png" alt="image11" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5422-periodic-queue-schedule">5.4.2.2. Periodic Queue Schedule<a href="#5422-periodic-queue-schedule" class="hash-link" aria-label="Direct link to 5.4.2.2. Periodic Queue Schedule" title="Direct link to 5.4.2.2. Periodic Queue Schedule">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_period-170676452863457.png" alt="image12" class="img_ev3q"></p>
<p><code>Periodic Schedule</code> 内部实现如上图所示，核心是两级链表：</p>
<ul>
<li>第一级链表如上图 <code>绿色</code> 所示。是各种传输结构的实际描述符，主要包含以下几种类型的描述符：</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_period_type-170676454719259.png" alt="image13" class="img_ev3q"></p>
<ul>
<li>第二级链表如上图 <code>橙色</code> 所示。是一个指针数组，数组中保存的是指向第一级链表的指针。这里每个数组成员代表一个时间分片 Frame/Micro-Frame 的起始位置，每个时间片会根据指针传输第一级链表中的数据，直到第一级链表的结尾。指针的格式如下：</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_period_framelist-170676455945561.png" alt="image14" class="img_ev3q"></p>
<p>注解</p>
<p>这里的调度思想就是：第一级链表是一个传输数据全集，第二级链表决定了某个时间片里要传输的数据。</p>
<p>这样合理的安排二级链表的指针，比如间隔 8 次指向同一位置这部分数据的 interval 就是 8，间隔 4 次指向同一位置这部分数据的 interval 就是 4。 第一级链表也是要根据 interval 排序的。</p>
<p><code>Periodic Schedule</code> 核心的描述符除了 QH、QTD 还有 ITD：</p>
<ul>
<li>Isochronous (High-Speed) Transfer Descriptor (iTD)</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_itd-170676457166363.png" alt="image15" class="img_ev3q"></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="543-ehci-driver">5.4.3. EHCI Driver<a href="#543-ehci-driver" class="hash-link" aria-label="Direct link to 5.4.3. EHCI Driver" title="Direct link to 5.4.3. EHCI Driver">​</a></h4>
<p>ehci driver 负责把 echi 功能封装成标准的 hcd 驱动。它主要完成两项工作：</p>
<ul>
<li>注册标准的 hcd 驱动。把 <code>Client Software</code> 传送下来的 <code>urb</code> 映射到 EHCI 的链表中进行传输。</li>
<li>创建一个虚拟的根 hub 设备，即 roothub。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5431-urb-transfer">5.4.3.1. URB Transfer<a href="#5431-urb-transfer" class="hash-link" aria-label="Direct link to 5.4.3.1. URB Transfer" title="Direct link to 5.4.3.1. URB Transfer">​</a></h5>
<p>ehci 注册 hcd 驱动：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int ehci_platform_probe(struct platform_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 分配 hcd，并且把 hcd-&gt;driver 初始化成 ehci_hc_driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ehci_init_driver(&amp;ehci_platform_hc_driver, &amp;platform_overrides);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hcd = usb_create_hcd(&amp;ehci_platform_hc_driver, &amp;dev-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dev_name(&amp;dev-&gt;dev));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 注册标准的 hcd 驱动 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    err = usb_add_hcd(hcd, irq, IRQF_SHARED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>hcd 驱动向上提供了标准接口，最终的实现会调用到 <code>ehci_hc_driver</code> 当中。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct hc_driver ehci_hc_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .description =          hcd_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .product_desc =         &quot;EHCI Host Controller&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .hcd_priv_size =        sizeof(struct ehci_hcd),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * generic hardware linkage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .irq =                  ehci_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .flags =                HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * basic lifecycle operations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reset =                ehci_setup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .start =                ehci_run,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .stop =                 ehci_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .shutdown =             ehci_shutdown,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * managing i/o requests and associated device resources</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .urb_enqueue =          ehci_urb_enqueue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .urb_dequeue =          ehci_urb_dequeue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .endpoint_disable =     ehci_endpoint_disable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .endpoint_reset =       ehci_endpoint_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .clear_tt_buffer_complete =     ehci_clear_tt_buffer_complete,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * scheduling support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .get_frame_number =     ehci_get_frame,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * root hub support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .hub_status_data =      ehci_hub_status_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .hub_control =          ehci_hub_control,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bus_suspend =          ehci_bus_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bus_resume =           ehci_bus_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .relinquish_port =      ehci_relinquish_port,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .port_handed_over =     ehci_port_handed_over,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .get_resuming_ports =   ehci_get_resuming_ports,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    * device support</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .free_dev =             ehci_remove_device,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 urb transfer 过程中，最核心 的是调用上述的 <code>ehci_urb_enqueue()</code> 和 <code>ehci_urb_dequeue()</code> 函数。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="5432-roothub">5.4.3.2. Roothub<a href="#5432-roothub" class="hash-link" aria-label="Direct link to 5.4.3.2. Roothub" title="Direct link to 5.4.3.2. Roothub">​</a></h5>
<p>首先创建虚拟的 roothub:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* (1) 首先创建和初始化 `usb_device` 结构： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ehci_platform_probe() → usb_add_hcd() → usb_alloc_dev():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_device *usb_alloc_dev(struct usb_device *parent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct usb_bus *bus, unsigned port1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.1) dev 总线初始化为 usb_bus_type */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.bus = &amp;usb_bus_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.2) dev 类型初始化为 usb_device_type，标明自己是一个 usb device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.type = &amp;usb_device_type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev-&gt;dev.groups = usb_device_groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (2) 然后注册  `usb_device` 结构： */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_add_hcd() → register_root_hub() → usb_new_device() → device_add()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>然后因为 roothub 并不是在 Usb 物理总线上，所以对它的查询和配置需要特殊处理。详见 <code>Usb Hub Driver</code> 这一节。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-usb-device-子系统代码架构">6. USB Device 子系统代码架构<a href="#6-usb-device-子系统代码架构" class="hash-link" aria-label="Direct link to 6. USB Device 子系统代码架构" title="Direct link to 6. USB Device 子系统代码架构">​</a></h2>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_flow_detail1-170676467857865.png" alt="image0" class="img_ev3q"></p>
<p> 整个 USB 系统的通讯模型如上图所示，Device 框架见右侧彩图部分。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-usb-device-controller-layer">6.1. USB Device Controller Layer<a href="#61-usb-device-controller-layer" class="hash-link" aria-label="Direct link to 6.1. USB Device Controller Layer" title="Direct link to 6.1. USB Device Controller Layer">​</a></h3>
<p>上述软件栈的最底层是 UDC (USB Device Controller)，UDC 层最主要的作用是提供一个 endpoint 资源池，负责处理 endpoint 层级的数据收发。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="611-aic-usb-device-controller">6.1.1. AIC USB Device Controller<a href="#611-aic-usb-device-controller" class="hash-link" aria-label="Direct link to 6.1.1. AIC USB Device Controller" title="Direct link to 6.1.1. AIC USB Device Controller">​</a></h4>
<p>ArtinChip UDC 在硬件层面实现了以下功能：</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6111-data-mode">6.1.1.1. Data Mode<a href="#6111-data-mode" class="hash-link" aria-label="Direct link to 6.1.1.1. Data Mode" title="Direct link to 6.1.1.1. Data Mode">​</a></h5>
<p>UDC 实现的一项主要工作是数据搬移：</p>
<ul>
<li>UDC 发送时，数据先从内存 Memory 搬移到 UDC 的内部 FIFO 当中，然后由 UDC 发送到 USB 物理线路上。</li>
<li>UDC 接收时，数据先从 USB 物理线路接收到 UDC 的内部 FIFO 当中，然后再从 FIFO 拷贝到 内存 Memory 当中。</li>
</ul>
<p>对于 <code>FIFO</code> 和 <code>Memory</code> 之间的数据搬移工作，当前 UDC 支持两种方式：</p>
<ul>
<li>DMA Mode。</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_mode_dma-170676470897567.png" alt="image1" class="img_ev3q"></p>
<p>由 UDC 内部的 DMA 模块来承担数据搬移工作，只要使用寄存器配置好 FIFO 的分配，以及在寄存器中配置好 DMA 的其实地址，DMA 会完成数据的搬移。</p>
<ul>
<li>Slave Mode。</li>
</ul>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_mode_slave-170676471760269.png" alt="image2" class="img_ev3q"></p>
<p>也可以不使用 DMA 而直接使用 CPU 来搬移，这种方式非常消耗 CPU 的带宽，CPU 被简单重复的数据拷贝拖住不能做其他的事情。这种方式一般用于 Debug 模式。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6112-endpoint-fifo-mode">6.1.1.2. Endpoint FIFO Mode<a href="#6112-endpoint-fifo-mode" class="hash-link" aria-label="Direct link to 6.1.1.2. Endpoint FIFO Mode" title="Direct link to 6.1.1.2. Endpoint FIFO Mode">​</a></h5>
<p>不同的 UDC 中 Endpoint 对 FIFO 的使用有多种模式，当前 UDC 选用的是 <code>Shared Transmit FIFO</code> 模式。在 <code>Shared Transmit FIFO</code> 模式中， <code>Endpoint</code> 对 <code>FIFO</code> 使用模式如下：</p>
<ul>
<li>所有的 <code>non-periodic IN endpoints</code> 共享一个 <code>transmit FIFO</code> 。 <code>non-periodic endpoints</code> 包括 <code>isochronous transfers</code> 和 <code>interrupt transfers</code>。</li>
<li>每一个 <code>periodic IN endpoint</code> 独立拥有一个 <code>transmit FIFO</code> 。 <code>periodic endpoints</code> 包括 <code>bulk transfers</code> 和 <code>control transfers</code>。</li>
<li>所有的 <code>OUT endpoints</code> 共享一个 <code>receive FIFO</code>。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6113-endpoint-resource">6.1.1.3. Endpoint Resource<a href="#6113-endpoint-resource" class="hash-link" aria-label="Direct link to 6.1.1.3. Endpoint Resource" title="Direct link to 6.1.1.3. Endpoint Resource">​</a></h5>
<p>USB 协议定义一个 Device 最多可以实现 16 个 IN endpoint + 16 个 OUT endpoint。当前 UDC 实现了 5 个 IN endpoint + 5 个 OUT endpoint，除了 endpoint 0 IN/OUT 被系统默认使用，剩下的可以被驱动动态分配使用。</p>
<p>如上一节所描述，UDC 是 <code>Shared Transmit FIFO</code> 模式， <code>periodic IN endpoint</code> 需要拥有一个独立的 <code>transmit FIFO</code>。当前 UDC 拥有两个这样的 <code>transmit FIFO</code> 资源，供驱动动态分配。</p>
<p>如果驱动创建一个 <code>periodic IN endpoint</code> 它分配到了第一个 <code>endpoint</code> 资源，但是没有分配到 <code>transmit FIFO</code> 资源，也会创建失败。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6114-calculating-fifo-size">6.1.1.4. Calculating FIFO Size<a href="#6114-calculating-fifo-size" class="hash-link" aria-label="Direct link to 6.1.1.4. Calculating FIFO Size" title="Direct link to 6.1.1.4. Calculating FIFO Size">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_fifo_size-170676474040571.png" alt="image3" class="img_ev3q"></p>
<p>由上几节的描述可以看到，UDC 有多个模块需要使用内部 FIFO。包括：</p>
<ul>
<li>OUT endpoints RxFIFO</li>
<li>IN non-periodic endpoints TxFIFO</li>
<li>IN periodic endpoints TxFIFO</li>
<li>DMA</li>
</ul>
<p>UDC 内部 FIFO 总大小是固定的，那么怎么样来分配 FIFO 空间给这些模块呢？ UDC 提供了以下计算公式：</p>
<ul>
<li>Receive FIFO RAM allocation</li>
</ul>
<blockquote>
<p>RAM for SETUP Packets: 4 * n + 6 locations in Scatter/Gather DMA mode and 5 * n+6 locations in Slave and Buffer DMA mode must be reserved in the RxFIFO to receive up to n SETUP packets on control endpoints, where n is the number of control endpoints the device core supports. The core does not use these locations, which are Reserved for SETUP packets, to write any other data.</p>
<p>// Setup 包的保留 RAM 空间(DMA 模式)： 5*n + 6 locations，n 为 control endpoints 的个数。该部分只为 SETUP 包保留，不会写入其他数据。</p>
<p>One location for Global OUT NAK</p>
<p>// Global OUT NAK: 1 location</p>
<p>Status information is written to the FIFO along with each received packet. Therefore, a minimum space of (Largest Packet Size / 4) + 1 must be allotted to receive packets. If a high-bandwidth endpoint is enabled, or multiple isochronous endpoints are enabled, then at least two (Largest Packet Size / 4) + 1 spaces must be allotted to receive back-to-back packets. Typically, two (Largest Packet Size / 4) + 1 spaces are recommended so that when the previous packet is being transferred to AHB, the USB can receive the subsequent packet. If AHB latency is high, you must allocate enough space to receive multiple packets. This is critical to prevent dropping of any isochronous packets.</p>
<p>// 包接收空间： 最少 (Largest Packet Size / 4) + 1 spaces，如果空间充裕使用 two (Largest Packet Size / 4) + 1 spaces</p>
<p>Along with each endpoint’s last packet, transfer complete status information is also pushed to the FIFO. Typically, one location for each OUT endpoint is recommended.</p>
<p>// 对于每个 OUT endpoint ，最后一个包需要一个位置存放 transfer complete status information</p>
<p>An additional endpoint for each EPDisable is also required.</p>
<p>// 对于每个 OUT endpoint ，还需要一个位置存放 EPDisable</p>
<p>计算公式：</p>
<p>Device RxFIFO = (5 * number of control endpoints + 8) + ((largest USB packet used / 4) + 1 for status information) + (2 * number of OUT endpoints) + 1 for Global NAK</p>
</blockquote>
<ul>
<li>Transmit FIFO RAM allocation</li>
</ul>
<blockquote>
<p>The RAM size for the Periodic Transmit FIFO must equal the maximum amount of data that can be transmitted in a single microframe. The core does not use any data RAM allocated over this requirement, and when data RAM allocated is less than this requirement, the core can malfunction.</p>
<p>// Periodic Transmit FIFO RAM大小必须等于在单个微帧中可以传输的最大数据量。核心不使用任何分配给这个需求的数据RAM，当分配的数据RAM小于这个需求时，核心可能会发生故障。</p>
<p>The minimum amount of RAM required for the Non-periodic Transmit FIFO is the largest maximum packet size among all supported non-periodic IN endpoints.</p>
<p>// Non-periodic Transmit FIFO 最小RAM数量是所有支持的非周期IN端点中最大的包大小。</p>
<p>More space allocated in the Transmit Non-periodic FIFO results in better performance on the USB and can hide AHB latencies. Typically, two Largest Packet Sizes’ worth of space is recommended, so that when the current packet is under transfer to the USB, the AHB can get the next packet. If the AHB latency is large, then you must allocate enough space to buffer multiple packets.</p>
<p>// Transmit Non-periodic FIFO 中分配更多的空间，可以在USB上获得更好的性能，并可以隐藏AHB延迟。通常，建议使用两个最大包大小的空间，以便当当前包正在传输到USB时，AHB可以获得下一个包。如果AHB延迟较大，则必须分配足够的空间来缓冲多个包。</p>
<p>It is assumed that i number of periodic FIFOs is implemented in Device mode.</p>
<p>// i 是 periodic FIFOs 的个数。</p>
<p>计算公式：</p>
<p>Non-Periodic TxFIFO = largest non-periodic USB packet used / 4</p>
<p>Periodic Endpoint-Specific TxFIFOs= largest periodic USB packet used for an endpoint / 4</p>
</blockquote>
<ul>
<li>Internal Register Storage Space Allocation</li>
</ul>
<blockquote>
<p>When operating in Internal DMA mode, the core stores the Endpoint DMA address register (DI/OEPDMA) in the SPRAM. One location must be allocated for each endpoint.</p>
<p>// 当在内部DMA模式下运行时，核心将端点DMA地址寄存器(DI/OEPDMA)存储在SPRAM中。必须为每个端点分配一个位置。</p>
<p>For example, if an endpoint is bidirectional, then two locations must be allocated. If an endpoint is IN or OUT, then only one location must be allocated.</p>
<p>// 例如，如果一个端点是双向的，那么必须分配两个位置。如果端点是IN或OUT，则必须只分配一个位置。</p>
</blockquote>
<p><strong>Example</strong></p>
<p>The MPS is 1,024 bytes for a <code>periodic USB packet</code> and 512 bytes for a <code>non-periodic USB packet</code>. There are three <code>OUT endpoints</code>, three <code>IN endpoints</code>, one <code>control endpoint</code>.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Device RxFIFO = (5 * 1 + 8) + ((1,024 / 4) +1) + (2 * 4) + 1 = 279</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Non-Periodic TxFIFO = (512 / 4) = 128</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Device Periodic TxFIFO:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 1 = (1,024 / 4) = 256</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 2 = (1,024 / 4) = 256</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 3 = (1,024 / 4) = 256</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>当前 UDC</strong></p>
<p>The MPS is 1,024 bytes for a <code>periodic USB packet</code> and 1024 bytes for a <code>non-periodic USB packet</code>. There are 4 <code>OUT endpoints</code>, 4 <code>IN endpoints</code>, 1 <code>control endpoint</code>.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Device RxFIFO = (5 * 1 + 8) + ((1,024 / 4) +1) + (2 * 5) + 1 = 281 = 0x119</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Non-Periodic TxFIFO = (1024 / 4) = 256 = 0x100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Device Periodic TxFIFO:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 1 = (1,024 / 4) = 256 = 0x100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 2 = remain space = 0x3F6 - 0x119 - 0x100 - 0x100 = 0xDD</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Internal Register Storage Space = 5 * 2 = 10 = 0xA</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>或者：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Device RxFIFO = (5 * 1 + 8) + ((1,024 / 4) +1) + (2 * 5) + 1 = 281 = 0x119</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Non-Periodic TxFIFO = (1024 / 4) = 256 = 0x200</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Device Periodic TxFIFO:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 1 = (0x3F6 - 0x119 - 0x200) / 2 = 0x6E</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> EP 2 = (0x3F6 - 0x119 - 0x200) / 2 = 0x6E</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Internal Register Storage Space = 5 * 2 = 10 = 0xA</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6115-fifo-mapping">6.1.1.5. FIFO Mapping<a href="#6115-fifo-mapping" class="hash-link" aria-label="Direct link to 6.1.1.5. FIFO Mapping" title="Direct link to 6.1.1.5. FIFO Mapping">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_fifo_mapping-170676477619873.png" alt="image4" class="img_ev3q"></p>
<p>由上几节可知对一个端点 Endpoint 来说，它对应的 FIFO 是动态分配的。在 DMA 模式下，一旦初始化时配置完成就不用再去管 Endpoint FIFO 的地址。但是对 Slave 模式来说，在数据收发过程中需要 CPU 访问对应 FIFO 空间。</p>
<p>为了方便 CPU 对 Endpoint FIFO 的访问，UDC 把 Endpoint FIFO 映射到了固定地址。其中读操作会映射到 OUT Endpoint FIFO，写操作会映射到 IN Endpoint FIFO。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6116-interrupt-cascade">6.1.1.6. Interrupt Cascade<a href="#6116-interrupt-cascade" class="hash-link" aria-label="Direct link to 6.1.1.6. Interrupt Cascade" title="Direct link to 6.1.1.6. Interrupt Cascade">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_interrupt-170676478596475.png" alt="image5" class="img_ev3q"></p>
<p>由于 UDC 的中断状态较多，所以分成 3 级级联：</p>
<ul>
<li>layer1: <code>GINTSTS</code> &amp; <code>GINTMSK</code> 。全局中断，每一 bit 表示一个全局中断状态。其中： <code>OEPInt</code> 表示有 <code>Out Endpoint</code> 中断发生 ， <code>IEPInt</code> 表示有 <code>In Endpoint</code> 中断发生。</li>
<li>layer2: <code>DAINT</code> &amp; <code>DAINTMSK</code> 。Endpoint 中断，每一 bit 表示一个 Endpoint 发生了中断。</li>
<li>layer3: <code>DOEPINTn</code> &amp; <code>DOEPMSK</code> ， <code>DIEPINTn</code> &amp; <code>DIEPMSK</code> 。Endpoint 中断细节，每一个 Endpoint 拥有一组这样的寄存器。 寄存器中的每一 bit 代表某个 Endpoint 的某种中断状态。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6117-data-transfer">6.1.1.7. Data Transfer<a href="#6117-data-transfer" class="hash-link" aria-label="Direct link to 6.1.1.7. Data Transfer" title="Direct link to 6.1.1.7. Data Transfer">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_trandfer-170676480019777.png" alt="image6" class="img_ev3q"></p>
<p>UDC 内部的数据收发流程如上图所示。主要的工作就是根据 USB 接收到的读写指令，把数据在 FIFO 和 Memory 之间进行搬移。具体分为几种情况：</p>
<ul>
<li>OUT Endpoint。所有 OUT Endpoint 的线路数据会接收到一个统一的 <code>Rx FIFO</code> 当中，然后根据接收数据的具体 Endpoint配置的 Memory 地址和长度，DMA 把数据从 FIFO 搬移到对应 Memory 当中，最后产生中断。</li>
<li>IN Non-period Endpoint。所有 IN Non-period Endpoint 共享一个统一的 <code>Tx Non-period FIFO</code> ，根据Endpoint配置的 Memory 地址和长度，DMA 把数据从 Memory 搬移到统一的 FIFO 当中，发送到线路上后产生中断。IN Non-period Endpoint 需要配置 <code>Next Endpoint</code> 指针，这样 DMA处理完一个 Endpoint 的数据后才知道下一个需要处理的 Endpoint。</li>
<li>IN Period Endpoint。每一个 IN Period Endpoint 拥有自己独立的 FIFO，根据Endpoint配置的 Memory 地址和长度，DMA 把数据从 Memory 搬移到对应的 FIFO 当中，发送到线路上后产生中断。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="612-aic-udc-driver">6.1.2. AIC UDC Driver<a href="#612-aic-udc-driver" class="hash-link" aria-label="Direct link to 6.1.2. AIC UDC Driver" title="Direct link to 6.1.2. AIC UDC Driver">​</a></h4>
<p><code>UDC Driver</code> 在需要完成的工作有两点：</p>
<ul>
<li>把 UDC 硬件注册成标准的 Gadget Device，以便提供标准的 Gadget API 给 Gadget Function 驱动来使用。</li>
<li>提供 endpoint 资源池，处理 endpoint 层级的数据收发。</li>
<li>需要处理部分 Endpoint0 Setup 逻辑。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6121-init">6.1.2.1. Init<a href="#6121-init" class="hash-link" aria-label="Direct link to 6.1.2.1. Init" title="Direct link to 6.1.2.1. Init">​</a></h5>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_init-170676481980279.png" alt="image7" class="img_ev3q"></p>
<p>UDC 驱动把资源初始化好以后，注册成一个标准的 gadget 设备。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6122-gadgetops">6.1.2.2. gadget.ops<a href="#6122-gadgetops" class="hash-link" aria-label="Direct link to 6.1.2.2. gadget.ops" title="Direct link to 6.1.2.2. gadget.ops">​</a></h5>
<p>UDC 驱动需要提供 gadget 设备的操作函数集 <code>gadget.ops</code>。简单定义如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_gadget_ops aic_usb_gadget_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .get_frame              = aic_gg_getframe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .udc_start              = aic_gg_udc_start,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .udc_stop               = aic_gg_udc_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .pullup                 = aic_gg_pullup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .vbus_session           = aic_gg_vbus_session,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .vbus_draw              = aic_gg_vbus_draw,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中的核心函数为 <code>.udc_start()</code> ，在调用该函数以后 UDC 才真正进入工作状态。其主要流程如下：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_start-170676484417081.png" alt="image8" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6123-epops">6.1.2.3. ep.ops<a href="#6123-epops" class="hash-link" aria-label="Direct link to 6.1.2.3. ep.ops" title="Direct link to 6.1.2.3. ep.ops">​</a></h5>
<p>UDC 驱动需要提供 endpoint 的操作函数集 <code>ep.ops</code>。简单定义如下：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_ep_ops aic_usb_ep_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .enable                 = aic_ep_enable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disable                = aic_ep_disable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .alloc_request          = aic_ep_alloc_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .free_request           = aic_ep_free_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .queue                  = aic_ep_queue_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .dequeue                = aic_ep_dequeue_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .set_halt               = aic_ep_sethalt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中 <code>.queue()</code> 函数负责接收 Gadget Function 驱动发送下来的 <code>usb_request</code>。其主要流程如下：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_queue-170676485559783.png" alt="image9" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6124-interrupt">6.1.2.4. Interrupt<a href="#6124-interrupt" class="hash-link" aria-label="Direct link to 6.1.2.4. Interrupt" title="Direct link to 6.1.2.4. Interrupt">​</a></h5>
<p>UDC 驱动主要承担的是数据收发，在上一节收到 <code>usb_request</code> 请求以后，接下来就是等待硬件处理完成产生中断了。中断处理的主要流程如下：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_interrupt_flow-170676486451685.png" alt="image10" class="img_ev3q"></p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6125-ep0-setup">6.1.2.5. EP0 Setup<a href="#6125-ep0-setup" class="hash-link" aria-label="Direct link to 6.1.2.5. EP0 Setup" title="Direct link to 6.1.2.5. EP0 Setup">​</a></h5>
<p>UDC 驱动还有一项重要工作就是负责 EP0 Control 状态机的处理。USB ep0 上的 Control Transfer 处理分为3个阶段： <code>Setup Stage</code> 、 <code>Data In/Out Stage</code> 、 <code>Status In/Out Stage</code> 。具体对应以下 5 种状态：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* Gadget ep0 states */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum ep0_state {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EP0_SETUP,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EP0_DATA_IN,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EP0_DATA_OUT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EP0_STATUS_IN,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    EP0_STATUS_OUT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这几种状态之间的转换流程如下所示：</p>
<p><img loading="lazy" src="https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_ep0_control-170676488914487.png" alt="image11" class="img_ev3q"></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-usb-device-layer">6.2. USB Device Layer<a href="#62-usb-device-layer" class="hash-link" aria-label="Direct link to 6.2. USB Device Layer" title="Direct link to 6.2. USB Device Layer">​</a></h3>
<p>Linux 使  用了一个 <code>Gadget</code> 的概念来组织 USB Device。</p>
<p>Gadget Layer 层把 UDC 提供的 endpoint 封装成标准的 Gadget Device，提供统一的向上接口。</p>
<p>Gadget Driver 又把各式各样的 Function 和 Gadget Device 链接起来。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="621-gadget-bus">6.2.1. Gadget Bus<a href="#621-gadget-bus" class="hash-link" aria-label="Direct link to 6.2.1. Gadget Bus" title="Direct link to 6.2.1. Gadget Bus">​</a></h4>
<p>Gadget Layer 层没有定义一个标准的 Bus 总线，而是自定义了两条链表来分别存储 Device 和 Driver：</p>
<table><thead><tr><th>type</th><th>list</th><th>escript</th></tr></thead><tbody><tr><td>Device</td><td>udc_list</td><td>所有Device全集</td></tr><tr><td>Driver</td><td>gadget_driver_pending_list</td><td>只包含没有适配Device的Driver</td></tr></tbody></table>
<p>它们的使用场景如下：</p>
<ul>
<li>在 Gadget Device 创建时，首先把 Device 加入到 <code>udc_list</code> 链表，然后尝试和 <code>gadget_driver_pending_list</code> 链表中的 Driver 进行 match():</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_add_gadget_udc() → usb_add_gadget_udc_release() → usb_add_gadget():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_add_gadget(struct usb_gadget *gadget)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 将 device 加入全局链表 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list_add_tail(&amp;udc-&gt;list, &amp;udc_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* pick up one of pending gadget drivers */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 尝试 match gadget 的 device 和 driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = check_pending_gadget_drivers(udc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto err_del_udc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_unlock(&amp;udc_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int check_pending_gadget_drivers(struct usb_udc *udc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_gadget_driver *driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.1) 遍历 `gadget_driver_pending_list` 链表中的 Driver，和 Device 进行 match()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            且一个 Driver 只能 match 一个 Device，Driver match 成功后会从链表删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list_for_each_entry(driver, &amp;gadget_driver_pending_list, pending)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!driver-&gt;udc_name || strcmp(driver-&gt;udc_name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        dev_name(&amp;udc-&gt;dev)) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* (2.2) Match 成功，对 Device 和 Driver 进行 bind() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = udc_bind_to_driver(udc, driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (ret != -EPROBE_DEFER)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                /* (2.3) Driver Match 成功后，从pending链表删除 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                list_del_init(&amp;driver-&gt;pending);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>在 Gadget Driver 创建时，首先尝试和 <code>udc_list</code> 链表中的 Device 进行 match()，match() 不成功则把 Driver 加入到 <code>gadget_driver_pending_list</code> 链表中:</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gadget_dev_desc_UDC_store() → usb_gadget_probe_driver():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_probe_driver(struct usb_gadget_driver *driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_udc          *udc = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                     ret = -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!driver || !driver-&gt;bind || !driver-&gt;setup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_lock(&amp;udc_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.1) 如果 Driver 有 udc_name，尝试和 udc_list 链表中 Device 的 Name 进行 match()  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (driver-&gt;udc_name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list_for_each_entry(udc, &amp;udc_list, list) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = strcmp(driver-&gt;udc_name, dev_name(&amp;udc-&gt;dev));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else if (udc-&gt;driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = -EBUSY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto found;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1.2) 如果 Driver 没有 udc_name，尝试适配 udc_list 链表中第一个没有适配的 Device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list_for_each_entry(udc, &amp;udc_list, list) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* For now we take the first one */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!udc-&gt;driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                goto found;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!driver-&gt;match_existing_only) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* (2) 如果没有 match() 成功，则把 Driver 加入到 pending 链表 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list_add_tail(&amp;driver-&gt;pending, &amp;gadget_driver_pending_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_info(&quot;udc-core: couldn&#x27;t find an available UDC - added [%s] to list of pending drivers\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            driver-&gt;function);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_unlock(&amp;udc_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_warn(&quot;udc-core: couldn&#x27;t find an available UDC or it&#x27;s busy\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">found:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 如果 Match 成功，对 Device 和 Driver 进行 bind() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = udc_bind_to_driver(udc, driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_unlock(&amp;udc_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>在 Device 和 Driver Match 成功时的 bind() 动作：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev_dbg(&amp;udc-&gt;dev, &quot;registering UDC driver [%s]\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            driver-&gt;function);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 数据成员的赋值 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    udc-&gt;driver = driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    udc-&gt;dev.driver = &amp;driver-&gt;driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    udc-&gt;gadget-&gt;dev.driver = &amp;driver-&gt;driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 调用 Gadget Driver 的 bind() 函数 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = driver-&gt;bind(udc-&gt;gadget, driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto err1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 调用 Gadget Device 的 start() 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            udc-&gt;gadget-&gt;ops-&gt;udc_start(udc-&gt;gadget, udc-&gt;driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = usb_gadget_udc_start(udc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        driver-&gt;unbind(udc-&gt;gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto err1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (4) 调用 Gadget Device 的 pullup() 函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gadget-&gt;ops-&gt;pullup(gadget, 1/0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    usb_udc_connect_control(udc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>注意：这里和一般的 Device 和 Driver 的适配规则有些不一样。一般的规则是一个 Dirver 可以适配多个 Device，而一个 Device 只能适配一个 Driver。而这里的规则是一个 Gadget Device 只能适配一个 Gadget Driver，而一个 Gadget Driver 只能适配一个 Gadget Device。 Gadget Driver 代表的是一个 <code>Composite Device</code>。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="622-gadget-device">6.2.2. Gadget Device<a href="#622-gadget-device" class="hash-link" aria-label="Direct link to 6.2.2. Gadget Device" title="Direct link to 6.2.2. Gadget Device">​</a></h4>
<p>上一节说过 Gadget Device 由 UDC Driver 创建。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dwc2_driver_probe() → usb_add_gadget_udc() → usb_add_gadget_udc_release() → usb_add_gadget()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Gadget Device 的主要作用是提供了 Endpoint 资源，供 Function Layer 使用标准的 Gadget API   来进行访问。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6221-endpoint-alloc">6.2.2.1. Endpoint Alloc<a href="#6221-endpoint-alloc" class="hash-link" aria-label="Direct link to 6.2.2.1. Endpoint Alloc" title="Direct link to 6.2.2.1. Endpoint Alloc">​</a></h5>
<p>UDC Driver 在调用 usb_add_gadget_udc() 注册 Gadget Device 之前，初始化了 Gadget 的 Endpoint 资源链表：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dwc2_driver_probe() → dwc2_gadget_init():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int dwc2_gadget_init(struct dwc2_hsotg *hsotg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 初始化 Gadget Device 的 Endpoint 资源链表为空  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INIT_LIST_HEAD(&amp;hsotg-&gt;gadget.ep_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hsotg-&gt;gadget.ep0 = &amp;hsotg-&gt;eps_out[0]-&gt;ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* initialise the endpoints now the core has been initialised */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 初始化 UDC 拥有的 Endpoint，加入到 Gadget Device 的 Endpoint 资源链表中 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (epnum = 0; epnum &lt; hsotg-&gt;num_of_eps; epnum++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hsotg-&gt;eps_in[epnum])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dwc2_hsotg_initep(hsotg, hsotg-&gt;eps_in[epnum],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    epnum, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hsotg-&gt;eps_out[epnum])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dwc2_hsotg_initep(hsotg, hsotg-&gt;eps_out[epnum],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    epnum, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct dwc2_hsotg_ep *hs_ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int epnum,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    bool dir_in)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INIT_LIST_HEAD(&amp;hs_ep-&gt;queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INIT_LIST_HEAD(&amp;hs_ep-&gt;ep.ep_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* add to the list of endpoints known by the gadget driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.1) UDC 中除了 endpoint0 以外，其他的 endpoint 都加入到Gadget Device 的 Endpoint 资源链表 `gadget.ep_list` 中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            endpoint0 的操作由 UDC 驱动自己来处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (epnum)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list_add_tail(&amp;hs_ep-&gt;ep.ep_list, &amp;hsotg-&gt;gadget.ep_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.2) 初始化 endpoint 的结构体成员 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hs_ep-&gt;parent = hsotg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hs_ep-&gt;ep.name = hs_ep-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (hsotg-&gt;params.speed == DWC2_SPEED_PARAM_LOW)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_ep_set_maxpacket_limit(&amp;hs_ep-&gt;ep, 8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_ep_set_maxpacket_limit(&amp;hs_ep-&gt;ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    epnum ? 1024 : EP0_MPS_LIMIT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.3) endpoint 最重要的结构体成员，endpoint 操作函数集</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        endpoint 的相关操作最后调用到这些函数上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hs_ep-&gt;ep.ops = &amp;dwc2_hsotg_ep_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (epnum == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hs_ep-&gt;ep.caps.type_control = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (hsotg-&gt;params.speed != DWC2_SPEED_PARAM_LOW) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hs_ep-&gt;ep.caps.type_iso = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            hs_ep-&gt;ep.caps.type_bulk = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hs_ep-&gt;ep.caps.type_int = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dir_in)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hs_ep-&gt;ep.caps.dir_in = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hs_ep-&gt;ep.caps.dir_out = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Gadget Device 准备好了 Endpoint 资源链表以后，通过 usb_add_gadget_udc() 注册。这样就可以 Function Layer 就可以通过调用 Gadget Api 来动态分配 Endpoint 了。例如：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">acm_bind(struct usb_configuration *c, struct usb_function *f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* allocate instance-specific endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 从 Gadget Device 中分配一个 in endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;acm_fs_in_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.in = ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 从 Gadget Device 中分配一个 out endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;acm_fs_out_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.out = ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 从 Gadget Device 中分配一个 notify endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;acm_fs_notify_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;notify = ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中通过 usb_ep_autoconfig() 函数从 Gadget Device 的 Endpoint 资源链表中分配空闲的 endpoint:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\function\f_acm.c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_autoconfig() → usb_ep_autoconfig_ss():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_ep *usb_ep_autoconfig_ss(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_gadget               *gadget,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_endpoint_descriptor  *desc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_ss_ep_comp_descriptor *ep_comp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_ep   *ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (gadget-&gt;ops-&gt;match_ep) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ep = gadget-&gt;ops-&gt;match_ep(gadget, desc, ep_comp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto found_ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Second, look at endpoints until an unclaimed one looks usable */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 从 Gadget Device 的 Endpoint 资源链表中查找一个空闲的(ep-&gt;claimed为空) 且符合要求的 endpoint  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list_for_each_entry (ep, &amp;gadget-&gt;ep_list, ep_list) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            goto found_ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Fail */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">found_ep:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep-&gt;address = desc-&gt;bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep-&gt;desc = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep-&gt;comp_desc = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 设置 endpoint 为已分配 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep-&gt;claimed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6222-endpoint-access">6.2.2.2. EndPoint Access<a href="#6222-endpoint-access" class="hash-link" aria-label="Direct link to 6.2.2.2. EndPoint Access" title="Direct link to 6.2.2.2. EndPoint Access">​</a></h5>
<p>Gadget Device 不仅仅为 Gadget Api 提供了分配 endpoint 的支持，还支持对 endpoint 收发数据的底层支持。在上一节的 endpoint 初始化时，就已经设置 endpoint 的操作函数集 <code>dwc2_hsotg_ep_ops</code> ：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dwc2_driver_probe() → dwc2_gadget_init() → dwc2_hsotg_initep():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct dwc2_hsotg_ep *hs_ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    int epnum,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    bool dir_in)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.3) endpoint 最重要的结构体成员，endpoint 操作函数集</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        endpoint 的相关操作最后调用到这些函数上</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hs_ep-&gt;ep.ops = &amp;dwc2_hsotg_ep_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_ep_ops dwc2_hsotg_ep_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .enable         = dwc2_hsotg_ep_enable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disable        = dwc2_hsotg_ep_disable_lock,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .alloc_request  = dwc2_hsotg_ep_alloc_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .free_request   = dwc2_hsotg_ep_free_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .queue          = dwc2_hsotg_ep_queue_lock,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .dequeue        = dwc2_hsotg_ep_dequeue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .set_halt       = dwc2_hsotg_ep_sethalt_lock,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* note, don&#x27;t believe we have any call for the fifo routines */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Gadget Api 提供了以下接口来操作 endpoint 读写数据。在 Host 侧对 endpoint 进行一次操作请求的数据结构是 <code>struct urb</code> ，而在 Device 侧也有类似的数据结构称为 <code>struct usb_request</code> ，对 endpoint 的数据读写就是围绕 <code>struct usb_request</code> 展开的：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\function\f_acm.c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int acm_cdc_notify(struct f_acm *acm, u8 type, u16 value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *data, unsigned length)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_ep                   *ep = acm-&gt;notify;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_request              *req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_cdc_notification     *notify;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const unsigned                  len = sizeof(*notify) + length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void                            *buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int                             status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 初始化 `struct usb_request` 数据结构 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    req = acm-&gt;notify_req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;notify_req = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;pending = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    req-&gt;length = len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notify = req-&gt;buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buf = notify + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notify-&gt;bmRequestType = USB_DIR_IN | USB_TYPE_CLASS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            | USB_RECIP_INTERFACE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notify-&gt;bNotificationType = type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notify-&gt;wValue = cpu_to_le16(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notify-&gt;wIndex = cpu_to_le16(acm-&gt;ctrl_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    notify-&gt;wLength = cpu_to_le16(length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    memcpy(buf, data, length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* ep_queue() can complete immediately if it fills the fifo... */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spin_unlock(&amp;acm-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 提交 `usb_request` 请求到 endpoint 处理队列中 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = usb_ep_queue(ep, req, GFP_ATOMIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spin_lock(&amp;acm-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>其中 usb_ep_queue() 函数就会调用 endpoint 的操作函数集 <code>dwc2_hsotg_ep_ops</code> 中的 <code>.queue</code> 函数：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_ep_queue(struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct usb_request *req, gfp_t gfp_flags)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (WARN_ON_ONCE(!ep-&gt;enabled &amp;&amp; ep-&gt;address)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = -ESHUTDOWN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 实际调用 dwc2_hsotg_ep_queue_lock() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = ep-&gt;ops-&gt;queue(ep, req, gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trace_usb_ep_queue(ep, req, ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6223-udc-control">6.2.2.3. UDC Control<a href="#6223-udc-control" class="hash-link" aria-label="Direct link to 6.2.2.3. UDC Control" title="Direct link to 6.2.2.3. UDC Control">​</a></h5>
<p>Gadget Device 还提供了 UDC 层级的一些操作函数，UDC Driver 在调用 usb_add_gadget_udc() 注册 Gadget Device 之前，初始化了 Gadget 的 操作函数集：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dwc2_driver_probe() → dwc2_gadget_init():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int dwc2_gadget_init(struct dwc2_hsotg *hsotg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hsotg-&gt;gadget.max_speed = USB_SPEED_HIGH;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 初始化 Gadget Device 的操作函数集  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hsotg-&gt;gadget.ops = &amp;dwc2_hsotg_gadget_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hsotg-&gt;gadget.name = dev_name(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hsotg-&gt;remote_wakeup_allowed = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">↓</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_gadget_ops dwc2_hsotg_gadget_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .get_frame      = dwc2_hsotg_gadget_getframe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .set_selfpowered        = dwc2_hsotg_set_selfpowered,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .udc_start              = dwc2_hsotg_udc_start,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .udc_stop               = dwc2_hsotg_udc_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .pullup                 = dwc2_hsotg_pullup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .vbus_session           = dwc2_hsotg_vbus_session,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .vbus_draw              = dwc2_hsotg_vbus_draw,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>Gadget Api 提供了一些内部函数来调用：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int usb_gadget_udc_start(struct usb_udc *udc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return udc-&gt;gadget-&gt;ops-&gt;udc_start(udc-&gt;gadget, udc-&gt;driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void usb_gadget_udc_stop(struct usb_udc *udc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    udc-&gt;gadget-&gt;ops-&gt;udc_stop(udc-&gt;gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void usb_gadget_udc_set_speed(struct usb_udc *udc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        enum usb_device_speed speed)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (udc-&gt;gadget-&gt;ops-&gt;udc_set_speed) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        enum usb_device_speed s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s = min(speed, udc-&gt;gadget-&gt;max_speed);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        udc-&gt;gadget-&gt;ops-&gt;udc_set_speed(udc-&gt;gadget, s);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_connect(struct usb_gadget *gadget)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!gadget-&gt;ops-&gt;pullup) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = -EOPNOTSUPP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (gadget-&gt;deactivated) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * If gadget is deactivated we only save new state.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * Gadget will be connected automatically after activation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gadget-&gt;connected = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = gadget-&gt;ops-&gt;pullup(gadget, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gadget-&gt;connected = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trace_usb_gadget_connect(gadget, ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_disconnect(struct usb_gadget *gadget)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!gadget-&gt;ops-&gt;pullup) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = -EOPNOTSUPP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!gadget-&gt;connected)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (gadget-&gt;deactivated) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * If gadget is deactivated we only save new state.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * Gadget will stay disconnected after activation.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gadget-&gt;connected = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = gadget-&gt;ops-&gt;pullup(gadget, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gadget-&gt;connected = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gadget-&gt;udc-&gt;driver-&gt;disconnect(gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trace_usb_gadget_disconnect(gadget, ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="623-gadget-driver-configfs">6.2.3. Gadget Driver (Configfs)<a href="#623-gadget-driver-configfs" class="hash-link" aria-label="Direct link to 6.2.3. Gadget Driver (Configfs)" title="Direct link to 6.2.3. Gadget Driver (Configfs)">​</a></h4>
<p>Gadget Device 支撑了核心 Gadget Api 的实现，而 Function Layer 又需要使用这些 Api。怎么样将两者适配起来？Gadget Driver 就是用来完成这项工作的。</p>
<p>目前存在两种风格的 Gadget Driver，其中包括：</p>
<ul>
<li>Legacy。这是早期风格的 Gadget Driver，只能通过静态编译的方式指定使用哪些 Function。</li>
<li>Configfs。这是目前流行的 Gadget Driver，可以通过 configfs 文件系统，不用重新编译内核，动态的配置需要使用的 Function。</li>
</ul>
<p>我们首先介绍 configfs 风格的 Gadget Driver。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6231-configfs-使用">6.2.3.1. Configfs 使用<a href="#6231-configfs-使用" class="hash-link" aria-label="Direct link to 6.2.3.1. Configfs 使用" title="Direct link to 6.2.3.1. Configfs 使用">​</a></h5>
<p>首先从使用上体验一下 configfs 的便捷。例如创建一个 ACM Function:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 1、挂载configfs文件系统。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mount -t configfs none /sys/kernel/config</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd /sys/kernel/config/usb_gadget</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 2、创建g1目录，实例化一个新的gadget模板 (composite device)。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir g1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd g1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3.1、定义USB产品的VID和PID。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x1d6b&quot; &gt; idVendor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0x0104&quot; &gt; idProduct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3.2、实例化英语语言ID。(0x409是USB language ID 美国英语，不是任意的，可以在USBIF网站上下载文档查询。)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls strings/0x409/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 3.3、将开发商、产品和序列号字符串写入内核。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;0123456789&quot; &gt; strings/0x409/serialnumber</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;AAAA Inc.&quot; &gt; strings/0x409/manufacturer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;Bar Gadget&quot; &gt; strings/0x409/product</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 4、创建 `Function` 功能实例，需要注意的是，一个功能如果有多个实例的话，扩展名必须用数字编号。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir functions/acm.GS0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 5.1、创建一个USB `Configuration` 配置实例：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 5.2、定义配置描述符使用的字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mkdir configs/c.1/strings/0x409</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls configs/c.1/strings/0x409/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;ACM&quot; &gt; configs/c.1/strings/0x409/configuration</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 6、捆绑功能 `Function` 实例到 `Configuration` 配置c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ln -s functions/acm.GS0 configs/c.1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 7.1、查找本机可获得的UDC实例 (即 gadget device)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ls /sys/class/udc/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10200000.usb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 7.2、将gadget驱动注册到UDC上，插上USB线到电脑上，电脑就会枚举USB设备。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;10200000.usb&quot; &gt; UDC</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6232-configfs-层次结构">6.2.3.2. Configfs 层次结构<a href="#6232-configfs-层次结构" class="hash-link" aria-label="Direct link to 6.2.3.2. Configfs 层次结构" title="Direct link to 6.2.3.2. Configfs 层次结构">​</a></h5>
<p>configfs 并不是 gadget 专用的，它是一个通用文件系统，方便用户通过文件系统创建文件夹、文件的方式来创建内核对象。</p>
<p>configfs 是很好理解的， <code>struct config_group</code> 相当于一个文件夹， <code>struct config_item_type</code> 是这个文件夹的属性集。其中 <code>config_item_type-&gt;ct_group_ops-&gt;make_group()/drop_item()</code> 定义了创建/销毁下一层子文件夹的方法， <code>config_item_type-&gt;ct_attrs</code> 定义了子文件和相关操作函数。</p>
<p>我们通过解析 <code>drivers\usb\gadget\configfs.c</code> 文件来深入理解 <code>configfs</code> 的使用方法：</p>
<ul>
<li>首先创建首层文件夹 <code>/sys/kernel/config/usb_gadget</code> ：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct configfs_group_operations gadgets_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .make_group     = &amp;gadgets_make,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .drop_item      = &amp;gadgets_drop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static const struct config_item_type gadgets_type = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .ct_group_ops   = &amp;gadgets_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .ct_owner       = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct configfs_subsystem gadget_subsys = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .su_group = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .cg_item = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .ci_namebuf = &quot;usb_gadget&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .ci_type = &amp;gadgets_type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .su_mutex = __MUTEX_INITIALIZER(gadget_subsys.su_mutex),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int __init gadget_cfs_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config_group_init(&amp;gadget_subsys.su_group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = configfs_register_subsystem(&amp;gadget_subsys);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_init(gadget_cfs_init);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>创建 <code>/sys/kernel/config/usb_gadget/g1</code> ，相当于创建一个全新的 <code>composite device</code>。会调用顶层 <code>struct config_group</code> 的 <code>config_item_type-&gt;ct_group_ops-&gt;make_group()</code> 函数，即 <code>gadgets_make()</code> ：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct config_group *gadgets_make(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct config_group *group,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const char *name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct gadget_info *gi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi = kzalloc(sizeof(*gi), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!gi)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ERR_PTR(-ENOMEM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 创建顶层文件夹 `/sys/kernel/config/usb_gadget/g1` 对应的 `struct config_group` 结构</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `/sys/kernel/config/usb_gadget/g1` 下对应不少子文件，在 gadget_root_type.ct_attrs 中定义，即 `gadget_root_attrs`:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            static struct configfs_attribute *gadget_root_attrs[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_bDeviceClass,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_bDeviceSubClass,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_bDeviceProtocol,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_bMaxPacketSize0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_idVendor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_idProduct,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_bcdDevice,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_bcdUSB,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_UDC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;gadget_dev_desc_attr_max_speed,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config_group_init_type_name(&amp;gi-&gt;group, name, &amp;gadget_root_type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 创建子文件夹 `/sys/kernel/config/usb_gadget/g1/functions`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `functions_type` 中定义了进一步创建子文件夹的操作函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config_group_init_type_name(&amp;gi-&gt;functions_group, &quot;functions&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;functions_type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configfs_add_default_group(&amp;gi-&gt;functions_group, &amp;gi-&gt;group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 创建子文件夹 `/sys/kernel/config/usb_gadget/g1/configs`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `config_desc_type` 中定义了进一步创建子文件夹的操作函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config_group_init_type_name(&amp;gi-&gt;configs_group, &quot;configs&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;config_desc_type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configfs_add_default_group(&amp;gi-&gt;configs_group, &amp;gi-&gt;group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (4) 创建子文件夹 `/sys/kernel/config/usb_gadget/g1/strings`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `gadget_strings_strings_type` 中定义了进一步创建子文件夹的操作函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config_group_init_type_name(&amp;gi-&gt;strings_group, &quot;strings&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;gadget_strings_strings_type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configfs_add_default_group(&amp;gi-&gt;strings_group, &amp;gi-&gt;group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (5) 创建子文件夹 `/sys/kernel/config/usb_gadget/g1/os_desc`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            `os_desc_type` 中定义了进一步创建哪些子文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    config_group_init_type_name(&amp;gi-&gt;os_desc_group, &quot;os_desc&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &amp;os_desc_type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    configfs_add_default_group(&amp;gi-&gt;os_desc_group, &amp;gi-&gt;group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (6) `configfs.c` 的目的很明确就是创建一个 `composite device`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            由用户添加和配置这个 `device` 当中的多个 `interface` 即 `function`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.bind = configfs_do_nothing;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.unbind = configfs_do_nothing;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.suspend = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.resume = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.max_speed = USB_SPEED_SUPER_PLUS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spin_lock_init(&amp;gi-&gt;spinlock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_init(&amp;gi-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INIT_LIST_HEAD(&amp;gi-&gt;string_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INIT_LIST_HEAD(&amp;gi-&gt;available_func);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    composite_init_dev(&amp;gi-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;cdev.desc.bLength = USB_DT_DEVICE_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;cdev.desc.bDescriptorType = USB_DT_DEVICE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;cdev.desc.bcdDevice = cpu_to_le16(get_default_bcdDevice());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.gadget_driver = configfs_driver_template;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi-&gt;composite.name = gi-&gt;composite.gadget_driver.function;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!gi-&gt;composite.gadget_driver.function)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &amp;gi-&gt;group;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">err:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kfree(gi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return ERR_PTR(-ENOMEM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<ul>
<li>创建 <code>/sys/kernel/config/usb_gadget/g1/functions/acm.GS0</code>。会调用 <code>functions_type</code> 中定义的 function_make() 函数：</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct config_group *function_make(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct config_group *group,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const char *name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct gadget_info *gi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_function_instance *fi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char buf[MAX_NAME_LEN];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *func_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    char *instance_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = snprintf(buf, MAX_NAME_LEN, &quot;%s&quot;, name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &gt;= MAX_NAME_LEN)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ERR_PTR(-ENAMETOOLONG);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 把 `acm.GS0` 分割成两部分：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            func_name = `acm`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instance_name = `GS0`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    func_name = buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    instance_name = strchr(func_name, &#x27;.&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!instance_name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_err(&quot;Unable to locate . in FUNC.INSTANCE\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ERR_PTR(-EINVAL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *instance_name = &#x27;\0&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    instance_name++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 根据 func_name 在全局链表中查找对应 function</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_get_function_instance() → try_get_usb_function_instance() → fd-&gt;alloc_inst() → acm_alloc_instance():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            并调用 usb_function_driver-&gt;alloc_inst() 分配一个 function 实例</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fi = usb_get_function_instance(func_name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (IS_ERR(fi))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ERR_CAST(fi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (3) 初始化 function 实例 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = config_item_set_name(&amp;fi-&gt;group.cg_item, &quot;%s&quot;, name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_put_function_instance(fi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ERR_PTR(ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (fi-&gt;set_inst_name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = fi-&gt;set_inst_name(fi, instance_name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_put_function_instance(fi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return ERR_PTR(ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gi = container_of(group, struct gadget_info, functions_group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_lock(&amp;gi-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (4) 将 function 实例挂载到 composite device 的 function 链表当中去 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list_add_tail(&amp;fi-&gt;cfs_list, &amp;gi-&gt;available_func);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_unlock(&amp;gi-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &amp;fi-&gt;group;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 <code>ln -s functions/acm.GS0 configs/c.1</code> 时给 function 实例安装实际的函数：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">config_usb_cfg_link() → usb_get_function() → fi-&gt;fd-&gt;alloc_func() → acm_alloc_func()：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct usb_function *acm_alloc_func(struct usb_function_instance *fi)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct f_serial_opts *opts;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct f_acm *acm;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.1) 对应分配一个 func 实例 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm = kzalloc(sizeof(*acm), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!acm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ERR_PTR(-ENOMEM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spin_lock_init(&amp;acm-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2.2) 初始化 func 实例的成员函数 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.connect = acm_connect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.disconnect = acm_disconnect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.send_break = acm_send_break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.name = &quot;acm&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.strings = acm_strings;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* descriptors are per-instance copies */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.bind = acm_bind;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.set_alt = acm_set_alt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.setup = acm_setup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.disable = acm_disable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    opts = container_of(fi, struct f_serial_opts, func_inst);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port_num = opts-&gt;port_num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.unbind = acm_unbind;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.free_func = acm_free_func;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.resume = acm_resume;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.func.suspend = acm_suspend;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return &amp;acm-&gt;port.func;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6233-gadget-driver">6.2.3.3. Gadget Driver<a href="#6233-gadget-driver" class="hash-link" aria-label="Direct link to 6.2.3.3. Gadget Driver" title="Direct link to 6.2.3.3. Gadget Driver">​</a></h5>
<p>Configfs 风格的 gadget driver 的定义：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\configfs.c：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_gadget_driver configfs_driver_template = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bind           = configfs_composite_bind,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .unbind         = configfs_composite_unbind,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setup          = configfs_composite_setup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reset          = configfs_composite_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disconnect     = configfs_composite_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .suspend        = configfs_composite_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .resume         = configfs_composite_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .max_speed      = USB_SPEED_SUPER_PLUS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .owner          = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .name               = &quot;configfs-gadget&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .match_existing_only = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在调用 <code>echo &quot;/sys/class/udc/10200000.usb&quot; &gt; /sys/kernel/config/usb_gadget/g1/UDC</code> 时，将上述 <code>gadget driver</code> 进行注册，和 UDC 已经注册好的 <code>gadget device</code> 进行动态适配。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gadget_dev_desc_UDC_store() → usb_gadget_probe_driver(&amp;gi-&gt;composite.gadget_driver) → udc_bind_to_driver()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>本质上是 使用 configfs 创建好的 <code>composite device</code> 和 <code>gadget device</code> 进行绑定：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gadget_dev_desc_UDC_store() → usb_gadget_probe_driver()  → udc_bind_to_driver() → configfs_composite_bind() → usb_add_function() → function-&gt;bind() → acm_bind():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">acm_bind(struct usb_configuration *c, struct usb_function *f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 这样 function 实例和 gadget device 进行了绑定 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_composite_dev *cdev = c-&gt;cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct f_acm            *acm = func_to_acm(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* allocate instance-specific endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) function 实例可以从 gadget device 中分配得到 endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;acm_fs_in_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.in = ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;acm_fs_out_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;port.out = ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;acm_fs_notify_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    acm-&gt;notify = ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>但是 bind() 以后 function 实例只是分配了 endpoint 资源还没有被启动，因  为 Device 是被动状态，只有连上 Host，被 Host <code>Set Configuration</code> 操作以后。某一组 <code>Configuration</code> 被配置，相应的 <code>Function 实例</code> 才会被启用：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dwc2_hsotg_complete_setup() → dwc2_hsotg_process_control() → hsotg-&gt;driver-&gt;setup() → configfs_composite_setup() → composite_setup() → set_config() → f-&gt;set_alt() → acm_set_alt():</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int acm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct f_acm            *acm = func_to_acm(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_composite_dev *cdev = f-&gt;config-&gt;cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* we know alt == 0, so this is an activation or a reset */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 使能 endpoint，并且提交 `struct usb_request` 请求  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (intf == acm-&gt;ctrl_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (acm-&gt;notify-&gt;enabled) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dev_vdbg(&amp;cdev-&gt;gadget-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &quot;reset acm control interface %d\n&quot;, intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_ep_disable(acm-&gt;notify);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!acm-&gt;notify-&gt;desc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (config_ep_by_speed(cdev-&gt;gadget, f, acm-&gt;notify))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_ep_enable(acm-&gt;notify);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (intf == acm-&gt;data_id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (acm-&gt;notify-&gt;enabled) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dev_dbg(&amp;cdev-&gt;gadget-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;reset acm ttyGS%d\n&quot;, acm-&gt;port_num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gserial_disconnect(&amp;acm-&gt;port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!acm-&gt;port.in-&gt;desc || !acm-&gt;port.out-&gt;desc) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dev_dbg(&amp;cdev-&gt;gadget-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;activate acm ttyGS%d\n&quot;, acm-&gt;port_num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (config_ep_by_speed(cdev-&gt;gadget, f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        acm-&gt;port.in) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                config_ep_by_speed(cdev-&gt;gadget, f,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        acm-&gt;port.out)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                acm-&gt;port.in-&gt;desc = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                acm-&gt;port.out-&gt;desc = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gserial_connect(&amp;acm-&gt;port, acm-&gt;port_num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="624-gadget-driver-legacy">6.2.4. Gadget Driver (Legacy)<a href="#624-gadget-driver-legacy" class="hash-link" aria-label="Direct link to 6.2.4. Gadget Driver (Legacy)" title="Direct link to 6.2.4. Gadget Driver (Legacy)">​</a></h4>
<p>对于 Legacy Gadget Driver 驱动来说，相当于 Configfs Gadget Driver 的一个简化版。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6241-gadget-drive">6.2.4.1. Gadget Drive<a href="#6241-gadget-drive" class="hash-link" aria-label="Direct link to 6.2.4.1. Gadget Drive" title="Direct link to 6.2.4.1. Gadget Drive">​</a></h5>
<p>Legacy 风格的 gadget driver 的定义：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\composite.c:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static const struct usb_gadget_driver composite_driver_template = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bind           = composite_bind,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .unbind         = composite_unbind,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .setup          = composite_setup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .reset          = composite_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .disconnect     = composite_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .suspend        = composite_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .resume         = composite_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .owner              = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>驱动提供了一个注册函数 usb_composite_probe()，以供 <code>composite device</code> 来进行调用：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_composite_probe(struct usb_composite_driver *driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct usb_gadget_driver *gadget_driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!driver || !driver-&gt;dev || !driver-&gt;bind)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!driver-&gt;name)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        driver-&gt;name = &quot;composite&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (1) 把传递过来的 `usb_composite_driver` 包装成 `usb_gadget_driver` */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    driver-&gt;gadget_driver = composite_driver_template;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gadget_driver = &amp;driver-&gt;gadget_driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gadget_driver-&gt;function =  (char *) driver-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gadget_driver-&gt;driver.name = driver-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gadget_driver-&gt;max_speed = driver-&gt;max_speed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* (2) 注册 gadget driver，让其和 gadget device 适配 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return usb_gadget_probe_driver(gadget_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EXPORT_SYMBOL_GPL(usb_composite_probe);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="6242-composite-device">6.2.4.2. Composite Device<a href="#6242-composite-device" class="hash-link" aria-label="Direct link to 6.2.4.2. Composite Device" title="Direct link to 6.2.4.2. Composite Device">​</a></h5>
<p>没有了 configfs 由用户来创建 <code>composite device</code> ，只能使用一个文件来创建 <code>composite device</code> 定义其使用哪些 <code>function</code> 和一系列配置。例如：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">drivers\usb\gadget\legacy\acm_ms.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct usb_composite_driver acm_ms_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name           = &quot;g_acm_ms&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .dev            = &amp;device_desc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .max_speed      = USB_SPEED_SUPER,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .strings        = dev_strings,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .bind           = acm_ms_bind,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .unbind         = acm_ms_unbind,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* (1) 驱动一开始就调用 usb_composite_probe() 来注册 acm_ms_driver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        因为 acm_ms_driver 没有指定 udc_name 所以只能适配第一个 udc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_usb_composite_driver(acm_ms_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define module_usb_composite_driver(__usb_composite_driver) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    module_driver(__usb_composite_driver, usb_composite_probe, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            usb_composite_unregister)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 gadget driver 驱动适配后，调用 bind() 函数：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_gadget_probe_driver() → udc_bind_to_driver() → composite_bind() → acm_ms_bind()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在 acm_ms_bind() 函数中创建 <code>composite device</code> 的 <code>Configuration</code> 和 <code>Function/Interface</code> ，并且和 Gadget Device / UDC 进行绑定。</p>
<p>其他操作和 Configfs Gadget Driver 类似。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="63-usb-interface-layer">6.3. USB Interface Layer<a href="#63-usb-interface-layer" class="hash-link" aria-label="Direct link to 6.3. USB Interface Layer" title="Direct link to 6.3. USB Interface Layer">​</a></h3>
<p>Linux 使用 Function 来实现 USB Interface 等级的功能。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="631-function-注册">6.3.1. Function 注册<a href="#631-function-注册" class="hash-link" aria-label="Direct link to 6.3.1. Function 注册" title="Direct link to 6.3.1. Function 注册">​</a></h4>
<p>在 <code>drivers/usb/gadget/function/</code> 路径下有一批 Gadget Function 的定义：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ls drivers/usb/gadget/function/f*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">f_acm.c  f_ecm.c  f_eem.c  f_fs.c  f_hid.c  f_loopback.c  f_mass_storage.c  f_mass_storage.h</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">f_midi.c  f_ncm.c  f_obex.c  f_phonet.c  f_printer.c  f_rndis.c  f_serial.c  f_sourcesink.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">f_subset.c  f_tcm.c  f_uac1.c  f_uac1_legacy.c  f_uac2.c  f_uvc.c  f_uvc.h</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>大家使用 <code>DECLARE_USB_FUNCTION_INIT()</code> 宏定义来调用 usb_function_register() 函数，把 <code>usb_function_driver</code> 注册到全局链表 <code>func_list</code> 中。等待 <code>composite device</code> 来进行实例化。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DECLARE_USB_FUNCTION_INIT(acm, acm_alloc_instance, acm_alloc_func);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DECLARE_USB_FUNCTION(_name, _inst_alloc, _func_alloc)               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static struct usb_function_driver _name ## usb_func = {         \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .name = __stringify(_name),                         \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .mod  = THIS_MODULE,                                        \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .alloc_inst = _inst_alloc,                          \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .alloc_func = _func_alloc,                          \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };                                                              \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MODULE_ALIAS(&quot;usbfunc:&quot;__stringify(_name));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DECLARE_USB_FUNCTION_INIT(_name, _inst_alloc, _func_alloc)  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DECLARE_USB_FUNCTION(_name, _inst_alloc, _func_alloc)           \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int __init _name ## mod_init(void)                       \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {                                                               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return usb_function_register(&amp;_name ## usb_func);   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                                                               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static void __exit _name ## mod_exit(void)                      \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {                                                               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        usb_function_unregister(&amp;_name ## usb_func);                \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                                                               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    module_init(_name ## mod_init);                                 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    module_exit(_name ## mod_exit)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="632-gadget-api">6.3.2. Gadget API<a href="#632-gadget-api" class="hash-link" aria-label="Direct link to 6.3.2. Gadget API" title="Direct link to 6.3.2. Gadget API">​</a></h4>
<p>在 Function Layer 主要使用以下 Gadget Layer 层提供的 API：</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_autoconfig()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_enable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_disable()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_alloc_request()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_free_request()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_queue()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usb_ep_dequeue()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-常见问题">7. 常见问题<a href="#7-常见问题" class="hash-link" aria-label="Direct link to 7. 常见问题" title="Direct link to 7. 常见问题">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="71-自动切换-hostdevice">7.1. 自动切换 Host/Device<a href="#71-自动切换-hostdevice" class="hash-link" aria-label="Direct link to 7.1. 自动切换 Host/Device" title="Direct link to 7.1. 自动切换 Host/Device">​</a></h3>
<p>该功能是在用户态手动切换 USB 端口为 Host 或者 Device</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="711-配置修改">7.1.1. 配置修改<a href="#711-配置修改" class="hash-link" aria-label="Direct link to 7.1.1. 配置修改" title="Direct link to 7.1.1. 配置修改">​</a></h4>
<p>在 相应工程的 board.dts 中打开 otg 的宏，并配置 otg-mode， 可选值为</p>
<ul>
<li>auto： 通过硬件的 ID 管脚切换</li>
<li>host： 默认配置为 host</li>
<li>device： 默认配置为 device</li>
</ul>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#if 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&amp;otg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       otg-mode = &quot;device&quot;;    /* auto/host/device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="712-手动切换">7.1.2. 手动切换<a href="#712-手动切换" class="hash-link" aria-label="Direct link to 7.1.2. 手动切换" title="Direct link to 7.1.2. 手动切换">​</a></h4>
<p>通过上述配置打开 otg mode 后就可以在控制台通过 sysfs 的接口进行手动切换</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #cat /sys/devices/platform/soc/soc\:usb-otg/otg_mode                 //当前模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #echo auto &gt; /sys/devices/platform/soc/soc\:usb-otg/otg_mode         //切换为 auto</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #echo device &gt; /sys/devices/platform/soc/soc\:usb-otg/otg_mode       //切换为 device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[aic@] #echo host &gt; /sys/devices/platform/soc/soc\:usb-otg/otg_mode         //切换为 host</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/100askTeam/ArtInChip-Docs/tree/master/docs/D213-DevKit/part3/07-12_USB-Useguide.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/en/docs/D213-DevKit/part3/07-11_UART-Useguide"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">UART 使用指南</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/en/docs/D213-DevKit/part3/07-13_PSADC-Useguide"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">PSADC 使用指南</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-配置指南" class="table-of-contents__link toc-highlight">1. 配置指南</a><ul><li><a href="#11-usb-host-配置" class="table-of-contents__link toc-highlight">1.1. USB Host 配置</a></li><li><a href="#12-usb-device-配置" class="table-of-contents__link toc-highlight">1.2. USB Device 配置</a></li><li><a href="#13-usb-otg-配置" class="table-of-contents__link toc-highlight">1.3. USB OTG 配置</a></li></ul></li><li><a href="#2-调试指南" class="table-of-contents__link toc-highlight">2. 调试指南</a><ul><li><a href="#21-usb-host-调试" class="table-of-contents__link toc-highlight">2.1. USB Host 调试</a></li><li><a href="#22-usb-device-调试" class="table-of-contents__link toc-highlight">2.2. USB Device 调试</a></li></ul></li><li><a href="#3-测试指南" class="table-of-contents__link toc-highlight">3. 测试指南</a><ul><li><a href="#31-测试方案介绍" class="table-of-contents__link toc-highlight">3.1. 测试方案介绍</a></li><li><a href="#32-device-侧-gadget-zero" class="table-of-contents__link toc-highlight">3.2. Device 侧 <code>gadget zero</code></a></li><li><a href="#33-host-侧-usbtestko" class="table-of-contents__link toc-highlight">3.3. Host 侧 <code>usbtest.ko</code></a></li><li><a href="#34-host-侧-testusb" class="table-of-contents__link toc-highlight">3.4. Host 侧 <code>testusb</code></a></li></ul></li><li><a href="#4-设计说明" class="table-of-contents__link toc-highlight">4. 设计说明</a><ul><li><a href="#41-usb-host-controller-driver" class="table-of-contents__link toc-highlight">4.1. USB Host Controller Driver</a></li><li><a href="#42-usb-device-controller-driver" class="table-of-contents__link toc-highlight">4.2. USB Device Controller Driver</a></li></ul></li><li><a href="#5-usb-host-子系统代码架构" class="table-of-contents__link toc-highlight">5. USB Host 子系统代码架构</a><ul><li><a href="#51-usb-core" class="table-of-contents__link toc-highlight">5.1. USB Core</a></li><li><a href="#52-usb-device-layer" class="table-of-contents__link toc-highlight">5.2. USB Device Layer</a></li><li><a href="#53-usb-interface-layer" class="table-of-contents__link toc-highlight">5.3. USB Interface Layer</a></li><li><a href="#54-usb-host-controller-layer" class="table-of-contents__link toc-highlight">5.4. USB Host Controller Layer</a></li></ul></li><li><a href="#6-usb-device-子系统代码架构" class="table-of-contents__link toc-highlight">6. USB Device 子系统代码架构</a><ul><li><a href="#61-usb-device-controller-layer" class="table-of-contents__link toc-highlight">6.1. USB Device Controller Layer</a></li><li><a href="#62-usb-device-layer" class="table-of-contents__link toc-highlight">6.2. USB Device Layer</a></li><li><a href="#63-usb-interface-layer" class="table-of-contents__link toc-highlight">6.3. USB Interface Layer</a></li></ul></li><li><a href="#7-常见问题" class="table-of-contents__link toc-highlight">7. 常见问题</a><ul><li><a href="#71-自动切换-hostdevice" class="table-of-contents__link toc-highlight">7.1. 自动切换 Host/Device</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://dongshanpi.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">DongshanPI<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://canaan-docs.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Canaan-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://renesas-docs.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Renesas-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://rtos.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">RTOS<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://tina.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">TinaSDK-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://allwinner-docs.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Allwinner-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://aw-r128.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">R128-Docs<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://space.bilibili.com/275908810" target="_blank" rel="noopener noreferrer" class="footer__link-item">BiliBili<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://forums.100ask.net" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://video.100ask.net/" target="_blank" rel="noopener noreferrer" class="footer__link-item">VideoCenter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/dongshanpi" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://weidongshan.coding.net/public/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Coding<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/100askTeam" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://gitee.com/weidongshan" target="_blank" rel="noopener noreferrer" class="footer__link-item">Gitee<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 100askTeam, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>