"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4182],{6955:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>a,frontMatter:()=>r,metadata:()=>t,toc:()=>l});var i=s(5893),d=s(1151);const r={sidebar_position:27},c="USB \u4f7f\u7528\u6307\u5357",t={id:"D213-DevKit/part3/07-12_USB-Useguide",title:"USB \u4f7f\u7528\u6307\u5357",description:"1. \u914d\u7f6e\u6307\u5357",source:"@site/docs/D213-DevKit/part3/07-12_USB-Useguide.md",sourceDirName:"D213-DevKit/part3",slug:"/D213-DevKit/part3/07-12_USB-Useguide",permalink:"/docs/D213-DevKit/part3/07-12_USB-Useguide",draft:!1,unlisted:!1,editUrl:"https://github.com/100askTeam/ArtInChip-Docs/tree/master/docs/D213-DevKit/part3/07-12_USB-Useguide.md",tags:[],version:"current",sidebarPosition:27,frontMatter:{sidebar_position:27},sidebar:"d213dkSidebar",previous:{title:"UART \u4f7f\u7528\u6307\u5357",permalink:"/docs/D213-DevKit/part3/07-11_UART-Useguide"},next:{title:"PSADC \u4f7f\u7528\u6307\u5357",permalink:"/docs/D213-DevKit/part3/07-13_PSADC-Useguide"}},o={},l=[{value:"1. \u914d\u7f6e\u6307\u5357",id:"1-\u914d\u7f6e\u6307\u5357",level:2},{value:"1.1. USB Host \u914d\u7f6e",id:"11-usb-host-\u914d\u7f6e",level:3},{value:"1.1.1. USB Host Controller \u914d\u7f6e",id:"111-usb-host-controller-\u914d\u7f6e",level:4},{value:"1.1.1.1. EHCI \u914d\u7f6e",id:"1111-ehci-\u914d\u7f6e",level:5},{value:"1.1.1.2. OHCI \u914d\u7f6e",id:"1112-ohci-\u914d\u7f6e",level:5},{value:"1.1.2. USB Interface \u9a71\u52a8\u914d\u7f6e",id:"112-usb-interface-\u9a71\u52a8\u914d\u7f6e",level:4},{value:"1.1.2.1. U \u76d8 \u914d\u7f6e",id:"1121-u-\u76d8-\u914d\u7f6e",level:5},{value:"1.1.2.2. USB \u952e\u76d8/\u9f20\u6807 \u914d\u7f6e",id:"1122-usb-\u952e\u76d8\u9f20\u6807-\u914d\u7f6e",level:5},{value:"1.2. USB Device \u914d\u7f6e",id:"12-usb-device-\u914d\u7f6e",level:3},{value:"1.2.1. USB Device Controller \u914d\u7f6e",id:"121-usb-device-controller-\u914d\u7f6e",level:4},{value:"1.2.2. USB Gadget \u914d\u7f6e",id:"122-usb-gadget-\u914d\u7f6e",level:4},{value:"1.2.2.1. Gadget \u914d\u7f6e",id:"1221-gadget-\u914d\u7f6e",level:5},{value:"1.2.2.2. ConfigFS \u914d\u7f6e",id:"1222-configfs-\u914d\u7f6e",level:5},{value:"1.2.3. USB Interface \u914d\u7f6e",id:"123-usb-interface-\u914d\u7f6e",level:4},{value:"1.2.3.1. ACM \u4e32\u53e3 \u914d\u7f6e",id:"1231-acm-\u4e32\u53e3-\u914d\u7f6e",level:5},{value:"1.2.3.2. U \u76d8 \u914d\u7f6e",id:"1232-u-\u76d8-\u914d\u7f6e",level:5},{value:"1.2.3.3. NCM \u7f51\u53e3 \u914d\u7f6e",id:"1233-ncm-\u7f51\u53e3-\u914d\u7f6e",level:5},{value:"1.2.3.4. ECM \u7f51\u53e3 \u914d\u7f6e",id:"1234-ecm-\u7f51\u53e3-\u914d\u7f6e",level:5},{value:"1.2.3.5. ADBD \u914d\u7f6e",id:"1235-adbd-\u914d\u7f6e",level:5},{value:"1.3. USB OTG \u914d\u7f6e",id:"13-usb-otg-\u914d\u7f6e",level:3},{value:"1.3.1. OTG \u6a21\u5f0f\u914d\u7f6e",id:"131-otg-\u6a21\u5f0f\u914d\u7f6e",level:4},{value:"1.3.2. OTG \u76f8\u5173 GPIO",id:"132-otg-\u76f8\u5173-gpio",level:4},{value:"2. \u8c03\u8bd5\u6307\u5357",id:"2-\u8c03\u8bd5\u6307\u5357",level:2},{value:"2.1. USB Host \u8c03\u8bd5",id:"21-usb-host-\u8c03\u8bd5",level:3},{value:"2.1.1. \u67e5\u770b USB \u8bbe\u5907",id:"211-\u67e5\u770b-usb-\u8bbe\u5907",level:4},{value:"2.1.2. Sysfs \u8282\u70b9",id:"212-sysfs-\u8282\u70b9",level:4},{value:"2.1.3. USB \u603b\u7ebf\u5206\u6790\u4eea",id:"213-usb-\u603b\u7ebf\u5206\u6790\u4eea",level:4},{value:"2.1.4. usbmon",id:"214-usbmon",level:4},{value:"2.2. USB Device \u8c03\u8bd5",id:"22-usb-device-\u8c03\u8bd5",level:3},{value:"2.2.1. \u67e5\u770b USB \u8bbe\u5907",id:"221-\u67e5\u770b-usb-\u8bbe\u5907",level:4},{value:"2.2.2. Sysfs \u8282\u70b9",id:"222-sysfs-\u8282\u70b9",level:4},{value:"2.2.3. \u6293\u5305\u5de5\u5177",id:"223-\u6293\u5305\u5de5\u5177",level:4},{value:"3. \u6d4b\u8bd5\u6307\u5357",id:"3-\u6d4b\u8bd5\u6307\u5357",level:2},{value:"3.1. \u6d4b\u8bd5\u65b9\u6848\u4ecb\u7ecd",id:"31-\u6d4b\u8bd5\u65b9\u6848\u4ecb\u7ecd",level:3},{value:"3.2. Device \u4fa7 <code>gadget zero</code>",id:"32-device-\u4fa7-gadget-zero",level:3},{value:"3.2.1. Device \u521b\u5efa",id:"321-device-\u521b\u5efa",level:4},{value:"3.2.2. SourceSink Function",id:"322-sourcesink-function",level:4},{value:"3.2.3. Loopback Function",id:"323-loopback-function",level:4},{value:"3.3. Host \u4fa7 <code>usbtest.ko</code>",id:"33-host-\u4fa7-usbtestko",level:3},{value:"3.3.1. TestCase",id:"331-testcase",level:4},{value:"3.3.2. Ioctl",id:"332-ioctl",level:4},{value:"3.4. Host \u4fa7 <code>testusb</code>",id:"34-host-\u4fa7-testusb",level:3},{value:"4. \u8bbe\u8ba1\u8bf4\u660e",id:"4-\u8bbe\u8ba1\u8bf4\u660e",level:2},{value:"4.1. USB Host Controller Driver",id:"41-usb-host-controller-driver",level:3},{value:"4.1.1. \u6e90\u7801\u8bf4\u660e",id:"411-\u6e90\u7801\u8bf4\u660e",level:4},{value:"4.1.2. \u6a21\u5757\u67b6\u6784",id:"412-\u6a21\u5757\u67b6\u6784",level:4},{value:"4.1.3. \u5173\u952e\u6d41\u7a0b",id:"413-\u5173\u952e\u6d41\u7a0b",level:4},{value:"4.1.3.1. \u521d\u59cb\u5316\u6d41\u7a0b",id:"4131-\u521d\u59cb\u5316\u6d41\u7a0b",level:5},{value:"4.1.3.2. \u666e\u901a URB \u5904\u7406\u6d41\u7a0b",id:"4132-\u666e\u901a-urb-\u5904\u7406\u6d41\u7a0b",level:5},{value:"4.1.3.3. Roothub URB \u5904\u7406\u6d41\u7a0b",id:"4133-roothub-urb-\u5904\u7406\u6d41\u7a0b",level:5},{value:"4.1.4. \u6570\u636e\u7ed3\u6784",id:"414-\u6570\u636e\u7ed3\u6784",level:4},{value:"4.1.4.1. ehci_hc_driver",id:"4141-ehci_hc_driver",level:5},{value:"4.1.5. \u63a5\u53e3\u8bbe\u8ba1",id:"415-\u63a5\u53e3\u8bbe\u8ba1",level:4},{value:"4.1.5.1. ehci_urb_enqueue",id:"4151-ehci_urb_enqueue",level:5},{value:"4.1.5.2. ehci_hub_control",id:"4152-ehci_hub_control",level:5},{value:"4.1.5.3. ehci_hub_status_data",id:"4153-ehci_hub_status_data",level:5},{value:"4.2. USB Device Controller Driver",id:"42-usb-device-controller-driver",level:3},{value:"4.2.1. \u6e90\u7801\u8bf4\u660e",id:"421-\u6e90\u7801\u8bf4\u660e",level:4},{value:"4.2.2. \u6a21\u5757\u67b6\u6784",id:"422-\u6a21\u5757\u67b6\u6784",level:4},{value:"4.2.3. \u5173\u952e\u6d41\u7a0b",id:"423-\u5173\u952e\u6d41\u7a0b",level:4},{value:"4.2.3.1. \u521d\u59cb\u5316\u6d41\u7a0b",id:"4231-\u521d\u59cb\u5316\u6d41\u7a0b",level:5},{value:"4.2.3.2. ep \u5206\u914d\u6d41\u7a0b",id:"4232-ep-\u5206\u914d\u6d41\u7a0b",level:5},{value:"4.2.3.3. \u666e\u901a ep \u7684 request \u5904\u7406",id:"4233-\u666e\u901a-ep-\u7684-request-\u5904\u7406",level:5},{value:"4.2.3.4. ep0 \u7684 request \u5904\u7406",id:"4234-ep0-\u7684-request-\u5904\u7406",level:5},{value:"4.2.4. \u6570\u636e\u7ed3\u6784",id:"424-\u6570\u636e\u7ed3\u6784",level:4},{value:"4.2.4.1. aic_usb_ep_ops",id:"4241-aic_usb_ep_ops",level:5},{value:"4.2.5. \u63a5\u53e3\u8bbe\u8ba1",id:"425-\u63a5\u53e3\u8bbe\u8ba1",level:4},{value:"4.2.5.1. aic_ep_queue_request",id:"4251-aic_ep_queue_request",level:5},{value:"4.2.5.2. aic_ep0_process_control",id:"4252-aic_ep0_process_control",level:5},{value:"5. USB Host \u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784",id:"5-usb-host-\u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784",level:2},{value:"5.1. USB Core",id:"51-usb-core",level:3},{value:"5.1.1. Layer",id:"511-layer",level:4},{value:"5.1.2. URB (USB Request Block)",id:"512-urb-usb-request-block",level:4},{value:"5.1.2.1. Normal Device urb_enqueue",id:"5121-normal-device-urb_enqueue",level:5},{value:"5.1.2.2. Roothub Device urb_enqueue",id:"5122-roothub-device-urb_enqueue",level:5},{value:"5.2. USB Device Layer",id:"52-usb-device-layer",level:3},{value:"5.2.1. Device (struct usb_device)",id:"521-device-struct-usb_device",level:4},{value:"5.2.2. Driver (struct usb_device_driver)",id:"522-driver-struct-usb_device_driver",level:4},{value:"5.2.3. Bus (usb_bus_type)",id:"523-bus-usb_bus_type",level:4},{value:"5.3. USB Interface Layer",id:"53-usb-interface-layer",level:3},{value:"5.3.1. Device (struct usb_interface)",id:"531-device-struct-usb_interface",level:4},{value:"5.3.2. Driver (struct usb_driver)",id:"532-driver-struct-usb_driver",level:4},{value:"5.3.3. USB Hub Driver",id:"533-usb-hub-driver",level:4},{value:"5.3.3.1. Normal Hub Port op",id:"5331-normal-hub-port-op",level:5},{value:"5.3.3.2. RootHub Port op",id:"5332-roothub-port-op",level:5},{value:"5.3.3.3. Device Attach",id:"5333-device-attach",level:5},{value:"5.3.3.4. Device Deattach",id:"5334-device-deattach",level:5},{value:"5.3.4. Bus (usb_bus_type)",id:"534-bus-usb_bus_type",level:4},{value:"5.4. USB Host Controller Layer",id:"54-usb-host-controller-layer",level:3},{value:"5.4.1. AIC USB Host Controller",id:"541-aic-usb-host-controller",level:4},{value:"5.4.2. EHCI \u5185\u90e8\u7ed3\u6784",id:"542-ehci-\u5185\u90e8\u7ed3\u6784",level:4},{value:"5.4.2.1. Asynchronous Queue Schedule",id:"5421-asynchronous-queue-schedule",level:5},{value:"5.4.2.2. Periodic Queue Schedule",id:"5422-periodic-queue-schedule",level:5},{value:"5.4.3. EHCI Driver",id:"543-ehci-driver",level:4},{value:"5.4.3.1. URB Transfer",id:"5431-urb-transfer",level:5},{value:"5.4.3.2. Roothub",id:"5432-roothub",level:5},{value:"6. USB Device \u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784",id:"6-usb-device-\u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784",level:2},{value:"6.1. USB Device Controller Layer",id:"61-usb-device-controller-layer",level:3},{value:"6.1.1. AIC USB Device Controller",id:"611-aic-usb-device-controller",level:4},{value:"6.1.1.1. Data Mode",id:"6111-data-mode",level:5},{value:"6.1.1.2. Endpoint FIFO Mode",id:"6112-endpoint-fifo-mode",level:5},{value:"6.1.1.3. Endpoint Resource",id:"6113-endpoint-resource",level:5},{value:"6.1.1.4. Calculating FIFO Size",id:"6114-calculating-fifo-size",level:5},{value:"6.1.1.5. FIFO Mapping",id:"6115-fifo-mapping",level:5},{value:"6.1.1.6. Interrupt Cascade",id:"6116-interrupt-cascade",level:5},{value:"6.1.1.7. Data Transfer",id:"6117-data-transfer",level:5},{value:"6.1.2. AIC UDC Driver",id:"612-aic-udc-driver",level:4},{value:"6.1.2.1. Init",id:"6121-init",level:5},{value:"6.1.2.2. gadget.ops",id:"6122-gadgetops",level:5},{value:"6.1.2.3. ep.ops",id:"6123-epops",level:5},{value:"6.1.2.4. Interrupt",id:"6124-interrupt",level:5},{value:"6.1.2.5. EP0 Setup",id:"6125-ep0-setup",level:5},{value:"6.2. USB Device Layer",id:"62-usb-device-layer",level:3},{value:"6.2.1. Gadget Bus",id:"621-gadget-bus",level:4},{value:"6.2.2. Gadget Device",id:"622-gadget-device",level:4},{value:"6.2.2.1. Endpoint Alloc",id:"6221-endpoint-alloc",level:5},{value:"6.2.2.2. EndPoint Access",id:"6222-endpoint-access",level:5},{value:"6.2.2.3. UDC Control",id:"6223-udc-control",level:5},{value:"6.2.3. Gadget Driver (Configfs)",id:"623-gadget-driver-configfs",level:4},{value:"6.2.3.1. Configfs \u4f7f\u7528",id:"6231-configfs-\u4f7f\u7528",level:5},{value:"6.2.3.2. Configfs \u5c42\u6b21\u7ed3\u6784",id:"6232-configfs-\u5c42\u6b21\u7ed3\u6784",level:5},{value:"6.2.3.3. Gadget Driver",id:"6233-gadget-driver",level:5},{value:"6.2.4. Gadget Driver (Legacy)",id:"624-gadget-driver-legacy",level:4},{value:"6.2.4.1. Gadget Drive",id:"6241-gadget-drive",level:5},{value:"6.2.4.2. Composite Device",id:"6242-composite-device",level:5},{value:"6.3. USB Interface Layer",id:"63-usb-interface-layer",level:3},{value:"6.3.1. Function \u6ce8\u518c",id:"631-function-\u6ce8\u518c",level:4},{value:"6.3.2. Gadget API",id:"632-gadget-api",level:4},{value:"7. \u5e38\u89c1\u95ee\u9898",id:"7-\u5e38\u89c1\u95ee\u9898",level:2},{value:"7.1. \u81ea\u52a8\u5207\u6362 Host/Device",id:"71-\u81ea\u52a8\u5207\u6362-hostdevice",level:3},{value:"7.1.1. \u914d\u7f6e\u4fee\u6539",id:"711-\u914d\u7f6e\u4fee\u6539",level:4},{value:"7.1.2. \u624b\u52a8\u5207\u6362",id:"712-\u624b\u52a8\u5207\u6362",level:4}];function u(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"usb-\u4f7f\u7528\u6307\u5357",children:"USB \u4f7f\u7528\u6307\u5357"}),"\n",(0,i.jsx)(n.h2,{id:"1-\u914d\u7f6e\u6307\u5357",children:"1. \u914d\u7f6e\u6307\u5357"}),"\n",(0,i.jsx)(n.p,{children:"ArtinChip \u63d0\u4f9b\u4e86 2 \u8def USB Host \u7aef\u53e3 \u548c 1 \u8def USB Device \u7aef\u53e3\uff0c\u9700\u8981\u5206\u522b\u8fdb\u884c\u914d\u7f6e\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"11-usb-host-\u914d\u7f6e",children:"1.1. USB Host \u914d\u7f6e"}),"\n",(0,i.jsx)(n.h4,{id:"111-usb-host-controller-\u914d\u7f6e",children:"1.1.1. USB Host Controller \u914d\u7f6e"}),"\n",(0,i.jsx)(n.p,{children:"\u9996\u5148\u9700\u8981\u914d\u7f6e\u597d USB Host Contoller \uff0cArtinChip \u5728 1 \u4e2a USB Host \u7aef\u53e3\u4e2d\u63d0\u4f9b\u4e86 2 \u7c7b Host Contoller\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u9488\u5bf9 USB 2.0 (High Speed) \u7684 EHCI \u63a7\u5236\u5668"}),"\n",(0,i.jsx)(n.li,{children:"\u9488\u5bf9 USB 1.0/1.1 (Low/Full Speed) \u7684 OHCI \u63a7\u5236\u5668"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\u5728\u8f6f\u4ef6\u4e0a\u9700\u8981\u9700\u8981\u5206\u5f00\u914d\u7f6e\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"1111-ehci-\u914d\u7f6e",children:"1.1.1.1. EHCI \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d\u4f7f\u80fd\u76f8\u5e94 EHCI Driver\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support\n\n <*>   EHCI HCD (USB 2.0) support\n [*]     Root Hub Transaction Translators\n [*]     Improved Transaction Translator scheduling\n <*>     Support for Artinchip on-chip EHCI USB controller\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u6ce8\u89e3"}),"\n",(0,i.jsxs)(n.p,{children:["\u5185\u6838\u914d\u7f6e\u4e3b\u8981\u662f\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"make menuconfig"})," \u547d\u4ee4\u8fdb\u884ckernel\u7684\u529f\u80fd\u9009\u62e9\uff0c\u914d\u7f6e\u5b8c\u6210\u540e\u7684\u9879\u76ee\u5b58\u50a8\u5728 ",(0,i.jsx)(n.code,{children:"target/configs/xxx_defconfig"})," \u6587\u4ef6\u4e2d\u3002"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"DTS \u6587\u4ef6\u4e2d\u914d\u7f6e\u76f8\u5e94 EHCI Device:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'usbh0: usb@10210000 {\n    compatible = "artinchip,aic-usbh-v1.0";\n    reg = <0x0 0x10210000 0x0 0x100>;\n    interrupts-extended = <&plic0 35 IRQ_TYPE_LEVEL_HIGH>, <&plic0 4 IRQ_TYPE_LEVEL_HIGH>;\n    clocks = <&cmu CLK_USBH0>;\n    clock-names = "usbh";\n    resets = <&rst RESET_USBH0>;\n    reset-names = "usbh";\n    dr_mode = "host";\n};\n\nusbh1: usb@10220000 {\n    compatible = "artinchip,aic-usbh-v1.0";\n    reg = <0x0 0x10220000 0x0 0x100>;\n    interrupts-extended = <&plic0 37 IRQ_TYPE_LEVEL_HIGH>,\n                        <&plic0 38 IRQ_TYPE_LEVEL_HIGH>;\n    clocks = <&cmu CLK_USBH1>;\n    clock-names = "usbh";\n    resets = <&rst RESET_USBH1>, <&rst RESET_USBPHY1>;\n    reset-names = "usbh", "usbh-phy";\n    dr_mode = "host";\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u6ce8\u89e3"}),"\n",(0,i.jsxs)(n.p,{children:["\u8fd9\u4e9b\u53c2\u6570\u4e3b\u8981\u5728\u6587\u4ef6 ",(0,i.jsx)(n.code,{children:"target/d211/common/d211.dtsi"})," \u4e2d\uff0c\u6a21\u5757\u7cfb\u7edf\u53c2\u6570\u968f IC \u7684\u8bbe\u5b9a\u800c\u5b9a\uff0c\u4e00\u822c\u4e0d\u80fd\u8fdb\u884c\u66f4\u6539\uff0c\u9664\u975e\u66f4\u6362\u4e86\u65b0\u7684 IC\uff0c\u5219\u9700\u8981\u5728\u4e13\u4e1a\u4eba\u58eb\u7684\u6307\u5bfc\u4e0b\u8fdb\u884c\u66f4\u6539\u3002"]}),"\n",(0,i.jsx)(n.h5,{id:"1112-ohci-\u914d\u7f6e",children:"1.1.1.2. OHCI \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d\u4f7f\u80fd\u76f8\u5e94 EHCI Driver\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support\n\n <*>   OHCI HCD (USB 1.1) support\n <*>     Support for Artinchip on-chip OHCI USB controller\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"DTS \u6587\u4ef6\u4e2d\u914d\u7f6e\u76f8\u5e94 EHCI Device:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'ohci0: usb@10210400 {\n    compatible = "artinchip,aic-ohci-v1.0";\n    reg = <0x10210400 0x100>;\n    interrupts = <&plic0 4 IRQ_TYPE_LEVEL_HIGH>;\n    num-ports = <1>;\n};\n\nohci1: usb@10220400 {\n    compatible = "artinchip,aic-ohci-v1.0";\n    reg = <0x10220400 0x100>;\n    interrupts = <&plic0 6 IRQ_TYPE_LEVEL_HIGH>;\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"112-usb-interface-\u9a71\u52a8\u914d\u7f6e",children:"1.1.2. USB Interface \u9a71\u52a8\u914d\u7f6e"}),"\n",(0,i.jsx)(n.p,{children:"\u5728\u914d\u7f6e\u597d USB Host Controller \u4ee5\u540e\uff0c\u5c31\u80fd\u591f\u6b63\u786e\u8bc6\u522b\u63d2\u5165 USB \u603b\u7ebf\u7684 Device \u8bbe\u5907\u4e86\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u4f46\u662f USB Device \u6709\u5f88\u591a\u4e0d\u540c\u7c7b\u578b (\u4f8b\u5982\uff1aU \u76d8\u3001\u952e\u76d8\u9f20\u6807\u3001\u65e0\u7ebf\u7f51\u5361 \u2026) \uff0c\u8fd9\u4e9b\u529f\u80fd\u90fd\u662f\u5728 USB Device \u4e2d\u4ee5 Interface \u4e3a\u5355\u4f4d\u63d0\u4f9b\u7684\u3002\u6240\u4ee5\u8981\u4f7f\u7528 USB Device \u7684\u5177\u4f53\u529f\u80fd\uff0c\u8fd8\u9700\u8981\u914d\u7f6e\u4e0d\u540c\u7c7b\u578b USB Interface \u7684\u9a71\u52a8\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"1121-u-\u76d8-\u914d\u7f6e",children:"1.1.2.1. U \u76d8 \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"U \u76d8\u662f USB 2.0 \u8bbe\u5907\uff0c\u6240\u4ee5\u9996\u5148\u5f97\u914d\u7f6e\u597d\u4e0a\u8282\u4e2d\u7684 EHCI\uff0c\u518d\u8fdb\u884c\u4e0b\u9762\u7684\u914d\u7f6e\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u5728 Linux Kernel Kconfig \u4e2d\u4f7f\u80fd\u5bf9 USB Mass Storage \u7c7b\u578b\u7684 USB Interface \u9a71\u52a8\u7684\u652f\u6301\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support\n\n <*>   USB Mass Storage support\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u8fd8\u9700\u8981\u4f7f\u80fd\u5176\u4ed6\u76f8\u5173\u914d\u7f6e\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\u5757\u8bbe\u5907\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers\n\n [*] Block devices  ---\x3e\n"})}),"\n",(0,i.jsx)(n.p,{children:"SCSI \u8bbe\u5907\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > SCSI device support\n\n <*> SCSI device support\n [*] legacy /proc/scsi/ support\n     *** SCSI support type (disk, tape, CD-ROM) ***\n <*> SCSI disk support\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u6587\u4ef6\u7cfb\u7edf\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> File systems > DOS/FAT/EXFAT/NT Filesystems\n\n <*> VFAT (Windows-95) fs support\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u63d2\u5165 U \u76d8\uff0c\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"mount"})," \u547d\u4ee4\u5c06 U \u76d8\u6302\u8f7d\u5230\u5408\u9002\u7684\u76ee\u5f55\u4e0b\u5c31\u53ef\u4ee5\u64cd\u4f5c\u4e86\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] #\n[ 1591.469696] usb 1-1: new high-speed USB device number 3 using aic-ehci\n[ 1591.674435] usb-storage 1-1:1.0: USB Mass Storage device detected\n[ 1591.682567] scsi host0: usb-storage 1-1:1.0\n[ 1592.692021] scsi 0:0:0:0: Direct-Access     SanDisk  Cruzer Blade     1.00 PQ: 0 ANSI: 6\n[ 1592.714329] sd 0:0:0:0: [sda] 30842880 512-byte logical blocks: (15.8 GB/14.7 GiB)\n[ 1592.724171] sd 0:0:0:0: [sda] Write Protect is off\n[ 1592.730166] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA\n[ 1592.751720]  sda: sda1\n[ 1592.768330] sd 0:0:0:0: [sda] Attached SCSI removable disk\n\n[aic@] # mount -t vfat /dev/sda1 /mnt/u\n[aic@] # ls /mnt/u\nSystem Volume Information  u-boot-spl-dtb.bin\nu-boot-dtb.bin             vmlinux\nu-boot-dtb.img             zImage\nu-boot-spl-dtb.aic\n[aic@] #\n"})}),"\n",(0,i.jsx)(n.h5,{id:"1122-usb-\u952e\u76d8\u9f20\u6807-\u914d\u7f6e",children:"1.1.2.2. USB \u952e\u76d8/\u9f20\u6807 \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"U \u76d8\u662f USB 1.0/1.1 \u8bbe\u5907\uff0c\u6240\u4ee5\u9996\u5148\u5f97\u914d\u7f6e\u597d\u4e0a\u8282\u4e2d\u7684 OHCI\uff0c\u518d\u8fdb\u884c\u4e0b\u9762\u7684\u914d\u7f6e\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u5728 Linux Kernel Kconfig \u4e2d\u4f7f\u80fd\u5bf9 USB HID \u7c7b\u578b\u7684 USB Interface \u9a71\u52a8\u7684\u652f\u6301\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > HID support > USB HID support\n\n <*> USB HID transport layer\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u63d2\u5165\u952e\u76d8\u9f20\u6807\uff0c\u53ef\u4ee5\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"/dev/input/event"})," \u6587\u4ef6\u8bfb\u53d6\u5230\u952e\u76d8\u9f20\u6807\u4e0a\u62a5\u7684\u6570\u636e\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] #\n[   14.210983] usb 2-1: new low-speed USB device number 2 using aic-ohci\n[   14.478006] random: fast init done\n[   14.497013] input: PixArt Dell MS116 USB Optical Mouse as /devices/platform/soc/10220400.usb/usb2/2-1/2-1:1.0/0003:413C:301A.0001/input/input2\n[   14.510871] hid-generic 0003:413C:301A.0001: input: USB HID v1.11 Mouse [PixArt Dell MS116 USB Optical Mouse] on usb-10220400.usb-1/input0\n\n[aic@] # hexdump /dev/input/event2\n0000000 e138 5e0b 4c30 0004 0004 0004 0001 0009\n0000010 e138 5e0b 4c30 0004 0001 0110 0001 0000\n0000020 e138 5e0b 4c30 0004 0000 0000 0000 0000\n0000030 e138 5e0b d657 0007 0004 0004 0001 0009\n0000040 e138 5e0b d657 0007 0001 0110 0000 0000\n0000050 e138 5e0b d657 0007 0000 0000 0000 0000\n0000060 e139 5e0b 9085 0003 0004 0004 0001 0009\n0000070 e139 5e0b 9085 0003 0001 0110 0001 0000\n0000080 e139 5e0b 9085 0003 0000 0000 0000 0000\n0000090 e139 5e0b a3bc 0005 0004 0004 0001 0009\n00000a0 e139 5e0b a3bc 0005 0001 0110 0000 0000\n00000b0 e139 5e0b a3bc 0005 0000 0000 0000 0000\n"})}),"\n",(0,i.jsx)(n.h3,{id:"12-usb-device-\u914d\u7f6e",children:"1.2. USB Device \u914d\u7f6e"}),"\n",(0,i.jsx)(n.p,{children:"\u9996\u5148\u8981\u914d\u7f6e\u597d USB Device Controller\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"121-usb-device-controller-\u914d\u7f6e",children:"1.2.1. USB Device Controller \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d\u4f7f\u80fd\u76f8\u5e94 UDC Driver\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support > USB Peripheral Controller\n\n <*> ArtinChip USB2.0 Device Controller\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"DTS \u6587\u4ef6\u4e2d\u914d\u7f6e\u76f8\u5e94 UDC Device:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'aicudc: udc@10200000 {\n    compatible = "artinchip,aic-udc-v1.0";\n    reg = <0x0 0x10200000 0x0 0x1000>;\n    interrupts-extended = <&plic0 34 IRQ_TYPE_LEVEL_HIGH>;\n    clocks = <&cmu CLK_USBD>, <&cmu CLK_USB_PHY0>;\n    clock-names = "udc_clk";\n    resets = <&rst RESET_USBD>, <&rst RESET_USBPHY0>;\n    reset-names = "aicudc", "aicudc-ecc";\n    status = "okay";\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"122-usb-gadget-\u914d\u7f6e",children:"1.2.2. USB Gadget \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.p,{children:["\u4e3a\u4e86\u65b9\u4fbf Linux \u7cfb\u7edf\u6a21\u62df\u6210\u5404\u79cd\u7c7b\u578b\u7684 USB Device\uff0cLinux \u8bbe\u8ba1\u4e86\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Gadget Device"})," \u3002\u4e3a\u4e86\u65b9\u4fbf\u7528\u6237\u4f7f\u7528 \uff0cLinux \u53c8\u5c06 ",(0,i.jsx)(n.code,{children:"ConfigFS"})," \u5f15\u5165 USB Device \u5b50\u7cfb\u7edf\uff0c\u7528\u6765\u7075\u6d3b\u914d\u7f6e ",(0,i.jsx)(n.code,{children:"Gadget Device"}),"\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"\u6240\u4ee5\u5728\u4f7f\u7528 USB Device \u65f6\uff0c\u5728 Linux Kernel \u4e2d\u628a\u8fd9\u4e24\u8005\u90fd\u914d\u7f6e\u6210\u4f7f\u80fd\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"1221-gadget-\u914d\u7f6e",children:"1.2.2.1. Gadget \u914d\u7f6e"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support\n\n <*>   USB Gadget Support  ---\x3e\n"})}),"\n",(0,i.jsx)(n.h5,{id:"1222-configfs-\u914d\u7f6e",children:"1.2.2.2. ConfigFS \u914d\u7f6e"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support\n\n <*>   USB Gadget functions configurable through configfs\n"})}),"\n",(0,i.jsx)(n.h4,{id:"123-usb-interface-\u914d\u7f6e",children:"1.2.3. USB Interface \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 ",(0,i.jsx)(n.code,{children:"Gadget Device"})," \u57fa\u7840\u4e4b\u4e0a\uff0c\u9700\u8981\u914d\u7f6e\u5177\u4f53\u7684 ",(0,i.jsx)(n.code,{children:"Interface / Function"})," \u624d\u80fd\u63d0\u4f9b\u5177\u4f53\u7684 USB Device \u529f\u80fd\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"USB Gadget Device \u53ef\u4ee5\u6a21\u62df\u6210\u5404\u79cd\u529f\u80fd\u7684 USB \u5916\u8bbe\uff0c\u4f8b\u5982\uff1aUSB \u4e32\u53e3\u3001USB \u7f51\u53e3\u3001U \u76d8\u3002\u3002\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"1231-acm-\u4e32\u53e3-\u914d\u7f6e",children:"1.2.3.1. ACM \u4e32\u53e3 \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Linux Kernel Kconfig \u6587\u4ef6\u4e2d\u4f7f\u80fd ",(0,i.jsx)(n.code,{children:"CDC ACM"})," \u7c7b\u578b\u7684 ",(0,i.jsx)(n.code,{children:"Gadget functions"})," \uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support\n\n <*>   USB Gadget functions configurable through configfs\n [*]     Abstract Control Model (CDC ACM)\n\n\n> Device Drivers\n\n [*] Block devices  ---\x3e\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u901a\u8fc7\u7528\u6237\u6001\u7684 configfs \u6587\u4ef6\u63a5\u53e3\u521b\u5efa\u5305\u542b ",(0,i.jsx)(n.code,{children:"ACM"})," \u4e32\u53e3\u529f\u80fd\u7684 USB Device\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'mount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\nmkdir g1\ncd g1\necho "0x1d6b" > idVendor\necho "0x0104" > idProduct\nmkdir strings/0x409\nls strings/0x409/\necho "0123456789" > strings/0x409/serialnumber\necho "AIC Inc." > strings/0x409/manufacturer\necho "Bar Gadget" > strings/0x409/product\nmkdir functions/acm.GS0\nmkdir configs/c.1\nls configs/c.1\nmkdir configs/c.1/strings/0x409\nls configs/c.1/strings/0x409/\necho "ACM" > configs/c.1/strings/0x409/configuration\nln -s functions/acm.GS0 configs/c.1\necho `ls /sys/class/udc` > UDC\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u7528\u6237\u4f7f\u7528\uff1a"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u5c06\u5355\u677f\u7684 USB Device \u7aef\u53e3\u548c Windows PC \u7684 USB Host \u7aef\u53e3\u8fde\u63a5\uff0c\u5728 Windows PC \u8bbe\u5907\u7ba1\u7406\u5668\u4f1a\u770b\u5230\u4e00\u4e2a\u65b0\u7684USB\u4e32\u53e3\u8282\u70b9\uff1a"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/serial_win_res-17067633659793.png",alt:"image0"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u5728 PC \u7aef\u4f7f\u7528\u4e32\u53e3\u7ec8\u7aef\u5de5\u5177\u6253\u5f00 COM12\uff0c\u6ce2\u7279\u7387\u4f7f\u7528 115200\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["\u5728\u5355\u677f\u7aef\u6267\u884c\uff1a ",(0,i.jsx)(n.code,{children:"echo abd > /dev/ttyGS0"})," \uff0c\u5728 PC \u7aef\u4e32\u53e3\u5c31\u4f1a\u6536\u5230\u8be5\u5b57\u7b26\u4e32\uff1a"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/serial_win_term-17067633720245.png",alt:"image1"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["\u5728\u5355\u677f\u7aef\u6267\u884c ",(0,i.jsx)(n.code,{children:"cat /dev/ttyGS0"})," \uff0c\u5728 PC \u7aef\u5199\u4e00\u4e2a\u5b57\u7b26\u4e32 \u201c123412345\u201d \uff0c\u70b9\u56de\u8f66\u540e\uff0c\u5728\u5355\u677f\u7aef\u4e5f\u80fd\u6536\u5230\u8be5\u5b57\u7b26\u4e32\u3002"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"1232-u-\u76d8-\u914d\u7f6e",children:"1.2.3.2. U \u76d8 \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d \uff1a"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u4f7f\u80fd ",(0,i.jsx)(n.code,{children:"Mass storage"})," \u7c7b\u578b\u7684 ",(0,i.jsx)(n.code,{children:"Gadget functions"})," \uff1a:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support\n\n <*>   USB Gadget functions configurable through configfs\n [*]     Mass storage\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u4f7f\u80fd\u73af\u56de\u5757\u8bbe\u5907\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers\n\n <*>   Loopback device support\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Busybox \u4e2d\u4f7f\u80fd ",(0,i.jsx)(n.code,{children:"losetup"})," \u547d\u4ee4\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:">  Linux System Utilities\n\n [*] losetup (5.5 kb)\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u901a\u8fc7\u7528\u6237\u6001\u7684 configfs \u6587\u4ef6\u63a5\u53e3\u521b\u5efa\u5305\u542b ",(0,i.jsx)(n.code,{children:"Mass storage"})," \u5b58\u50a8\u529f\u80fd\u7684 USB Device\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'dd if=/dev/zero of=/tmp/mass.img bs=128K count=132\nlosetup /dev/loop0 /tmp/mass.img\nmkdir /tmp/media\nmkfs.vfat /dev/loop0\nmount -t vfat /dev/loop0 /tmp/media/\ncp /linuxrc /tmp/media\nsync\n\nmount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\nmkdir g_mass\ncd g_mass\necho "0x200" > bcdUSB\necho "0x100" > bcdDevice\necho "0x1234" > idVendor\necho "0x5678" > idProduct\nmkdir configs/c1.1\nmkdir functions/mass_storage.0\necho /dev/loop0 > functions/mass_storage.0/lun.0/file\nmkdir strings/0x409\necho "0123456789ABCDEF" > strings/0x409/serialnumber\necho "river" > strings/0x409/manufacturer\necho "river_msc" > strings/0x409/product\nmkdir configs/c1.1/strings/0x409\necho "abc" > configs/c1.1/strings/0x409/configuration\nln -s functions/mass_storage.0 configs/c1.1\necho `ls /sys/class/udc` > UDC\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u7528\u6237\u4f7f\u7528\uff1a"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u5c06\u5355\u677f\u7684 USB Device \u7aef\u53e3\u548c Windows PC \u7684 USB Host \u7aef\u53e3\u8fde\u63a5\uff0c\u5728 Windows PC \u4e0a\u4f1a\u770b\u5230\u4e00\u4e2a\u65b0\u589e\u7684 U \u76d8\uff0c\u53ef\u4ee5\u6b63\u5e38\u8bfb\u5199\u3002"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"1233-ncm-\u7f51\u53e3-\u914d\u7f6e",children:"1.2.3.3. NCM \u7f51\u53e3 \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d \uff1a"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u4f7f\u80fd ",(0,i.jsx)(n.code,{children:"CDC NCM"})," \u7c7b\u578b\u7684 ",(0,i.jsx)(n.code,{children:"Gadget functions"})," \uff1a:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support\n\n <*>   USB Gadget functions configurable through configfs\n [*]     Network Control Model (CDC NCM)\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u4f7f\u80fd TCP/IP \u652f\u6301\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Networking support > Networking options\n\n [*] TCP/IP networking\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u901a\u8fc7\u7528\u6237\u6001\u7684 configfs \u6587\u4ef6\u63a5\u53e3\u521b\u5efa\u5305\u542b ",(0,i.jsx)(n.code,{children:"CDC NCM"})," \u4ee5\u592a\u7f51\u529f\u80fd\u7684 USB Device\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'mount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\nmkdir g_ncm\ncd g_ncm\necho "0xA55A" > idVendor\necho "0x0111" > idProduct\nmkdir strings/0x409\necho "0123456789" > strings/0x409/serialnumber\necho "Xyz Inc." > strings/0x409/manufacturer\necho "NCM gadget" > strings/0x409/product\nmkdir functions/ncm.usb0\nmkdir configs/c.1\nmkdir configs/c.1/strings/0x409\necho "NCM" > configs/c.1/strings/0x409/configuration\nln -s functions/ncm.usb0 configs/c.1\necho `ls /sys/class/udc` > UDC\n\nifconfig usb0 up\nifconfig usb0 173.11.1.1\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u7528\u6237\u4f7f\u7528\uff1a"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["\u5c06\u5355\u677f\u7684 USB Device \u7aef\u53e3\u548c Ubuntu PC \u7684 USB Host \u7aef\u53e3\u8fde\u63a5\uff0c\u5728 Ubuntu PC \u4f1a\u770b\u5230\u4e00\u4e2a\u65b0\u7684\u7f51\u7edc\u63a5\u53e3\uff0c\u540d\u5b57\u968f\u673a\uff0c\u7c7b\u4f3c\uff1a ",(0,i.jsx)(n.code,{children:"enx0afcc15d3417"})," \u3002"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["\u914d\u7f6e Ubuntu PC \u7aef\u7684\u7f51\u53e3\u4e3a\u540c\u4e00\u7f51\u6bb5\u5730\u5740\uff0c ",(0,i.jsx)(n.code,{children:"sudo ifconfig enx0afcc15d3417 173.11.1.2"}),"\u3002"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u4e24\u4e2a\u7f51\u53e3\u76f8\u4e92\u53ef\u4ee5 ping \u901a\uff1a"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ubuntu@ubuntu $ ping 173.11.1.1\nPING 173.11.1.1 (173.11.1.1) 56(84) bytes of data.\n64 bytes from 173.11.1.1: icmp_seq=1 ttl=64 time=10.3 ms\n64 bytes from 173.11.1.1: icmp_seq=2 ttl=64 time=5.02 ms\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"1234-ecm-\u7f51\u53e3-\u914d\u7f6e",children:"1.2.3.4. ECM \u7f51\u53e3 \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d \uff1a"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u4f7f\u80fd ",(0,i.jsx)(n.code,{children:"CDC ECM"})," \u7c7b\u578b\u7684 ",(0,i.jsx)(n.code,{children:"Gadget functions"})," \uff1a:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support\n\n <*>   USB Gadget functions configurable through configfs\n [*]     Ethernet Control Model (CDC ECM)\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u4f7f\u80fd TCP/IP \u652f\u6301\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Networking support > Networking options\n\n [*] TCP/IP networking\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u901a\u8fc7\u7528\u6237\u6001\u7684 configfs \u6587\u4ef6\u63a5\u53e3\u521b\u5efa\u5305\u542b ",(0,i.jsx)(n.code,{children:"CDC ECM"})," \u4ee5\u592a\u7f51\u529f\u80fd\u7684 USB Device\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'mount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\nmkdir g_ecm\ncd g_ecm\necho "0x1d6b" > idVendor\necho "0x0104" > idProduct\nmkdir strings/0x409\necho "0123456789" > strings/0x409/serialnumber\necho "AIC Inc." > strings/0x409/manufacturer\necho "Bar Gadget" > strings/0x409/product\nmkdir functions/ecm.usb0\nmkdir configs/c.1\nmkdir configs/c.1/strings/0x409\necho "ECM" > configs/c.1/strings/0x409/configuration\nln -s functions/ecm.usb0 configs/c.1\necho `ls /sys/class/udc` > UDC\n\nifconfig usb0 up\nifconfig usb0 173.11.1.1\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u7528\u6237\u4f7f\u7528\uff1a\u548c\u4e0a\u4e00\u8282 NCM \u7f51\u53e3 \u4e00\u6837\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"1235-adbd-\u914d\u7f6e",children:"1.2.3.5. ADBD \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d \uff1a"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u4f7f\u80fd ",(0,i.jsx)(n.code,{children:"FunctionFS"})," \u7c7b\u578b\u7684 ",(0,i.jsx)(n.code,{children:"Gadget functions"})," \uff1a:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support > USB Gadget Support\n\n <*>   USB Gadget functions configurable through configfs\n [*]     Function filesystem (FunctionFS)\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u4f7f\u80fd TCP/IP \u652f\u6301\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Networking support > Networking options\n\n [*] TCP/IP networking\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u901a\u8fc7\u7528\u6237\u6001\u7684 configfs \u6587\u4ef6\u63a5\u53e3\u521b\u5efa ",(0,i.jsx)(n.code,{children:"FunctionFS"})," \u4e2d\u7684 USB Device\uff0c\u6302\u8f7d\u5b8c FunctionFS \u6587\u4ef6\u7cfb\u7edf\u4ee5\u540e\uff0c ",(0,i.jsx)(n.code,{children:"adbd"})," \u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"/dev/usb-ffs/adb"})," \u4e2d\u6620\u5c04\u6210\u6587\u4ef6\u7684 endpoint \u76f4\u63a5\u548c USB Host \u8fdb\u884c\u901a\u8baf\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'mkdir /dev/pts\nmount -t devpts none /dev/pts\n\nmount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\nmkdir g_adb\ncd g_adb\necho "0x18d1" > idVendor\necho "0x4e26" > idProduct\nmkdir configs/c.1\nmkdir functions/ffs.adb\nmkdir strings/0x409\nmkdir configs/c.1/strings/0x409\necho "0123456789ABCDEF" > strings/0x409/serialnumber\necho "AIC Inc." > strings/0x409/manufacturer\necho "FunctionFS gadget (adb)" > strings/0x409/product\necho "Conf 1" > configs/c.1/strings/0x409/configuration\necho 120 > configs/c.1/MaxPower\nln -s functions/ffs.adb configs/c.1\n\nmkdir -p /dev/usb-ffs/adb\nmount -o uid=2000,gid=2000 -t functionfs adb /dev/usb-ffs/adb\n\nifconfig lo up\nifconfig\n\ncd /root\nadbd&\n\nsleep 1\necho `ls /sys/class/udc/` > /sys/kernel/config/usb_gadget/g_adb/UDC\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"\u7528\u6237\u4f7f\u7528\uff1a"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\u5c06\u5355\u677f\u7684 USB Device \u7aef\u53e3\u548c PC \u7684 USB Host \u7aef\u53e3\u8fde\u63a5\uff0c\u5728 PC \u7aef\u8fd0\u884c ",(0,i.jsx)(n.code,{children:"adb shell"})," \u547d\u4ee4\u5373\u53ef\u8fdb\u884c adb \u64cd\u4f5c\u3002"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"13-usb-otg-\u914d\u7f6e",children:"1.3. USB OTG \u914d\u7f6e"}),"\n",(0,i.jsxs)(n.p,{children:["USB Host 0 \u548c USB Device 0 \u5171\u4eab 1 \u8def phy\u3002\u8981\u4e48\u540c\u65f6\u53ea\u80fd\u542f\u7528\u5176\u4e2d\u4e00\u79cd\u529f\u80fd\uff0c\u8981\u4e48\u542f\u7528 USB OTG \u529f\u80fd\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"id"})," \u7ba1\u811a\u7684\u503c\u6765\u52a8\u6001\u5207\u6362\u5bf9\u5916\u529f\u80fd\u3002"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Linux Kernel Kconfig \u6587\u4ef6\u4e2d\u4f7f\u80fd\u76f8\u5e94 OTG Driver\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support\n\n  [*]   OTG support\n  [*]     Support for Artinchip on-chip OTG Switch\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"DTS \u6587\u4ef6\u4e2d\u914d\u7f6e\u76f8\u5e94 OTG Device:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'otg: usb-otg {\n    compatible = "artinchip,aic-otg-v2.0";\n};\n\n&otg {\n    otg-mode = "auto";      //  = auto/host/device\n    id-gpios = <&gpio_f 15 GPIO_ACTIVE_HIGH>;\n    vbus-en-gpios = <&gpio_a 7 GPIO_ACTIVE_HIGH>;\n    dp-sw-gpios = <&gpio_e 14 GPIO_ACTIVE_LOW>;\n    status = "okay";\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"131-otg-\u6a21\u5f0f\u914d\u7f6e",children:"1.3.1. OTG \u6a21\u5f0f\u914d\u7f6e"}),"\n",(0,i.jsxs)(n.p,{children:["OTG \u53ef\u4ee5\u914d\u7f6e\u6210 ",(0,i.jsx)(n.code,{children:"Auto \u6a21\u5f0f"})," \u6216\u8005 ",(0,i.jsx)(n.code,{children:"Force \u6a21\u5f0f"})," \uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Auto \u6a21\u5f0f"}),"\u3002\u6839\u636e ",(0,i.jsx)(n.code,{children:"id"})," \u7ba1\u811a\u7684\u7535\u5e73\u6765\u51b3\u5b9a\u5f53\u524d OTG \u7aef\u53e3\u5de5\u4f5c\u6a21\u5f0f\u4e3a ",(0,i.jsx)(n.code,{children:"Host"})," / ",(0,i.jsx)(n.code,{children:"Device"})," \uff0c\u901a\u5e38\u60c5\u51b5\u4e0b ",(0,i.jsx)(n.code,{children:"id = low"})," \u5bf9\u5e94 ",(0,i.jsx)(n.code,{children:"Host"})," \u6a21\u5f0f\uff0c ",(0,i.jsx)(n.code,{children:"id = high"})," \u5bf9\u5e94 ",(0,i.jsx)(n.code,{children:"Device"})," \u6a21\u5f0f\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Force \u6a21\u5f0f"}),"\u3002\u624b\u5de5\u914d\u7f6e\u5de5\u4f5c\u6a21\u5f0f\uff0c\u901a\u8fc7\u914d\u7f6e ",(0,i.jsx)(n.code,{children:"/sys/devices/platform/soc/soc\\:usb-otg/otg_mode"})," \u6587\u4ef6\u8282\u70b9\u7684\u503c\u6765\u6539\u53d8\u5f53\u524d OTG \u7aef\u53e3\u7684\u5de5\u4f5c\u6a21\u5f0f\uff0c ",(0,i.jsx)(n.code,{children:"host"})," \u5bf9\u5e94 ",(0,i.jsx)(n.code,{children:"Host"})," \u6a21\u5f0f\uff0c ",(0,i.jsx)(n.code,{children:"device"})," \u5bf9\u5e94 ",(0,i.jsx)(n.code,{children:"Device"})," \u6a21\u5f0f\u3002\u53e6\u5916 ",(0,i.jsx)(n.code,{children:"auto"})," \u5bf9\u5e94 ",(0,i.jsx)(n.code,{children:"Auto"})," \u6a21\u5f0f\uff0c\u9700\u8981\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"id"})," \u7ba1\u811a\u6765\u8fdb\u884c\u5224\u65ad\u3002"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u4e24\u79cd\u6a21\u5f0f\u5bf9\u5e94 DTS \u6587\u4ef6\u4e2d\u7684 ",(0,i.jsx)(n.code,{children:"otg"})," \u8282\u70b9\u7684\u4e0d\u540c\u914d\u7f6e\uff1a"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Mode"}),(0,i.jsxs)(n.th,{children:["DTS ",(0,i.jsx)(n.code,{children:"otg-mode"})," \u5c5e\u6027"]}),(0,i.jsxs)(n.th,{children:["DTS ",(0,i.jsx)(n.code,{children:"xxx-gpios"})," \u5c5e\u6027"]}),(0,i.jsxs)(n.th,{children:["\u8fd0\u884c\u65f6 ",(0,i.jsx)(n.code,{children:"Host"})," / ",(0,i.jsx)(n.code,{children:"Device"})," \u5207\u6362\u65b9\u6cd5"]})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Auto"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:'otg-mode = "auto";'})," (\u5982\u679c\u6ca1\u6709\u914d\u7f6e ",(0,i.jsx)(n.code,{children:"otg-mode"})," \u5c5e\u6027, \u9ed8\u8ba4\u4e5f\u662f Auto \u6a21\u5f0f)"]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"id-gpios"})," \u5c5e\u6027\u5fc5\u987b\u914d\u7f6e\uff1b ",(0,i.jsx)(n.code,{children:"vbus-en-gpios"})," \u548c ",(0,i.jsx)(n.code,{children:"dp-sw-gpios"})," \u5c5e\u6027\u6839\u636e\u786c\u4ef6\u914d\u7f6e\u9009\u914d\u3002"]}),(0,i.jsxs)(n.td,{children:["OTG \u9a71\u52a8\u6839\u636e ",(0,i.jsx)(n.code,{children:"id-gpios"})," \u7ba1\u811a\u7684\u7535\u5e73\u53d8\u5316 \u81ea\u52a8\u5207\u6362 USB \u5de5\u4f5c\u6a21\u5f0f\u4e3a ",(0,i.jsx)(n.code,{children:"Host"})," / ",(0,i.jsx)(n.code,{children:"Device"}),"\u3002"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Force"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:'otg-mode = "device";'})," \u6216\u8005 ",(0,i.jsx)(n.code,{children:'otg-mode = "host";'})]}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"id-gpios"})," \u5c5e\u6027\u4e0d\u9700\u8981\u914d\u7f6e\uff1b ",(0,i.jsx)(n.code,{children:"vbus-en-gpios"})," \u548c ",(0,i.jsx)(n.code,{children:"dp-sw-gpios"})," \u5c5e\u6027\u6839\u636e\u786c\u4ef6\u914d\u7f6e\u9009\u914d\u3002"]}),(0,i.jsxs)(n.td,{children:["\u9700\u8981\u914d\u7f6e\u6587\u4ef6\u8282\u70b9\u6765\u624b\u5de5\u5207\u6362\uff1a ",(0,i.jsx)(n.code,{children:"echo devices > /sys/devices/platform/soc/soc\\:usb-otg/otg_mode"})," \u6216\u8005 ",(0,i.jsx)(n.code,{children:"echo host > /sys/devices/platform/soc/soc\\:usb-otg/otg_mode"})]})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"132-otg-\u76f8\u5173-gpio",children:"1.3.2. OTG \u76f8\u5173 GPIO"}),"\n",(0,i.jsx)(n.p,{children:"\u4ece\u4e0a\u9762\u914d\u7f6e\u53ef\u4ee5\u770b\u5230\u548c OTG \u529f\u80fd\u76f8\u5173\u7684 GPIO \u7ba1\u811a\u6709 3 \u4e2a\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"id-gpios"})," \u3002\u7528\u6765\u68c0\u6d4b\u5f53\u524d\u63d2\u5165\u7684\u662f\u4e0d\u662f OTG \u7ebf\uff0c\u5982\u679c\u4e3a OTG \u7ebf\u5219\u9700\u8981\u628a\u672c\u673a\u5207\u6362\u5230 USB Host \u6a21\u5f0f\uff0c\u5426\u5219\u672c\u673a\u5207\u6362\u5230 USB Device \u6a21\u5f0f\u3002\u8be5\u7ba1\u811a\u5728 ",(0,i.jsx)(n.code,{children:"Auto \u6a21\u5f0f"})," \u6a21\u5f0f\u4e0b\u662f\u5fc5\u987b\u914d\u7f6e\u7684\uff0c\u5982\u679c\u7f3a\u5c11\u8be5\u7ba1\u811a OTG \u53ea\u80fd\u5de5\u4f5c\u5728 ",(0,i.jsx)(n.code,{children:"Force \u6a21\u5f0f"})," \u624b\u5de5\u8fdb\u884c\u5207\u6362\u3002"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"vbus-en-gpios"})," \u3002\u8be5\u7ba1\u811a\u662f\u7528\u6765\u63a7\u5236 VBUS \u7684 5V \u8f93\u51fa\u7684\uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\uff1a\u5207\u6362\u5230 USB Host \u6a21\u5f0f\u65f6\u9700\u8981\u4f7f\u80fd\u672c\u673a\u7aef\u7684 VBUS 5V \u8f93\u51fa\u7ed9\u5bf9\u7aef Device \u4f9b\u7535\uff0c\u5207\u6362\u5230 USB Device \u6a21\u5f0f\u65f6\u9700\u8981\u5173\u95ed\u672c\u673a\u7aef\u7684 VBUS 5V \u8f93\u51fa\u8f6c\u800c\u5bf9\u7aef Host \u7684\u4f9b\u7535\u3002\uff08\u5b9e\u9645\u4f7f\u7528\u4e0a\u6765\u8bf4\uff0c\u4e0d\u8bba\u672c\u7aef\u662f Host/Device \u6a21\u5f0f\uff0c\u4e5f\u53ef\u4ee5\u5728 VBUS \u4e0a\u4e00\u76f4\u4f9b\u7535 5V \u4e24\u8fb9 VBUS \u65e0\u538b\u5dee\u5219\u65e0\u6f0f\u7535\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0b ",(0,i.jsx)(n.code,{children:"vbus-en-gpios"})," \u65e0\u9700\u914d\u7f6e\u3002\uff09"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"dp-sw-gpios"})," \u3002\u8be5\u7ba1\u811a\u662f\u5728 OTG \u5916\u51fa\u4e24\u4e2a\u72ec\u7acb Host\u3001Device \u7aef\u53e3\u65f6\uff0c\u7528\u6765\u63a7\u5236\u5916\u90e8 Switch \u7684\u3002\u975e\u8be5\u6a21\u5f0f\u65f6\uff0c ",(0,i.jsx)(n.code,{children:"dp-sw-gpios"})," \u65e0\u9700\u914d\u7f6e\u3002"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/otg_gpio-17067633468021.png",alt:"image2"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["3 \u4e2a GPIO \u7ba1\u811a\u7684\u5177\u4f53\u4f7f\u7528\u573a\u666f\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u7528\u6237\u6839\u636e\u81ea\u5df1\u7684\u4f7f\u7528\u573a\u666f\u6765\u9009\u62e9\u914d\u7f6e\u54ea\u4e9b GPIO\u3002\u6bcf\u4e2a GPIO \u7684 \u8f93\u5165\u8f93\u51fa\u6b63\u53cd\u7535\u5e73\u6709\u6548\uff0c\u53ef\u4ee5\u901a\u8fc7 DTS \u4e2d\u7684 ",(0,i.jsx)(n.code,{children:"GPIO_ACTIVE_HIGH"})," \u548c ",(0,i.jsx)(n.code,{children:"GPIO_ACTIVE_LOW"})," \u6765\u914d\u7f6e\uff1a"]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"GPIO Name"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"GPIO_ACTIVE_HIGH"}),(0,i.jsx)(n.th,{children:"GPIO_ACTIVE_LOW"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"id-gpios"})}),(0,i.jsx)(n.td,{children:"input"}),(0,i.jsx)(n.td,{children:"\u8f93\u5165\u4f4e\u7535\u5e73 = Host\uff0c\u8f93\u5165\u9ad8\u7535\u5e73 = Device"}),(0,i.jsx)(n.td,{children:"\u8f93\u5165\u4f4e\u7535\u5e73 = Device\uff0c\u8f93\u5165\u9ad8\u7535\u5e73 = Host"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"vbus-en-gpios"})}),(0,i.jsx)(n.td,{children:"output"}),(0,i.jsx)(n.td,{children:"Host (VBUS on) = \u8f93\u51fa\u9ad8\u7535\u5e73Device (VBUS off) = \u8f93\u51fa\u4f4e\u7535\u5e73"}),(0,i.jsx)(n.td,{children:"Host (VBUS on) = \u8f93\u51fa\u4f4e\u7535\u5e73Device (VBUS off) = \u8f93\u51fa\u9ad8\u7535\u5e73"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"dp-sw-gpios"})}),(0,i.jsx)(n.td,{children:"output"}),(0,i.jsx)(n.td,{children:"Host = \u8f93\u51fa\u9ad8\u7535\u5e73Device = \u8f93\u51fa\u4f4e\u7535\u5e73"}),(0,i.jsx)(n.td,{children:"Host = \u4f4e\u7535\u5e73Device = \u9ad8\u7535\u5e73"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"2-\u8c03\u8bd5\u6307\u5357",children:"2. \u8c03\u8bd5\u6307\u5357"}),"\n",(0,i.jsx)(n.h3,{id:"21-usb-host-\u8c03\u8bd5",children:"2.1. USB Host \u8c03\u8bd5"}),"\n",(0,i.jsx)(n.h4,{id:"211-\u67e5\u770b-usb-\u8bbe\u5907",children:"2.1.1. \u67e5\u770b USB \u8bbe\u5907"}),"\n",(0,i.jsx)(n.p,{children:"\u5728\u5355\u677f\u7684 USB Host \u7aef\u53e3\u6709\u8bbe\u5907\u63d2\u5165\u6216\u8005\u62d4\u51fa\u65f6\uff0c\u5355\u677f\u4e32\u53e3\u4f1a\u6709\u6253\u5370\u63d0\u793a\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] #\n[ 6792.678130] usb 1-1: new high-speed USB device number 2 using aic-ehci\n[ 6792.884601] usb-storage 1-1:1.0: USB Mass Storage device detected\n[ 6792.910596] scsi host0: usb-storage 1-1:1.0\n[ 6793.970429] scsi 0:0:0:0: Direct-Access     SanDisk  Cruzer Blade     1.00 PQ: 0 ANSI: 6\n[ 6793.995300] sd 0:0:0:0: [sda] 30842880 512-byte logical blocks: (15.8 GB/14.7 GiB)\n[ 6794.018466] sd 0:0:0:0: [sda] Write Protect is off\n[ 6794.025383] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn't support DPO or FUA\n[ 6794.055267]  sda: sda1\n[ 6794.074720] sd 0:0:0:0: [sda] Attached SCSI removable disk\n[ 6806.436142] usb 1-1: USB disconnect, device number 2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u4e5f\u53ef\u4ee5\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"lsusb"})," \u547d\u4ee4\u67e5\u770b\u76ee\u524d\u7cfb\u7edf USB \u603b\u7ebf\u7684\u60c5\u51b5\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] # lsusb\nBus 001 Device 001: ID 1d6b:0002\nBus 001 Device 003: ID 0781:5567\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5982\u679c\u662f PC \u4e0a\u7684 Linux \u53d1\u884c\u7248\uff0c ",(0,i.jsx)(n.code,{children:"lsusb -v"})," \u547d\u4ee4\u53ef\u4ee5\u67e5\u770b USB \u8bbe\u5907\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u4f46\u662f\u5355\u677f\u4e0a\u4f7f\u7528\u7684 ",(0,i.jsx)(n.code,{children:"lsusb -v"})," \u88ab\u8fdb\u884c\u4e86\u7b80\u5316\u3002"]}),"\n",(0,i.jsx)(n.h4,{id:"212-sysfs-\u8282\u70b9",children:"2.1.2. Sysfs \u8282\u70b9"}),"\n",(0,i.jsxs)(n.p,{children:["\u4e5f\u53ef\u4ee5\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"/sys/kernel/debug/usb/devices"})," \u6587\u4ef6\u8282\u70b9\u67e5\u770b USB \u8bbe\u5907\u7684\u8be6\u7ec6\u4fe1\u606f\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] # mount -t debugfs none /sys/kernel/debug\n\n[aic@] # cat /sys/kernel/debug/usb/devices\n\nT:  Bus=01 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=480  MxCh= 1\nB:  Alloc=  0/800 us ( 0%), #Int=  0, #Iso=  0\nD:  Ver= 2.00 Cls=09(hub  ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1\nP:  Vendor=1d6b ProdID=0002 Rev= 5.10\nS:  Manufacturer=Linux 5.10.44-00071-g935288d48127-dirty ehci_hcd\nS:  Product=EHCI Host Controller\nS:  SerialNumber=10220000.usb\nC:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA\nI:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub\nE:  Ad=81(I) Atr=03(Int.) MxPS=   4 Ivl=256ms\n"})}),"\n",(0,i.jsx)(n.h4,{id:"213-usb-\u603b\u7ebf\u5206\u6790\u4eea",children:"2.1.3. USB \u603b\u7ebf\u5206\u6790\u4eea"}),"\n",(0,i.jsx)(n.p,{children:"\u5728 USB \u8bbe\u5907\u4e0d\u80fd\u6b63\u5e38\u679a\u4e3e\u6216\u8005 USB \u901a\u8baf\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u95ee\u9898\u65f6\uff0c\u6211\u4eec\u4e00\u822c\u4f7f\u7528 USB \u603b\u7ebf\u5206\u6790\u4eea\uff0c\u63a5\u5165\u5230 USB \u603b\u7ebf\u4e0a\u8fdb\u884c\u65c1\u8def\u6293\u5305\u5206\u6790\u3002"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_analy_instrument-17067634244437.png",alt:"image0"})}),"\n",(0,i.jsx)(n.p,{children:"\u6293\u5305\u6570\u636e\u7684\u5206\u6790\u754c\u9762\u5982\u4e0b\u56fe\u6240\u793a\uff1a"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_analy_ui-17067634311569.png",alt:"image1"})}),"\n",(0,i.jsx)(n.p,{children:"USB \u603b\u7ebf\u5206\u6790\u4eea\u5bf9\u6293\u53d6\u7684\u6570\u636e\u5305\u8fdb\u884c\u4e86\u89e3\u6790\uff0c\u7528\u8d77\u6765\u975e\u5e38\u65b9\u4fbf\u3002\u5e02\u9762\u4e0a\u8fd9\u7c7b\u4eea\u5668\u5927\u540c\u5c0f\u5f02\uff0c\u975e\u5e38\u5bb9\u6613\u4e0a\u624b\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"214-usbmon",children:"2.1.4. usbmon"}),"\n",(0,i.jsx)(n.p,{children:"\u5728\u6ca1\u6709\u5916\u90e8 USB \u5206\u6790\u4eea\u7684\u60c5\u51b5\u4e0b\uff0c\u4e5f\u53ef\u4ee5\u4f7f\u7528 Linux \u5185\u6838\u81ea\u5e26\u7684 USB \u6293\u5305\u6a21\u5757 usbmon \u6765\u6293\u53d6\u6570\u636e\u5305\u8fdb\u884c\u5206\u6790\u3002"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u9996\u5148\u5f97\u6253\u5f00 Linux \u5185\u6838\u4e2d\u7684 usbmon \u914d\u7f6e\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"> Device Drivers > USB support\n\n <*>   USB Monitor\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u91cd\u65b0\u7f16\u8bd1\u5185\u6838\u540e\u5c31\u53ef\u4ee5\u8fdb\u884c\u6293\u5305\u4e86\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] # mount -t debugfs none /sys/kernel/debug\n\n[aic@] # ls /sys/kernel/debug/usb/usbmon/\n0s  0u  1s  1t  1u  2s  2t  2u\n[aic@] # cat /sys/kernel/debug/usb/usbmon/0u\nc1b0e380 68846726 C Ii:1:001:1 0:2048 1 = 02\nc1b0e380 68846851 S Ii:1:001:1 -115:2048 4 <\nc7a15900 68847426 S Ci:1:001:0 s a3 00 0000 0001 0004 4 <\nc7a15900 68847507 C Ci:1:001:0 0 4 = 01050100\nc7a15900 68847595 S Co:1:001:0 s 23 01 0010 0001 0000 0\nc7a15900 68847652 C Co:1:001:0 0 0\nc7a15900 68847732 S Ci:1:001:0 s a3 00 0000 0001 0004 4 <\nc7a15900 68847790 C Ci:1:001:0 0 4 = 01050000\nc7a15900 68890082 S Ci:1:001:0 s a3 00 0000 0001 0004 4 <\nc7a15900 68890154 C Ci:1:001:0 0 4 = 01050000\nc7a15900 68940072 S Ci:1:001:0 s a3 00 0000 0001 0004 4 <\nc7a15900 68940142 C Ci:1:001:0 0 4 = 01050000\nc7a15900 68990067 S Ci:1:001:0 s a3 00 0000 0001 0004 4 <\nc7a15900 68990129 C Ci:1:001:0 0 4 = 01050000\n"})}),"\n",(0,i.jsx)(n.h3,{id:"22-usb-device-\u8c03\u8bd5",children:"2.2. USB Device \u8c03\u8bd5"}),"\n",(0,i.jsx)(n.h4,{id:"221-\u67e5\u770b-usb-\u8bbe\u5907",children:"2.2.1. \u67e5\u770b USB \u8bbe\u5907"}),"\n",(0,i.jsx)(n.p,{children:"\u5f53\u5355\u677f\u5145\u5f53 USB Device \u8fde\u63a5\u5230 PC \u4e3b\u673a USB Host \u7aef\u53e3\u65f6\uff0c\u53ef\u4ee5\u5728\u4e3b\u673a\u4e0a\u67e5\u770b USB \u8bbe\u5907\u6709\u6ca1\u6709\u6210\u529f\u88ab\u679a\u4e3e\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Linux \u4e3b\u673a\uff0c\u53ef\u4ee5\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"lsusb"})," \u547d\u4ee4\u8fdb\u884c\u67e5\u770b\u3002"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Windows \u4e3b\u673a\uff0c\u53ef\u4ee5\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"\u8bbe\u5907\u7ba1\u7406\u5668"})," \u547d\u4ee4\u8fdb\u884c\u67e5\u770b\uff1a"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/dev_manager-170676345576411.png",alt:"image2"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"222-sysfs-\u8282\u70b9",children:"2.2.2. Sysfs \u8282\u70b9"}),"\n",(0,i.jsxs)(n.p,{children:["\u5728\u5355\u677f\u4e0a\u4e5f\u53ef\u4ee5\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"/sys/kernel/debug/usb/xxxx.usb/"})," \u6587\u4ef6\u5939\u4e0b\u7684\u6587\u4ef6\u8282\u70b9\uff0c\u5bf9 UDC \u9a71\u52a8\u8fdb\u884c\u914d\u7f6e\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] # ls /sys/class/udc\n10200000.usb\n[aic@] # ls /sys/kernel/debug/usb/10200000.usb/\ndr_mode    ep1out     ep3in      ep4out     params     testmode\nep0        ep2in      ep3out     fifo       regdump\nep1in      ep2out     ep4in      hw_params  state\n[aic@] #\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u4f8b\u5982\u53ef\u4ee5 dump \u5bc4\u5b58\u5668\uff1a:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] # cat /sys/kernel/debug/usb/10200000.usb/regdump\nGOTGCTL = 0x00000000\nGOTGINT = 0x00000000\nGAHBCFG = 0x00000000\nGUSBCFG = 0x00000000\nGRSTCTL = 0x00000000\nGINTSTS = 0x00000000\nGINTMSK = 0x00000000\nGRXSTSR = 0x00000000\nGRXFSIZ = 0x00000000\nGNPTXFSIZ = 0x00000000\nGNPTXSTS = 0x00000000\n"})}),"\n",(0,i.jsx)(n.h4,{id:"223-\u6293\u5305\u5de5\u5177",children:"2.2.3. \u6293\u5305\u5de5\u5177"}),"\n",(0,i.jsx)(n.p,{children:"\u548c USB Host \u8c03\u8bd5\u4e00\u6837\uff0c\u6293\u5305\u53ef\u4ee5\u4f7f\u7528\u4e13\u95e8\u7684 USB \u603b\u7ebf\u5206\u6790\u4eea\u6216\u8005\u5728 Linux \u4e3b\u673a\u4e0a\u4f7f\u7528 usbmon \u8fdb\u884c\u6293\u5305\u3002"}),"\n",(0,i.jsx)(n.h2,{id:"3-\u6d4b\u8bd5\u6307\u5357",children:"3. \u6d4b\u8bd5\u6307\u5357"}),"\n",(0,i.jsx)(n.h3,{id:"31-\u6d4b\u8bd5\u65b9\u6848\u4ecb\u7ecd",children:"3.1. \u6d4b\u8bd5\u65b9\u6848\u4ecb\u7ecd"}),"\n",(0,i.jsx)(n.p,{children:"\u5728\u6d4b\u8bd5 USB \u65f6\uff0c\u666e\u901a\u7684\u505a\u6cd5\u662f\u627e\u4e00\u4e9b U \u76d8\u3001\u9f20\u6807\u3001\u952e\u76d8 \u7b49\u5916\u8bbe\u6765\u505a\u4e00\u4e9b\u6d4b\u8bd5\uff0c\u4f46\u662f\u8fd9\u4e9b\u6d4b\u8bd5\u8fd8\u662f\u504f\u4e0a\u5c42\u504f\u529f\u80fd\u7684\u3002\u76f8\u6bd4\u8f83 HC (USB Host Controller) \u548c UDC (USB Device Controller) \u6309\u7167USB\u534f\u8bae\u63d0\u4f9b\u7684\u5b8c\u6574\u529f\u80fd\u6765\u8bf4\uff0c\u8fd9\u79cd\u6d4b\u8bd5\u9a8c\u8bc1\u65f6\u4e0d\u5145\u5206\u7684\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u5728 Linux Kernel \u4e2d\u5bf9 HC/UDC \u6709\u4e00\u5957\u4e13\u6709\u7684\u6d4b\u8bd5\u65b9\u6848\uff0c\u5728\u5e95\u5c42\u5bf9 control/bulk/int/iso \u51e0\u79cd endpoint \u8fdb\u884c\u9488\u5bf9\u6027\u7684\u529f\u80fd\u548c\u538b\u529b\u6d4b\u8bd5\u3002"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_test_diagram-170676351834313.png",alt:"image0"})}),"\n",(0,i.jsx)(n.p,{children:"\u4e0a\u56fe\u7684\u6d4b\u8bd5\u65b9\u6848\u7531\u51e0\u90e8\u5206\u7ec4\u6210\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["1\u3001Device \u4fa7\u7684 ",(0,i.jsx)(n.code,{children:"gadget zero"})," \u6d4b\u8bd5\u8bbe\u5907\uff0c\u63d0\u4f9b\u4e86\u6d4b\u8bd5\u901a\u9053\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["2\u3001Host \u4fa7\u7684 ",(0,i.jsx)(n.code,{children:"usbtest.ko"})," \u6d4b\u8bd5\u9a71\u52a8\uff0c\u5c01\u88c5\u4e86 30 \u4e2a endpoint \u5c42\u7ea7\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["3\u3001Host \u4fa7\u7684 ",(0,i.jsx)(n.code,{children:"testusb"})," \u7528\u6237\u7a0b\u5e8f\uff0c\u7528\u6765\u8c03\u7528 ",(0,i.jsx)(n.code,{children:"usbtest.ko"})," \u63d0\u4f9b\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"32-device-\u4fa7-gadget-zero",children:["3.2. Device \u4fa7 ",(0,i.jsx)(n.code,{children:"gadget zero"})]}),"\n",(0,i.jsxs)(n.p,{children:["\u63d0\u4f9b\u6d4b\u8bd5\u9700\u8981\u7684Device\u8bbe\u5907\u6709\u5f88\u591a\u79cd\u65b9\u5f0f\uff0c\u4f8b\u5982\u53ef\u7528\u4f7f\u7528\u4e13\u95e8\u7684\u6d4b\u8bd5 Device \u91cc\u9762\u70e7\u5f55\u4e13\u6709\u7684\u6d4b\u8bd5 Firmware\u3002\u8282\u7ea6\u6210\u672c\u7684\u65b9\u5f0f\u8fd8\u662f\u4f7f\u7528 Linux gadget \u529f\u80fd\u6765\u52a8\u6001\u6a21\u62df USB Device \u8bbe\u5907\u3002\u9488\u5bf9 USB \u6d4b\u8bd5\uff0cLinux \u4e13\u95e8\u63d0\u4f9b\u4e86 ",(0,i.jsx)(n.code,{children:"gadget zero"})," \u8bbe\u5907\u3002"]}),"\n",(0,i.jsx)(n.h4,{id:"321-device-\u521b\u5efa",children:"3.2.1. Device \u521b\u5efa"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"gadget zero"})," \u7684\u6838\u5fc3\u662f\u521b\u5efa\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Composite Device"})," \uff0c\u5176\u5305\u542b\u4e86\u4e24\u4e2a ",(0,i.jsx)(n.code,{children:"Configuration"})," \uff0c\u5176\u4e2d\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Configuration 0"})," \u5305\u542b ",(0,i.jsx)(n.code,{children:"SourceSink Function/Interface"})," \uff0c\u53e6\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Configuration 1"})," \u5305\u542b ",(0,i.jsx)(n.code,{children:"Loopback Function/Interface"})," \u3002\u67d0\u4e00\u65f6\u523b\u53ea\u80fd\u9009\u62e9\u4f7f\u7528\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Configuration"})," \uff0c\u901a\u5e38\u60c5\u51b5\u4e0b\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"Configuration 0"})," \u5373 ",(0,i.jsx)(n.code,{children:"SourceSink"})," \u7684\u529f\u80fd\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"gadget zero"})," Device \u7531\u4e24\u79cd\u65b9\u5f0f\u521b\u5efa\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["1\u3001\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"zero_driver"})," \u521b\u5efa\uff0c\u53ea\u8981\u628a\u5bf9\u5e94\u9a71\u52a8\u6587\u4ef6 ",(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\legacy\\zero.c"})," \u7f16\u8bd1\u8fdb\u5185\u6838\u5373\u53ef\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["2\u3001\u901a\u8fc7 ",(0,i.jsx)(n.code,{children:"functionfs"})," \u52a8\u6001\u521b\u5efa\uff0c\u8fd9\u79cd\u65b9\u5f0f\u66f4\u7075\u6d3b\uff0c\u5b9e\u4f8b\u547d\u4ee4\u5982\u4e0b\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'mount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\n\nmkdir g2\ncd g2\n\necho "0x04e8" > idVendor\necho "0x2d01" > idProduct\n\nmkdir configs/c.1\nmkdir configs/c.2\nmkdir functions/Loopback.0\nmkdir functions/SourceSink.0\n\nmkdir strings/0x409\nmkdir configs/c.1/strings/0x409\nmkdir configs/c.2/strings/0x409\n\necho "0x0525" > idVendor\necho "0xa4a0" > idProduct\n\necho "0123456789" > strings/0x409/serialnumber\necho "Samsung Inc." > strings/0x409/manufacturer\necho "Bar Gadget" > strings/0x409/product\n\necho "Conf 1" > configs/c.1/strings/0x409/configuration\necho "Conf 2" > configs/c.2/strings/0x409/configuration\necho 120 > configs/c.1/MaxPower\n\n// SourceSink\uff1a\u9a71\u52a8 set configuration \u4f1a\u9009\u53d6 \u7b2c\u4e00\u4e2a configuration\nln -s functions/Loopback.0 configs/c.2\nln -s functions/SourceSink.0 configs/c.1\n\necho 4100000.udc-controller > UDC\n'})}),"\n",(0,i.jsxs)(n.p,{children:["\u6574\u4e2a\u8fc7\u7a0b\u5c31\u662f\u521b\u5efa\u4e86\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Vendor ID = 0x0525"})," \u3001 ",(0,i.jsx)(n.code,{children:"Product ID = 0xa4a0"})," \u7684 ",(0,i.jsx)(n.code,{children:"Composite Device"})," \uff0c\u5728 Host \u4fa7\u53ef\u4ee5\u67e5\u770b\u8fd9\u4e2a\u8bbe\u5907\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ lsusb -s 1:3\nBus 001 Device 003: ID 0525:a4a0 Netchip Technology, Inc. Linux-USB "Gadget Zero"\n\n$ lsusb -v -s 1:3\n\nBus 001 Device 003: ID 0525:a4a0 Netchip Technology, Inc. Linux-USB "Gadget Zero"\nCouldn\'t open device, some information will be missing\nDevice Descriptor:\nbLength                18\nbDescriptorType         1\nbcdUSB               2.00\nbDeviceClass            0\nbDeviceSubClass         0\nbDeviceProtocol         0\nbMaxPacketSize0        64\nidVendor           0x0525 Netchip Technology, Inc.\nidProduct          0xa4a0 Linux-USB "Gadget Zero"\nbcdDevice            5.10\niManufacturer           1\niProduct                2\niSerial                 3\nbNumConfigurations      2\nConfiguration Descriptor:\n    bLength                 9\n    bDescriptorType         2\n    wTotalLength       0x0045\n    bNumInterfaces          1\n    bConfigurationValue     1\n    iConfiguration          4\n    bmAttributes         0x80\n    (Bus Powered)\n    MaxPower              120mA\n    Interface Descriptor:\n    bLength                 9\n    bDescriptorType         4\n    bInterfaceNumber        0\n    bAlternateSetting       0\n    bNumEndpoints           2\n    bInterfaceClass       255 Vendor Specific Class\n    bInterfaceSubClass      0\n    bInterfaceProtocol      0\n    iInterface              0\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x81  EP 1 IN\n        bmAttributes            2\n        Transfer Type            Bulk\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0200  1x 512 bytes\n        bInterval               0\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x01  EP 1 OUT\n        bmAttributes            2\n        Transfer Type            Bulk\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0200  1x 512 bytes\n        bInterval               0\n    Interface Descriptor:\n    bLength                 9\n    bDescriptorType         4\n    bInterfaceNumber        0\n    bAlternateSetting       1\n    bNumEndpoints           4\n    bInterfaceClass       255 Vendor Specific Class\n    bInterfaceSubClass      0\n    bInterfaceProtocol      0\n    iInterface              0\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x81  EP 1 IN\n        bmAttributes            2\n        Transfer Type            Bulk\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0200  1x 512 bytes\n        bInterval               0\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x01  EP 1 OUT\n        bmAttributes            2\n        Transfer Type            Bulk\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0200  1x 512 bytes\n        bInterval               0\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x82  EP 2 IN\n        bmAttributes            1\n        Transfer Type            Isochronous\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0400  1x 1024 bytes\n        bInterval               4\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x02  EP 2 OUT\n        bmAttributes            1\n        Transfer Type            Isochronous\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0400  1x 1024 bytes\n        bInterval               4\nConfiguration Descriptor:\n    bLength                 9\n    bDescriptorType         2\n    wTotalLength       0x0020\n    bNumInterfaces          1\n    bConfigurationValue     2\n    iConfiguration          5\n    bmAttributes         0x80\n    (Bus Powered)\n    MaxPower                2mA\n    Interface Descriptor:\n    bLength                 9\n    bDescriptorType         4\n    bInterfaceNumber        0\n    bAlternateSetting       0\n    bNumEndpoints           2\n    bInterfaceClass       255 Vendor Specific Class\n    bInterfaceSubClass      0\n    bInterfaceProtocol      0\n    iInterface              6\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x81  EP 1 IN\n        bmAttributes            2\n        Transfer Type            Bulk\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0200  1x 512 bytes\n        bInterval               0\n    Endpoint Descriptor:\n        bLength                 7\n        bDescriptorType         5\n        bEndpointAddress     0x01  EP 1 OUT\n        bmAttributes            2\n        Transfer Type            Bulk\n        Synch Type               None\n        Usage Type               Data\n        wMaxPacketSize     0x0200  1x 512 bytes\n        bInterval               0\n'})}),"\n",(0,i.jsx)(n.h4,{id:"322-sourcesink-function",children:"3.2.2. SourceSink Function"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"SourceSink Function"})," \u7684\u4e3b\u8981\u529f\u80fd\u662f\u63d0\u4f9b\u4e86\u4e00\u7ec4 USB \u6d4b\u8bd5 endpoint\uff0c\u5176\u4e2d:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Sink"}),"\u3002sinks bulk packets OUT to the peripheral\u3002\u610f\u601d\u662f\u628a\u6570\u636e\u4ece Host \u5f15\u6d41\u5230 Device\uff0c\u5373 ",(0,i.jsx)(n.code,{children:"OUT"})," \u65b9\u5411\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Source"}),"\u3002sources them IN to the host\u3002\u610f\u601d\u662f\u628a\u4ece Device \u53d1\u9001\u6570\u636e\u5230 Device\uff0c\u5373 ",(0,i.jsx)(n.code,{children:"IN"})," \u65b9\u5411\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\u5177\u4f53\u63d0\u4f9b\u4e86 4 \u7ec4 \u6d4b\u8bd5 endpoint\uff1a"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Endpoint"}),(0,i.jsx)(n.th,{children:"Type"}),(0,i.jsx)(n.th,{children:"Direction"}),(0,i.jsx)(n.th,{children:"Descript|"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"in_ep"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"IN"}),(0,i.jsx)(n.td,{children:"Source \u53d1\u9001\u6570\u636e\u5230 Host\uff0c \u6ce8\u610f\u8fd9\u6570\u636e\u662f Device \u4e3b\u52a8\u751f\u6210\u7684"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"out_ep"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"OUT"}),(0,i.jsx)(n.td,{children:"Sink \u63a5\u6536 Host \u7684\u6570\u636e"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"iso_in_ep"}),(0,i.jsx)(n.td,{children:"iso"}),(0,i.jsx)(n.td,{children:"IN"}),(0,i.jsx)(n.td,{children:"Source \u53d1\u9001\u6570\u636e\u5230 Host"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"iso_out_ep"}),(0,i.jsx)(n.td,{children:"iso"}),(0,i.jsx)(n.td,{children:"OUT"}),(0,i.jsx)(n.td,{children:"Sink \u63a5\u6536 Host \u7684\u6570\u636e"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"\u4e3b\u8981\u6d41\u7a0b\u5982\u4e0b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\function\\f_sourcesink.c:\n\nsourcesink_bind()\uff1a\n\nstatic int\nsourcesink_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\n    /* (1) \u4ece gadget \u4e2d\u5206\u914d 2 \u4e2a bulk endpoint */\n    /* allocate bulk endpoints */\n    ss->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_source_desc);\n\n    ss->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_sink_desc);\n\n    /* (2) \u5982\u679c\u652f\u6301ISO\uff0c\u518d\u4ece gadget \u4e2d\u5206\u914d 2 \u4e2a iso endpoint */\n    /* allocate iso endpoints */\n    ss->iso_in_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_source_desc);\n    if (!ss->iso_in_ep)\n        goto no_iso;\n\n    ss->iso_out_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_sink_desc);\n    if (!ss->iso_out_ep) {\n\n}\n\nsourcesink_set_alt() \u2192 enable_source_sink() \u2192 usb_ep_enable()/source_sink_start_ep()\uff1a\n// \u542f\u52a8\u4e0a\u8ff0 endpoint\n\n\u2192 source_sink_complete():\n// urb \u7684 complete() \u51fd\u6570\uff0curb \u53d1\u9001/\u63a5\u6536\u5b8c\u6210\u540e\uff0c\u91cd\u65b0\u6302\u8f7d urb\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u8fd8\u652f\u6301\u4e00\u4e9b\u53c2\u6570\u8c03\u6574\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# ls functions/SourceSink.0/\nbulk_buflen     iso_qlen        isoc_maxburst   isoc_mult\nbulk_qlen       isoc_interval   isoc_maxpacket  pattern\n"})}),"\n",(0,i.jsx)(n.h4,{id:"323-loopback-function",children:"3.2.3. Loopback Function"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Loopback Function"})," \u63d0\u4f9b\u7684\u529f\u80fd\u66f4\u4e3a\u7b80\u5355\uff0c\u5b83\u5206\u914d\u4e86\u4e24\u4e2a bulk endpoint\uff0c\u6240\u505a\u7684\u5c31\u662f\u628a ",(0,i.jsx)(n.code,{children:"out_ep"})," \u63a5\u6536\u5230\u7684\u6570\u636e \u8f6c\u53d1\u5230 ",(0,i.jsx)(n.code,{children:"in_ep"}),"\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"\u4e3b\u8981\u6d41\u7a0b\u5982\u4e0b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\function\\f_loopback.c:\n\nloopback_bind()\uff1a\n\nstatic int loopback_bind(struct usb_configuration *c, struct usb_function *f)\n{\n    /* (1) \u4ece gadget \u4e2d\u5206\u914d 2 \u4e2a bulk endpoint */\n    /* allocate endpoints */\n    loop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_source_desc);\n\n    loop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_sink_desc);\n}\n\nloopback_set_alt() \u2192 enable_loopback() \u2192 alloc_requests():\n\nstatic int alloc_requests(struct usb_composite_dev *cdev,\n            struct f_loopback *loop)\n{\n\n    for (i = 0; i < loop->qlen && result == 0; i++) {\n        result = -ENOMEM;\n\n        in_req = usb_ep_alloc_request(loop->in_ep, GFP_ATOMIC);\n        if (!in_req)\n            goto fail;\n\n        out_req = lb_alloc_ep_req(loop->out_ep, loop->buflen);\n        if (!out_req)\n            goto fail_in;\n\n        in_req->complete = loopback_complete;\n        out_req->complete = loopback_complete;\n\n        in_req->buf = out_req->buf;\n        /* length will be set in complete routine */\n        in_req->context = out_req;\n        out_req->context = in_req;\n\n        /* (2) \u5148\u542f\u52a8 OUT endpoint */\n        result = usb_ep_queue(loop->out_ep, out_req, GFP_ATOMIC);\n        if (result) {\n            ERROR(cdev, \"%s queue req --\x3e %d\\n\",\n                    loop->out_ep->name, result);\n            goto fail_out;\n        }\n    }\n\n}\n\nstatic void loopback_complete(struct usb_ep *ep, struct usb_request *req)\n{\n    struct f_loopback       *loop = ep->driver_data;\n    struct usb_composite_dev *cdev = loop->function.config->cdev;\n    int                     status = req->status;\n\n    switch (status) {\n    case 0:                         /* normal completion? */\n        if (ep == loop->out_ep) {\n            /*\n            * We received some data from the host so let's\n            * queue it so host can read the from our in ep\n            */\n            struct usb_request *in_req = req->context;\n\n            in_req->zero = (req->actual < req->length);\n            in_req->length = req->actual;\n            ep = loop->in_ep;\n            req = in_req;\n        } else {\n            /*\n            * We have just looped back a bunch of data\n            * to host. Now let's wait for some more data.\n            */\n            req = req->context;\n            ep = loop->out_ep;\n        }\n\n        /* (3) \u73af\u56de\u7684\u5173\u952e\uff1a\n                OUT endpoint \u63a5\u6536\u5230\u7684\u6570\u636e \u8f6c\u53d1\u5230 IN endpoint\n                IN endpoint \u6570\u636e\u53d1\u9001\u5b8c\u6210\u540e req \u91cd\u65b0\u6302\u8f7d\u5230 OUT endpoint\n        */\n        /* queue the buffer back to host or for next bunch of data */\n        status = usb_ep_queue(ep, req, GFP_ATOMIC);\n\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u4e5f\u652f\u6301\u4e00\u4e9b\u53c2\u6570\u8c03\u6574\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# ls functions/Loopback.0/\nbulk_buflen  qlen\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"33-host-\u4fa7-usbtestko",children:["3.3. Host \u4fa7 ",(0,i.jsx)(n.code,{children:"usbtest.ko"})]}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 Host \u4fa7\u7684 ",(0,i.jsx)(n.code,{children:"usbtest.ko"})," \u5b83\u5c31\u662f\u4e00\u4e2a\u6807\u51c6\u7684 ",(0,i.jsx)(n.code,{children:"usb interface driver"}),"\u3002\u5b83\u6839\u636e ",(0,i.jsx)(n.code,{children:"Vendor ID = 0x0525"})," \u3001 ",(0,i.jsx)(n.code,{children:"Product ID = 0xa4a0"})," \u9002\u914d\u4e0a\u4e00\u8282 ",(0,i.jsx)(n.code,{children:"Composite Device"})," \u4e2d\u7684 ",(0,i.jsx)(n.code,{children:"SourceSink Interface"})," \u6216\u8005 ",(0,i.jsx)(n.code,{children:"Loopback Interface"}),"\u3002"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static const struct usb_device_id id_table[] = {\n\n    /* "Gadget Zero" firmware runs under Linux */\n    { USB_DEVICE(0x0525, 0xa4a0),\n        .driver_info = (unsigned long) &gz_info,\n    },\n\n}\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver usbtest_driver = {\n    .name =         "usbtest",\n    .id_table =     id_table,\n    .probe =        usbtest_probe,\n    .unlocked_ioctl = usbtest_ioctl,\n    .disconnect =   usbtest_disconnect,\n    .suspend =      usbtest_suspend,\n    .resume =       usbtest_resume,\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"331-testcase",children:"3.3.1. TestCase"}),"\n",(0,i.jsxs)(n.p,{children:["\u5176\u5728 ",(0,i.jsx)(n.code,{children:"SourceSink Interface"})," \u63d0\u4f9b\u7684 4 \u4e2a\u6d4b\u8bd5 endpoint\u3001\u6216\u8005 ",(0,i.jsx)(n.code,{children:"Loopback Interface"})," \u63d0\u4f9b\u7684 2 \u4e2a\u6d4b\u8bd5 endpoint + ",(0,i.jsx)(n.code,{children:"Composite Device"})," \u672c\u8eab\u7684 ep0 control endpoint \u57fa\u7840\u4e4b\u4e0a\uff0c\u63d0\u4f9b\u4e86 30 \u4e2a testcase\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"drivers\\usb\\misc\\usbtest.c:\n\nusbtest_do_ioctl()\n"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"index"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"iterations"}),(0,i.jsx)(n.th,{children:"vary"}),(0,i.jsx)(n.th,{children:"sglen"}),(0,i.jsx)(n.th,{children:"unaligned"}),(0,i.jsx)(n.th,{children:"testcase"}),(0,i.jsx)(n.th,{children:"descript"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"0"}),(0,i.jsx)(n.td,{children:"nop"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 0: NOPn\u201d"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"1"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 1: write %d bytes %u timesn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{children:"Simple non-queued bulk I/O tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"2"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 2: read %d bytes %u timesn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"3"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 3: write/%d 0..%d bytes %u timesn\u201d, param->vary, param->length, param->iterations"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"4"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 4: read/%d 0..%d bytes %u timesn\u201d, param->vary, param->length, param->iterations"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"5"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 5: write %d sglists %d entries of %d bytesn\u201d, param->iterations,param->sglen, param->length"}),(0,i.jsx)(n.td,{children:"Queued bulk I/O tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"6"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 6: read %d sglists %d entries of %d bytesn\u201d, param->iterations,param->sglen, param->length"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"7"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 7: write/%d %d sglists %d entries 0..%d bytesn\u201d, param->vary, param->iterations,param->sglen, param->length"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"8"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 8: read/%d %d sglists %d entries 0..%d bytesn\u201d, param->vary, param->iterations,param->sglen, param->length"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"9"}),(0,i.jsx)(n.td,{children:"control"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 9: ch9 (subset) control tests, %d timesn\u201d, param->iterations"}),(0,i.jsx)(n.td,{children:"non-queued sanity tests for control (chapter 9 subset)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"10"}),(0,i.jsx)(n.td,{children:"control"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 10: queue %d control calls, %d timesn\u201d, param->sglen, param->iterations)"}),(0,i.jsx)(n.td,{children:"queued control messaging"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"11"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 11: unlink %d reads of %dn\u201d, param->iterations, param->length"}),(0,i.jsx)(n.td,{children:"simple non-queued unlinks (ring with one urb)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"12"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 12: unlink %d writes of %dn\u201d, param->iterations, param->length"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"13"}),(0,i.jsx)(n.td,{children:"control"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 13: set/clear %d haltsn\u201d param->iterations"}),(0,i.jsx)(n.td,{children:"ep halt tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"14"}),(0,i.jsx)(n.td,{children:"control"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 14: %d ep0out, %d..%d vary %dn\u201d, param->iterations,realworld ? 1 : 0, param->length,param->vary"}),(0,i.jsx)(n.td,{children:"control write tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"15"}),(0,i.jsx)(n.td,{children:"iso"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 15: write %d iso, %d entries of %d bytesn\u201d, param->iterations, param->sglen, param->length"}),(0,i.jsx)(n.td,{children:"iso write tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"16"}),(0,i.jsx)(n.td,{children:"iso"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 16: read %d iso, %d entries of %d bytesn\u201d, param->iterations, param->sglen, param->length"}),(0,i.jsx)(n.td,{children:"iso read tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"17"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 17: write odd addr %d bytes %u times core mapn\u201d param->length, param->iterations"}),(0,i.jsx)(n.td,{children:"Tests for bulk I/O using DMA mapping by core and odd address"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"18"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 18: read odd addr %d bytes %u times core mapn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"19"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 19: write odd addr %d bytes %u times premappedn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{children:"Tests for bulk I/O using premapped coherent buffer and odd address"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"20"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 20: read odd addr %d bytes %u times premappedn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"21"}),(0,i.jsx)(n.td,{children:"control"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 21: %d ep0out odd addr, %d..%d vary %dn\u201d, param->iterations,realworld ? 1 : 0, param->length, param->vary"}),(0,i.jsx)(n.td,{children:"control write tests with unaligned buffer"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"22"}),(0,i.jsx)(n.td,{children:"iso"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 22: write %d iso odd, %d entries of %d bytesn\u201d, param->iterations, param->sglen, param->length"}),(0,i.jsx)(n.td,{children:"unaligned iso tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"23"}),(0,i.jsx)(n.td,{children:"iso"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{children:"\u201cTEST 23: read %d iso odd, %d entries of %d bytesn\u201d, param->iterations, param->sglen, param->length"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"24"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 24: unlink from %d queues of %d %d-byte writesn\u201d, param->iterations, param->sglen, param->length"}),(0,i.jsx)(n.td,{children:"unlink URBs from a bulk-OUT queue"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"25"}),(0,i.jsx)(n.td,{children:"int"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 25: write %d bytes %u timesn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{children:"Simple non-queued interrupt I/O tests"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"26"}),(0,i.jsx)(n.td,{children:"int"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 26: read %d bytes %u timesn\u201d, param->length, param->iterations"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"27"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 27: bulk write %dMbytesn\u201d, (param->iterations * param->sglen * param->length) / (1024 * 1024))"}),(0,i.jsx)(n.td,{children:"Performance test"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"28"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 28: bulk read %dMbytesn\u201d, (param->iterations * param->sglen * param->length) / (1024 * 1024))"}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"29"}),(0,i.jsx)(n.td,{children:"bulk"}),(0,i.jsx)(n.td,{children:"Y"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"\u201cTEST 29: Clear toggle between bulk writes %d timesn\u201d, param->iterations"}),(0,i.jsx)(n.td,{children:"Test data Toggle/seq_nr clear between bulk out transfers"})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"332-ioctl",children:"3.3.2. Ioctl"}),"\n",(0,i.jsx)(n.p,{children:"usbtest.ko \u4ee5 ioctl \u7684\u5f62\u5f0f\u5411\u7528\u6237\u6001\u63d0\u4f9b\u5bf9 testcase \u7684\u8c03\u7528\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usbdev_file_operations \u2192 usbdev_ioctl() \u2192 usbdev_do_ioctl() \u2192 proc_ioctl_default() \u2192 proc_ioctl()\uff1a\n\nstatic int proc_ioctl(struct usb_dev_state *ps, struct usbdevfs_ioctl *ctl)\n{\n\n    /*  (1) \u627e\u5230\u5bf9\u5e94\u7684 usb interface device */\n    else if (!(intf = usb_ifnum_to_if(ps->dev, ctl->ifno)))\n        retval = -EINVAL;\n\n    /* talk directly to the interface's driver */\n    default:\n        if (intf->dev.driver)\n            /*  (2) \u627e\u5230 usb interface device \u5bf9\u5e94\u7684 driver  */\n            driver = to_usb_driver(intf->dev.driver);\n        if (driver == NULL || driver->unlocked_ioctl == NULL) {\n            retval = -ENOTTY;\n        } else {\n            /* (3) \u8c03\u7528 driver \u7684 ioctl \u51fd\u6570 */\n            retval = driver->unlocked_ioctl(intf, ctl->ioctl_code, buf);\n            if (retval == -ENOIOCTLCMD)\n                retval = -ENOTTY;\n        }\n\n}\n\n\u2193\n\nusbtest_ioctl() \u2192 usbtest_do_ioctl()\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"34-host-\u4fa7-testusb",children:["3.4. Host \u4fa7 ",(0,i.jsx)(n.code,{children:"testusb"})]}),"\n",(0,i.jsxs)(n.p,{children:["testusb \u6e90\u7801\u5305\u542b\u5728 linux \u5185\u6838\u5f53\u4e2d\uff0c \u8def\u5f84\u4e3a ",(0,i.jsx)(n.code,{children:"linux-5.10\\tools\\usb\\testusb.c"})," \u3002\u53ef\u4ee5\u901a\u8fc7 luban \u7f16\u8bd1\uff0c\u6216\u8005\u7b80\u5355\u7f16\u8bd1\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"gcc -Wall -g -lpthread -o testusb testusb.c\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u5c31\u53ef\u4ee5\u542f\u52a8\u6d4b\u8bd5\u4e86\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ sudo ./testusb -a\nunknown speed       /dev/bus/usb/001/002\n/dev/bus/usb/001/002 test 0,    0.000011 secs\n/dev/bus/usb/001/002 test 1,    1.625031 secs\n/dev/bus/usb/001/002 test 2 --\x3e 110 (Connection timed out)\n/dev/bus/usb/001/002 test 3,    1.639717 secs\n/dev/bus/usb/001/002 test 4 --\x3e 110 (Connection timed out)\n/dev/bus/usb/001/002 test 5,    1.915198 secs\n/dev/bus/usb/001/002 test 6 --\x3e 110 (Connection timed out)\n/dev/bus/usb/001/002 test 7,    1.928419 secs\n/dev/bus/usb/001/002 test 8 --\x3e 110 (Connection timed out)\n/dev/bus/usb/001/002 test 9,   13.835084 secs\n\nsudo ./testusb -a\n\nsudo ./testusb -a -t1 -c1 -s512 -g32 -v32\n\nsudo ./testusb -a -t29 -c1 -s512 -g32 -v32\n\n// test 10 \u9700\u8981\u7279\u522b\u6ce8\u610f\uff0c\u5bb9\u6613\u6302\u6b7b host\nsudo ./testusb -a -t10 -c1 -s512 -g5 -v32\n// test 28 \u9700\u8981\u7279\u522b\u6ce8\u610f\uff0c\u5bb9\u6613\u6302\u6b7b host\nsudo ./testusb -a -t28 -c1 -s512 -g32 -v32\n"})}),"\n",(0,i.jsx)(n.h2,{id:"4-\u8bbe\u8ba1\u8bf4\u660e",children:"4. \u8bbe\u8ba1\u8bf4\u660e"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_sw_stack-170676362740915.png",alt:"image0"})}),"\n",(0,i.jsx)(n.p,{children:"\u6574\u4e2a USB \u7cfb\u7edf\u7684\u8f6f\u4ef6\u6808\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u672c\u6587\u4ec5\u63cf\u8ff0\u5176\u4e2d\u7684 HCD (Host Controller Driver) \u548c DCD (Device Controller Driver)\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"41-usb-host-controller-driver",children:"4.1. USB Host Controller Driver"}),"\n",(0,i.jsx)(n.p,{children:"\u4e0b\u9762\u4ee5 EHCI \u4e3a\u4f8b\uff0c\u8bf4\u660e HCD \u8f6f\u4ef6\u8bbe\u8ba1\u601d\u60f3\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"411-\u6e90\u7801\u8bf4\u660e",children:"4.1.1. \u6e90\u7801\u8bf4\u660e"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u76f8\u5173\u6a21\u5757"}),(0,i.jsx)(n.th,{children:"\u6e90\u7801\u8def\u5f84"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"EHCI"}),(0,i.jsx)(n.td,{children:"source\\linux-5.10\\drivers\\usb\\host\\ehci-aic.c source\\linux-5.10\\drivers\\usb\\host\\ehci-hcd.c source\\linux-5.10\\drivers\\usb\\host\\ehci-mem.c source\\linux-5.10\\drivers\\usb\\host\\ehci-q.c source\\linux-5.10\\drivers\\usb\\host\\ehci-timer.c source\\linux-5.10\\drivers\\usb\\host\\ehci-hub.c"})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"412-\u6a21\u5757\u67b6\u6784",children:"4.1.2. \u6a21\u5757\u67b6\u6784"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hcd-170676364467717.png",alt:"image1"})}),"\n",(0,i.jsx)(n.p,{children:"\u4ece HCD (Host Controller Driver) \u7684\u6846\u67b6\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cHCD \u4e3b\u8981\u63d0\u4f9b\u4e86\u4e24\u5927\u529f\u80fd\uff1a"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u666e\u901a URB \u6570\u636e\u6536\u53d1\u529f\u80fd\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"\u5c06 USB Class Driver \u4e0b\u53d1\u7684 URB\uff0c\u6309\u7167\u786c\u4ef6\u63a7\u5236\u5668\u8981\u6c42\u7684\u683c\u5f0f\uff0c\u6309\u5206\u7c7b\u53d1\u9001\u5230\u786c\u4ef6 List \u5f53\u4e2d\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"RootHub URB \u7684\u5904\u7406\u529f\u80fd\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"\u5bf9\u4e8e RootHub Driver \u4e0b\u53d1\u7684 ep0 \u63a7\u5236\u547d\u4ee4 URB\uff0c\u7cfb\u7edf\u4e0d\u4f1a\u53d1\u9001\u5230\u786c\u4ef6\u63a7\u5236\u5668\u4e4b\u4e0a\uff0c\u800c\u662f\u8f6c\u53d1\u7ed9 HCD \u4f7f\u7528\u8f6f\u4ef6\u6765\u6a21\u62df\u6267\u884c\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u5bf9\u4e8e RootHub Driver \u4e0b\u53d1\u7684\u7aef\u53e3\u72b6\u6001\u67e5\u8be2 URB\uff0c\u901a\u8fc7\u54cd\u5e94\u4e2d\u65ad\u8fdb\u884c\u4e0a\u62a5\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"413-\u5173\u952e\u6d41\u7a0b",children:"4.1.3. \u5173\u952e\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.h5,{id:"4131-\u521d\u59cb\u5316\u6d41\u7a0b",children:"4.1.3.1. \u521d\u59cb\u5316\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.p,{children:"HCD \u9a71\u52a8\u7684\u5165\u53e3\u662f platform \u9a71\u52a8\uff0c\u521d\u59cb\u5316\u6d41\u7a0b\u5148\u83b7\u53d6 irq\u3001reg\u3001clk\u3001reset \u7b49\u8d44\u6e90\u5e76\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u6700\u540e\u8c03\u7528 usb_add_hcd() \u5411\u7cfb\u7edf\u4e2d\u6ce8\u518c\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u5927\u81f4\u7684\u6d41\u7a0b\u5982\u4e0b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"|--\x3eehci_platform_init()\n    |--\x3eehci_init_driver()\n    |--\x3eplatform_driver_register()\n        |--\x3eaic_ehci_platform_probe()\n            |--\x3ehcd = usb_create_hcd()\n            |--\x3eirq = platform_get_irq(dev, 0);\n            |--\x3epriv->clks[i] = of_clk_get(dev->dev.of_node, i);\n            |--\x3epriv->rst[i] = devm_reset_control_get_shared_by_index(&dev->dev, i);\n            |--\x3ehcd->regs = devm_ioremap_resource(&dev->dev, res_mem);\n            |--\x3eaic_ehci_platform_power_on()\n                |--\x3ereset_control_deassert(priv->rst[i]);\n                |--\x3eclk_prepare_enable(priv->clks[i]);\n            |--\x3eusb_add_hcd(hcd, irq, IRQF_SHARED);\n"})}),"\n",(0,i.jsx)(n.h5,{id:"4132-\u666e\u901a-urb-\u5904\u7406\u6d41\u7a0b",children:"4.1.3.2. \u666e\u901a URB \u5904\u7406\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_urb_flow-170676367501619.png",alt:"image2"})}),"\n",(0,i.jsx)(n.p,{children:"\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u4e00\u4e2a\u666e\u901a urb \u7684\u5904\u7406\u5206\u4e3a\u4e24\u6b65\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["urb enqueue\u3002\u9996\u5148\u8c03\u7528 hcd \u7684 ",(0,i.jsx)(n.code,{children:".urb_enqueue()"})," \u51fd\u6570\uff0c\u5c06\u9700\u8981\u4f20\u8f93\u7684\u6570\u636e\u63d2\u5165\u5230\u786c\u4ef6\u63a7\u5236\u5668\u7684\u94fe\u8868\u5f53\u4e2d\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["urb complete\u3002\u5728\u94fe\u8868\u4e2d\u7684\u4e00\u5e27\u6570\u636e\u4f20\u8f93\u5b8c\u6210\u540e\u786c\u4ef6\u4f1a\u4ea7\u751f ",(0,i.jsx)(n.code,{children:"complete"})," \u4e2d\u65ad\uff0c\u5728\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4e2d\u5bf9\u76f8\u5e94 urb \u53d1\u9001 ",(0,i.jsx)(n.code,{children:"complete"})," \u4fe1\u53f7\uff0c\u8ba9 ",(0,i.jsx)(n.code,{children:"usb_start_wait_urb()"})," \u7684\u6d41\u7a0b\u7ee7\u7eed\u6267\u884c\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"4133-roothub-urb-\u5904\u7406\u6d41\u7a0b",children:"4.1.3.3. Roothub URB \u5904\u7406\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_roothub_urb_flow-170676368257721.png",alt:"image3"})}),"\n",(0,i.jsx)(n.p,{children:"\u5982\u4e0a\u56fe\u6240\u793a\uff0croothub urb \u7684\u5904\u7406\u5206\u4e3a\u4e24\u79cd\u7c7b\u578b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["ep0 control urb\u3002\u5bf9\u4e8e roothub control urb\uff0cHCD \u9700\u8981\u4f7f\u7528\u8f6f\u4ef6\u6765\u6a21\u62df\uff0c\u5b9e\u9645\u4e0a urb \u6ca1\u6709\u53d1\u9001\u5230\u786c\u4ef6\u63a7\u5236\u5668\u4e2d\uff0c\u56e0\u4e3a\u662f\u8f6f\u4ef6\u6a21\u62df\u6240\u4ee5\u65e0\u9700\u7b49\u5f85 ",(0,i.jsx)(n.code,{children:"complete"})," \u53ef\u4ee5\u7acb\u5373\u91ca\u653e\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["\u83b7\u53d6\u7aef\u53e3\u72b6\u6001 urb\u3002\u8fd9\u7c7b urb \u4f1a\u963b\u585e\u7b49\u5f85\u7aef\u53e3\u72b6\u6001\u6539\u53d8\uff0c\u4e00\u65e6\u7aef\u53e3\u72b6\u6001\u6539\u53d8\u4f1a\u89e6\u53d1\u786c\u4ef6\u4e2d\u65ad\uff0c\u5728\u4e2d\u65ad\u5904\u7406\u4e2d\u5524\u9192\u5bf9\u5e94 urb \u7684 ",(0,i.jsx)(n.code,{children:"complete"})," \u4fe1\u53f7\uff0c\u8ba9 ",(0,i.jsx)(n.code,{children:"usb_start_wait_urb()"})," \u7684\u6d41\u7a0b\u7ee7\u7eed\u6267\u884c\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"414-\u6570\u636e\u7ed3\u6784",children:"4.1.4. \u6570\u636e\u7ed3\u6784"}),"\n",(0,i.jsx)(n.h5,{id:"4141-ehci_hc_driver",children:"4.1.4.1. ehci_hc_driver"}),"\n",(0,i.jsx)(n.p,{children:"HCD \u6838\u5fc3\u7684\u6570\u636e\u7ed3\u6784\u4e3a hc_driver\uff0cEHCI \u5b9e\u73b0\u4e86\u4ee5\u4e0b\u7684\u6838\u5fc3\u51fd\u6570\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static const struct hc_driver ehci_hc_driver = {\n    .description =          hcd_name,\n    .product_desc =         "EHCI Host Controller",\n    .hcd_priv_size =        sizeof(struct ehci_hcd),\n\n    /*\n    * generic hardware linkage\n    */\n    .irq =                  ehci_irq,\n    .flags =                HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,\n\n    /*\n    * basic lifecycle operations\n    */\n    .reset =                ehci_setup,\n    .start =                ehci_run,\n    .stop =                 ehci_stop,\n    .shutdown =             ehci_shutdown,\n\n    /*\n    * managing i/o requests and associated device resources\n    */\n    .urb_enqueue =          ehci_urb_enqueue,\n    .urb_dequeue =          ehci_urb_dequeue,\n    .endpoint_disable =     ehci_endpoint_disable,\n    .endpoint_reset =       ehci_endpoint_reset,\n    .clear_tt_buffer_complete =     ehci_clear_tt_buffer_complete,\n\n    /*\n    * scheduling support\n    */\n    .get_frame_number =     ehci_get_frame,\n\n    /*\n    * root hub support\n    */\n    .hub_status_data =      ehci_hub_status_data,\n    .hub_control =          ehci_hub_control,\n    .bus_suspend =          ehci_bus_suspend,\n    .bus_resume =           ehci_bus_resume,\n    .relinquish_port =      ehci_relinquish_port,\n    .port_handed_over =     ehci_port_handed_over,\n    .get_resuming_ports =   ehci_get_resuming_ports,\n\n    /*\n    * device support\n    */\n    .free_dev =             ehci_remove_device,\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"415-\u63a5\u53e3\u8bbe\u8ba1",children:"4.1.5. \u63a5\u53e3\u8bbe\u8ba1"}),"\n",(0,i.jsx)(n.h5,{id:"4151-ehci_urb_enqueue",children:"4.1.5.1. ehci_urb_enqueue"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u51fd\u6570\u539f\u578b"}),(0,i.jsx)(n.th,{children:"int ehci_urb_enqueue (struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u529f\u80fd\u8bf4\u660e"}),(0,i.jsx)(n.td,{children:"\u63a5\u6536\u4e0a\u5c42\u4f20\u5165\u7684 urb\uff0c\u5e76\u5c06\u5176\u538b\u5165 EHCI \u7684\u786c\u4ef6\u961f\u5217\u3002"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u53c2\u6570\u5b9a\u4e49"}),(0,i.jsx)(n.td,{children:"hcd\uff1a\u5f53\u524d hcd \u63a7\u5236\u7ed3\u6784 urb\uff1a\u5f53\u524d urb \u63a7\u5236\u7ed3\u6784 mem_flags\uff1a\u5206\u914d\u5185\u5b58\u65f6\u4f7f\u7528\u7684\u6807\u5fd7"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u8fd4\u56de\u503c"}),(0,i.jsx)(n.td,{children:"0\uff0c\u6210\u529f\uff1b < 0\uff0c\u5931\u8d25"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u6ce8\u610f\u4e8b\u9879"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h5,{id:"4152-ehci_hub_control",children:"4.1.5.2. ehci_hub_control"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u51fd\u6570\u539f\u578b"}),(0,i.jsx)(n.th,{children:"int ehci_hub_control (struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex, char *buf, u16 wLength)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u529f\u80fd\u8bf4\u660e"}),(0,i.jsx)(n.td,{children:"\u5904\u7406 roothub \u76f8\u5173\u7684 control \u547d\u4ee4\u3002"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u53c2\u6570\u5b9a\u4e49"}),(0,i.jsx)(n.td,{children:"hcd\uff1a\u5f53\u524d hcd \u63a7\u5236\u7ed3\u6784 typeReq\uff1asetup token \u4e2d\u7684\u5bf9\u5e94\u5b57\u6bb5 wValue\uff1asetup token \u4e2d\u7684\u5bf9\u5e94\u5b57\u6bb5 wIndex\uff1asetup token \u4e2d\u7684\u5bf9\u5e94\u5b57\u6bb5 buf\uff1asetup data \u9700\u8981\u7684\u6570\u636e wLength\uff1asetup token \u4e2d\u7684\u5bf9\u5e94\u5b57\u6bb5"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u8fd4\u56de\u503c"}),(0,i.jsx)(n.td,{children:"0\uff0c\u6210\u529f\uff1b < 0\uff0c\u5931\u8d25"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u6ce8\u610f\u4e8b\u9879"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h5,{id:"4153-ehci_hub_status_data",children:"4.1.5.3. ehci_hub_status_data"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u51fd\u6570\u539f\u578b"}),(0,i.jsx)(n.th,{children:"int ehci_hub_status_data (struct usb_hcd *hcd, char *buf)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u529f\u80fd\u8bf4\u660e"}),(0,i.jsx)(n.td,{children:"\u67e5\u8be2 hub \u7aef\u53e3\u72b6\u6001\u3002"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u53c2\u6570\u5b9a\u4e49"}),(0,i.jsx)(n.td,{children:"hcd\uff1a\u5f53\u524d hcd \u63a7\u5236\u7ed3\u6784 buf\uff1a\u8fd4\u56de\u83b7\u53d6\u7684 hub \u7aef\u53e3\u72b6\u6001"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u8fd4\u56de\u503c"}),(0,i.jsx)(n.td,{children:">0\uff0c\u6210\u529f\u83b7\u53d6\u7aef\u53e3\u72b6\u6001\u7684\u957f\u5ea6\uff1b = 0\uff0c\u5931\u8d25"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u6ce8\u610f\u4e8b\u9879"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"42-usb-device-controller-driver",children:"4.2. USB Device Controller Driver"}),"\n",(0,i.jsx)(n.p,{children:"Linux \u5229\u7528 Device Controller Driver \u628a\u6574\u4e2a\u5355\u677f\u6a21\u62df\u6210\u4e00\u4e2a USB Device \u8bbe\u5907\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"421-\u6e90\u7801\u8bf4\u660e",children:"4.2.1. \u6e90\u7801\u8bf4\u660e"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u76f8\u5173\u6a21\u5757"}),(0,i.jsx)(n.th,{children:"\u6e90\u7801\u8def\u5f84"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"AIC UDC"}),(0,i.jsx)(n.td,{children:"source\\linux-5.10\\drivers\\usb\\gadget\\udc\\aic_udc.c source\\linux-5.10\\drivers\\usb\\gadget\\udc\\aic_udc.h"})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"422-\u6a21\u5757\u67b6\u6784",children:"4.2.2. \u6a21\u5757\u67b6\u6784"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd-170676372182523.png",alt:"image4"})}),"\n",(0,i.jsx)(n.p,{children:"\u4ece\u4e0a\u8ff0 DCD (Device Controller Driver) \u7684\u6846\u67b6\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cDCD \u4e3b\u8981\u63d0\u4f9b\u4e86\u4e24\u5927\u529f\u80fd\uff1a"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"\u666e\u901a ep \u7684 usb request \u5904\u7406\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"DCD \u63d0\u4f9b\u4e86\u4e00\u4e2a endpoint \u8d44\u6e90\u6c60\uff0cGadget Function Driver \u53ef\u4ee5\u5728\u8fd9\u4e2a\u8d44\u6e90\u6c60\u4e2d\u5206\u914d\u9700\u8981\u7684 endpoint\uff0c\u8fd9\u90e8\u5206\u7684 endpoint \u5c31\u79f0\u4e3a \u666e\u901a ep\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"ep0 \u7684 usb request \u5904\u7406\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"\u56e0\u4e3a DCD \u5bf9\u5916\u5448\u73b0\u4e3a\u4e00\u4e2a USB Device\uff0cUSB Device \u7684 ep0 \u662f\u7ba1\u7406\u901a\u9053\u662f\u9700\u8981\u7279\u6b8a\u5904\u7406\u7684\u3002\u5bf9 ep0 \u4f20\u8fbe\u8fc7\u6765\u7684 control \u6570\u636e\u9700\u8981\u5728 DCD \u5c42\u5f00\u59cb\u89e3\u6790\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"423-\u5173\u952e\u6d41\u7a0b",children:"4.2.3. \u5173\u952e\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.h5,{id:"4231-\u521d\u59cb\u5316\u6d41\u7a0b",children:"4.2.3.1. \u521d\u59cb\u5316\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.p,{children:"DCD \u9a71\u52a8\u7684\u5165\u53e3\u662f platform \u9a71\u52a8\uff0c\u521d\u59cb\u5316\u6d41\u7a0b\u5148\u83b7\u53d6 irq\u3001reg\u3001clk\u3001reset \u7b49\u8d44\u6e90\u5e76\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u6700\u540e\u8c03\u7528 usb_add_gadget_udc() \u5411\u7cfb\u7edf\u4e2d\u6ce8\u518c\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u5927\u81f4\u7684\u6d41\u7a0b\u5982\u4e0b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'|--\x3eaic_udc_probe()\n    |--\x3egg->regs = devm_ioremap_resource(&dev->dev, res);\n    |--\x3egg->reset = devm_reset_control_get_optional(gg->dev, "aicudc");\n    |--\x3egg->reset_ecc = devm_reset_control_get_optional_shared(gg->dev,"aicudc-ecc");\n    |--\x3egg->clks[i] = of_clk_get(gg->dev->of_node, i);\n    |--\x3eaic_gadget_init(gg);\n        |--\x3eaic_low_hw_enable()\n            |--\x3eclk_prepare_enable(gg->clks[i]);\n            |--\x3ereset_control_deassert(gg->reset);\n            |--\x3ereset_control_deassert(gg->reset_ecc);\n    |--\x3eres = platform_get_resource(dev, IORESOURCE_IRQ, 0);\n    |--\x3egg->irq = res->start;\n    |--\x3eusb_add_gadget_udc(gg->dev, &gg->gadget);\n'})}),"\n",(0,i.jsx)(n.h5,{id:"4232-ep-\u5206\u914d\u6d41\u7a0b",children:"4.2.3.2. ep \u5206\u914d\u6d41\u7a0b"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd_ep_pool-170676374509225.png",alt:"image5"})}),"\n",(0,i.jsx)(n.p,{children:"\u5982\u4e0a\u56fe\u6240\u793a\uff0cep \u8d44\u6e90\u7684\u64cd\u4f5c\u5206\u4e3a\u4e24\u90e8\u5206\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ep \u8d44\u6e90\u6c60\u521d\u59cb\u5316\u3002\u5728 udc \u9a71\u52a8\u521d\u59cb\u5316\u7684\u65f6\u5019\u540c\u65f6\u521d\u59cb\u5316\u4e86 ep \u8d44\u6e90\u6c60\uff0c\u8fd9\u6837\u5c31\u51b3\u5b9a\u4e86\u5f53\u524d\u6709\u591a\u5c11\u4e2a ep \u8d44\u6e90\u53ef\u7528\u3002"}),"\n",(0,i.jsx)(n.li,{children:"ep \u8d44\u6e90\u7684\u5206\u914d\u3002gadget composite device \u53ef\u4ee5\u914d\u7f6e\u591a\u4e2a interface \u5373 gadget function driver\uff0c\u5f53 function driver \u542f\u7528\u65f6\uff0c\u4f1a\u4ece\u8d44\u6e90\u6c60\u4e2d\u5206\u914d\u9700\u8981\u7684 ep\u3002\u5982\u679c\u914d\u7f6e\u7684 function driver \u8fc7\u591a\uff0c\u5c31\u53ef\u80fd\u4f1a\u5206\u914d\u5931\u8d25\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"4233-\u666e\u901a-ep-\u7684-request-\u5904\u7406",children:"4.2.3.3. \u666e\u901a ep \u7684 request \u5904\u7406"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd_ep_queue-170676375463427.png",alt:"image6"})}),"\n",(0,i.jsx)(n.p,{children:"\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u5bf9\u4e8e\u666e\u901a ep \u7684 reuqest \u6570\u636e\u6536\u53d1\u5206\u4e3a\u4e24\u6b65\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["request enqueue\u3002\u9996\u5148\u8c03\u7528 udc \u7684 ",(0,i.jsx)(n.code,{children:".queue()"})," \u51fd\u6570\uff0c\u5c06\u9700\u8981\u4f20\u8f93\u7684\u6570\u636e\u63d2\u5165\u5230\u786c\u4ef6\u63a7\u5236\u5668\u5bf9\u5e94\u7684 ep \u5bc4\u5b58\u5668\u5f53\u4e2d\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["complete callback\u3002ep \u6570\u636e\u6536\u53d1\u5b8c\u6210\u4f1a\u4ea7\u751f ",(0,i.jsx)(n.code,{children:"transfer complete"})," \u4e2d\u65ad\uff0c\u5728\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4e2d\u8c03\u7528 ",(0,i.jsx)(n.code,{children:"complete"})," \u56de\u8c03\u51fd\u6570\uff0c\u7ed3\u675f\u6574\u4e2a request \u4f20\u8f93\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"4234-ep0-\u7684-request-\u5904\u7406",children:"4.2.3.4. ep0 \u7684 request \u5904\u7406"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_dcd_ep0_queue-170676376089229.png",alt:"image7"})}),"\n",(0,i.jsx)(n.p,{children:"\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u5bf9\u4e8e ep0 \u7684 reuqest \u6570\u636e\u6536\u53d1\u548c \u666e\u901a ep \u57fa\u672c\u4e00\u6837\uff0c\u53ea\u662f\u5bf9\u6570\u636e\u7684\u56de\u8c03\u5904\u7406\u7a0d\u6709\u4e0d\u540c\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"424-\u6570\u636e\u7ed3\u6784",children:"4.2.4. \u6570\u636e\u7ed3\u6784"}),"\n",(0,i.jsx)(n.h5,{id:"4241-aic_usb_ep_ops",children:"4.2.4.1. aic_usb_ep_ops"}),"\n",(0,i.jsx)(n.p,{children:"AIC UDC \u9a71\u52a8\u6838\u5fc3\u7684\u6570\u636e\u7ed3\u6784\u4e3a usb_ep_ops\uff0c \u5b9e\u73b0\u4e86 op \u64cd\u4f5c\u7684\u76f8\u5173\u51fd\u6570\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static const struct usb_ep_ops aic_usb_ep_ops = {\n    .enable                 = aic_ep_enable,\n    .disable                = aic_ep_disable,\n    .alloc_request          = aic_ep_alloc_request,\n    .free_request           = aic_ep_free_request,\n    .queue                  = aic_ep_queue_request,\n    .dequeue                = aic_ep_dequeue_request,\n    .set_halt               = aic_ep_sethalt,\n};\n"})}),"\n",(0,i.jsx)(n.h4,{id:"425-\u63a5\u53e3\u8bbe\u8ba1",children:"4.2.5. \u63a5\u53e3\u8bbe\u8ba1"}),"\n",(0,i.jsx)(n.h5,{id:"4251-aic_ep_queue_request",children:"4.2.5.1. aic_ep_queue_request"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u51fd\u6570\u539f\u578b"}),(0,i.jsx)(n.th,{children:"int aic_ep_queue_request(struct usb_ep *ep, struct usb_request *req, gfp_t gfp_flags)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u529f\u80fd\u8bf4\u660e"}),(0,i.jsx)(n.td,{children:"\u63a5\u6536\u4e0a\u5c42\u4f20\u5165\u7684 request\uff0c\u5e76\u5c06\u5176\u914d\u7f6e\u5230 ep \u5bc4\u5b58\u5668\u4e2d\u3002"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u53c2\u6570\u5b9a\u4e49"}),(0,i.jsx)(n.td,{children:"ep\uff1a\u5f53\u524d ep \u63a7\u5236\u7ed3\u6784 req\uff1a\u5f53\u524d request \u63a7\u5236\u7ed3\u6784 gfp_flags\uff1a\u5206\u914d\u5185\u5b58\u65f6\u4f7f\u7528\u7684\u6807\u5fd7"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u8fd4\u56de\u503c"}),(0,i.jsx)(n.td,{children:"0\uff0c\u6210\u529f\uff1b < 0\uff0c\u5931\u8d25"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u6ce8\u610f\u4e8b\u9879"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h5,{id:"4252-aic_ep0_process_control",children:"4.2.5.2. aic_ep0_process_control"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"\u51fd\u6570\u539f\u578b"}),(0,i.jsx)(n.th,{children:"void aic_ep0_process_control(struct aic_usb_gadget *gg, struct usb_ctrlrequest *ctrl)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u529f\u80fd\u8bf4\u660e"}),(0,i.jsx)(n.td,{children:"\u5904\u7406 ep0 \u63a5\u6536\u5230\u7684 control \u6570\u636e\u5305\u3002"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u53c2\u6570\u5b9a\u4e49"}),(0,i.jsx)(n.td,{children:"gg\uff1a\u5f53\u524d gadget \u63a7\u5236\u7ed3\u6784 ctrl\uff1a\u5f53\u524d control \u6570\u636e\u5305"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u8fd4\u56de\u503c"}),(0,i.jsx)(n.td,{children:"0\uff0c\u6210\u529f\uff1b < 0\uff0c\u5931\u8d25"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"\u6ce8\u610f\u4e8b\u9879"}),(0,i.jsx)(n.td,{})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"5-usb-host-\u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784",children:"5. USB Host \u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_flow_detail_host-170676415011331.png",alt:"image0"})}),"\n",(0,i.jsx)(n.p,{children:"\u6574\u4e2a USB \u7cfb\u7edf\u7684\u901a\u8baf\u6a21\u578b\u5982\u4e0a\u56fe\u6240\u793a\uff0cHost \u6846\u67b6\u89c1\u5de6\u4fa7\u5f69\u56fe\u90e8\u5206\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"51-usb-core",children:"5.1. USB Core"}),"\n",(0,i.jsx)(n.h4,{id:"511-layer",children:"5.1.1. Layer"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_host_drv_dev-170676416810133.png",alt:"image1"})}),"\n",(0,i.jsxs)(n.p,{children:["\u7531\u524d\u51e0\u8282\u53ef\u77e5USB\u5c06 ",(0,i.jsx)(n.code,{children:"Device"})," \u8fdb\u4e00\u6b65\u7ec6\u5206\u6210\u4e863\u4e2a\u5c42\u7ea7\uff1a ",(0,i.jsx)(n.code,{children:"Configuration"})," \u914d\u7f6e\u3001 ",(0,i.jsx)(n.code,{children:"Interface"})," \u63a5\u53e3\u3001 ",(0,i.jsx)(n.code,{children:"Endpoint"})," \u7aef\u70b9\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:["USB Core \u4e3a\u5176\u4e2d\u4e24\u4e2a\u5c42\u6b21\u63d0\u4f9b\u4e86 ",(0,i.jsx)(n.code,{children:"Device + Driver"})," \u7684\u8bbe\u5907\u9a71\u52a8\u6a21\u578b\uff0c\u8fd9\u4e24\u4e2a\u5c42\u6b21\u5206\u522b\u662f ",(0,i.jsx)(n.code,{children:"USB Device Layer"})," \u548c ",(0,i.jsx)(n.code,{children:"USB Interface Layer"})," \u5c42\uff0c\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"USB Device"})," \u5305\u542b\u4e00\u4e2a\u6216\u591a\u4e2a ",(0,i.jsx)(n.code,{children:"USB Interface"}),"\u3002\u5176\u4e2d\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"USB Device Layer"})," \u5c42\u3002\u8fd9\u4e00\u5c42\u7684 ",(0,i.jsx)(n.code,{children:"Device"})," \u7531 ",(0,i.jsx)(n.code,{children:"Hub"})," \u521b\u5efa\uff0c ",(0,i.jsx)(n.code,{children:"Hub"})," \u672c\u8eab\u4e5f\u662f\u4e00\u79cd ",(0,i.jsx)(n.code,{children:"USB Device"})," \uff1b\u8fd9\u4e00\u5c42\u7684 ",(0,i.jsx)(n.code,{children:"Driver"})," \u5b8c\u6210\u7684\u529f\u80fd\u975e\u5e38\u7b80\u5355\uff0c\u57fa\u672c\u5c31\u662f\u5e2e ",(0,i.jsx)(n.code,{children:"USB Device"})," \u521b\u5efa\u5176\u5305\u542b\u7684\u6240\u6709\u5b50 ",(0,i.jsx)(n.code,{children:"USB Interface"})," \u7684 ",(0,i.jsx)(n.code,{children:"Device"})," \uff0c\u5927\u90e8\u5206\u573a\u666f\u4e0b\u90fd\u662f\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"usb_generic_driver"}),"\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"USB Interface Layer"})," \u5c42\u3002\u8fd9\u4e00\u5c42\u7684 ",(0,i.jsx)(n.code,{children:"Device"})," \u7531\u4e0a\u4e00\u7ea7 ",(0,i.jsx)(n.code,{children:"USB Device"})," \u5728\u9a71\u52a8 probe() \u65f6\u521b\u5efa\uff1b\u800c\u8fd9\u4e00\u5c42\u7684 ",(0,i.jsx)(n.code,{children:"Driver"})," \u5c31\u662f\u666e\u901a\u7684\u4e1a\u52a1 Usb \u9a71\u52a8\uff0c\u5373 Usb \u534f\u8bae\u4e2d\u6240\u8bf4\u7684 ",(0,i.jsx)(n.code,{children:"Client Software"}),"\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"512-urb-usb-request-block",children:"5.1.2. URB (USB Request Block)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_host_urb-170676417587035.png",alt:"image2"})}),"\n",(0,i.jsxs)(n.p,{children:["USB Core \u9664\u4e86\u63d0\u4f9b\u4e0a\u4e00\u8282\u63cf\u8ff0\u7684\u8bbe\u5907\u9a71\u52a8\u6a21\u578b\u4ee5\u5916\uff0c\u53e6\u4e00\u4e2a\u91cd\u8981\u7684\u4f5c\u7528\u5c31\u662f\u8981\u7ed9 ",(0,i.jsx)(n.code,{children:"USB Interface"})," Driver \u63d0\u4f9b\u8bfb\u5199 USB \u6570\u636e\u7684 API\uff0c\u8fd9\u4e00\u4efb\u52a1\u662f\u56f4\u7ed5\u7740 ",(0,i.jsx)(n.code,{children:"USB Request Block"})," \u6765\u5b8c\u6210\u7684\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"USB Interface"})," Driver \u9002\u914d\u6210\u529f\u4ee5\u540e\uff0c\u4f1a\u4ece\u914d\u7f6e\u4fe1\u606f\u4e2d\u83b7\u53d6\u5230\u5f53\u524d Interface \u5305\u542b\u4e86\u591a\u5c11\u4e2a ",(0,i.jsx)(n.code,{children:"Endpoint"})," \uff0c\u4ee5\u53ca\u6bcf\u4e2a ",(0,i.jsx)(n.code,{children:"Endpoint"})," \u7684\u5730\u5740\u3001\u4f20\u8f93\u7c7b\u578b\u3001\u6700\u5927\u5305\u957f\u7b49\u5176\u4ed6\u4fe1\u606f\u3002 ",(0,i.jsx)(n.code,{children:"Endpoint"})," \u662f USB \u603b\u7ebf\u4f20\u8f93\u4e2d\u6700\u5c0f\u7684 ",(0,i.jsx)(n.code,{children:"\u5bfb\u5740\u5355\u4f4d"})," \uff0cInterface Driver \u5229\u7528\u5bf9\u51e0\u4e2a ",(0,i.jsx)(n.code,{children:"Endpoint"})," \u7684\u8bfb\u5199\u6765\u9a71\u52a8\u5177\u4f53\u7684\u8bbe\u5907\u529f\u80fd\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:["\u5bf9\u67d0\u4e2a ",(0,i.jsx)(n.code,{children:"Endpoint"})," \u53d1\u8d77\u4e00\u6b21\u8bfb\u5199\u64cd\u4f5c\uff0c\u5177\u4f53\u5de5\u4f5c\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"struct urb"})," \u6570\u636e\u7ed3\u6784\u6765\u627f\u62c5\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:["\u4ee5\u4e0b\u662f\u4e00\u4e2a\u5bf9 ",(0,i.jsx)(n.code,{children:"Endpoint 0"})," \u4f7f\u7528 urb \u53d1\u8d77\u8bfb\u5199\u7684\u4e00\u4e2a\u7b80\u5355\u5b9e\u4f8b\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static int usb_internal_control_msg(struct usb_device *usb_dev,\n                    unsigned int pipe,\n                    struct usb_ctrlrequest *cmd,\n                    void *data, int len, int timeout)\n{\n    struct urb *urb;\n    int retv;\n    int length;\n\n    /* (1) \u5206\u914d\u4e00\u4e2a urb \u5185\u5b58\u7a7a\u95f4 */\n    urb = usb_alloc_urb(0, GFP_NOIO);\n    if (!urb)\n        return -ENOMEM;\n\n    /* (2) \u586b\u5145 urb \u5185\u5bb9\uff0c\u6700\u6838\u5fc3\u7684\u67093\u65b9\u9762\uff1a\n            1\u3001\u603b\u7ebf\u5730\u5740\uff1aDevice Num + Endpoint Num\n            2\u3001\u6570\u636e\uff1adata + len\n            3\u3001\u56de\u8c03\u51fd\u6570\uff1ausb_api_blocking_completion\n    */\n    usb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,\n                len, usb_api_blocking_completion, NULL);\n\n    /* (3) \u53d1\u9001 urb \u8bf7\u6c42\uff0c\u5e76\u4e14\u7b49\u5f85\u8bf7\u6c42\u5b8c\u6210 */\n    retv = usb_start_wait_urb(urb, timeout, &length);\n    if (retv < 0)\n        return retv;\n    else\n        return length;\n}\n\n\u2193\n\nstatic int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)\n{\n    struct api_context ctx;\n    unsigned long expire;\n    int retval;\n\n    init_completion(&ctx.done);\n    urb->context = &ctx;\n    urb->actual_length = 0;\n    /* (3.1) \u628a urb \u8bf7\u6c42\u6302\u8f7d\u5230 hcd \u7684\u961f\u5217\u5f53\u4e2d */\n    retval = usb_submit_urb(urb, GFP_NOIO);\n    if (unlikely(retval))\n        goto out;\n\n    expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;\n    /* (3.2) \u5f53 urb \u6267\u884c\u5b8c\u6210\u540e\uff0c\u9996\u5148\u4f1a\u8c03\u7528 urb \u7684\u56de\u8c03\u51fd\u6570\uff0c\u7136\u540e\u4f1a\u53d1\u9001 completion \u4fe1\u53f7\u89e3\u9664\u8fd9\u91cc\u7684\u963b\u585e */\n    if (!wait_for_completion_timeout(&ctx.done, expire)) {\n        usb_kill_urb(urb);\n        retval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);\n\n        dev_dbg(&urb->dev->dev,\n            "%s timed out on ep%d%s len=%u/%u\\n",\n            current->comm,\n            usb_endpoint_num(&urb->ep->desc),\n            usb_urb_dir_in(urb) ? "in" : "out",\n            urb->actual_length,\n            urb->transfer_buffer_length);\n    } else\n        retval = ctx.status;\nout:\n    if (actual_length)\n        *actual_length = urb->actual_length;\n\n    usb_free_urb(urb);\n    return retval;\n}\n'})}),"\n",(0,i.jsx)(n.h5,{id:"5121-normal-device-urb_enqueue",children:"5.1.2.1. Normal Device urb_enqueue"}),"\n",(0,i.jsx)(n.p,{children:"\u5bf9\u666e\u901a\u7684 Usb device \u6765\u8bf4\uff0curb \u6700\u540e\u4f1a\u63d0\u4ea4\u5230 Host Controller \u7684\u6536\u53d1\u961f\u5217\u4e0a\u9762\uff0c\u7531 HC \u5b8c\u6210\u5b9e\u9645\u7684 USB \u4f20\u8f93\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_submit_urb() \u2192 usb_hcd_submit_urb():\n\nint usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)\n{\n\n    /* (1) \u5982\u679c\u662f roothub \u8d70\u7279\u6b8a\u7684\u8def\u5f84 */\n    if (is_root_hub(urb->dev)) {\n        status = rh_urb_enqueue(hcd, urb);\n    /* (2) \u5982\u679c\u662f\u666e\u901a device \u8c03\u7528\u5bf9\u5e94\u7684 hcd \u7684 urb_enqueue() \u51fd\u6570 */\n    } else {\n        status = map_urb_for_dma(hcd, urb, mem_flags);\n        if (likely(status == 0)) {\n            status = hcd->driver->urb_enqueue(hcd, urb, mem_flags);\n            if (unlikely(status))\n                unmap_urb_for_dma(hcd, urb);\n        }\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"5122-roothub-device-urb_enqueue",children:"5.1.2.2. Roothub Device urb_enqueue"}),"\n",(0,i.jsx)(n.p,{children:"\u7279\u522b\u9700\u8981\u6ce8\u610f\u7684\u662f roothub \u5b83\u662f\u4e00\u4e2a\u865a\u62df\u7684 usb device\uff0c\u5b9e\u9645\u4e0a\u5b83\u5e76\u4e0d\u5728usb\u603b\u7ebf\u4e0a\u800c\u662f\u5728 host \u5185\u90e8\uff0c\u6240\u4ee5\u76f8\u5e94\u7684 urb \u9700\u8981\u7279\u6b8a\u5904\u7406\uff0c\u800c\u4e0d\u80fd\u4f7f\u7528 hcd \u628a\u6570\u636e\u53d1\u9001\u5230 Usb \u603b\u7ebf\u4e0a\u53bb\u3002"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_submit_urb() \u2192 usb_hcd_submit_urb() \u2192 rh_urb_enqueue():\n\nstatic int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)\n{\n    /* (1) \u5bf9\u4e8e int \u7c7b\u578b\u7684\u6570\u636e\uff0c\u88ab\u6302\u8f7d\u5230 hcd->status_urb \u6307\u9488\u4e0a\u9762\n            \u901a\u5e38 roothub \u9a71\u52a8\u7528\u8fd9\u4e2a urb \u6765\u67e5\u8be2 roothub \u7684\u7aef\u53e3\u72b6\u6001\n    */\n    if (usb_endpoint_xfer_int(&urb->ep->desc))\n        return rh_queue_status (hcd, urb);\n\n    /* (2) \u5bf9\u4e8e control \u7c7b\u578b\u7684\u6570\u636e\uff0c\u662f\u60f3\u8bfb\u53d6 roothub ep0 \u4e0a\u7684\u914d\u7f6e\u4fe1\u606f\n            \u4f7f\u7528\u8f6f\u4ef6\u6765\u6a21\u62df\u8fd9\u7c7b\u64cd\u4f5c\u7684\u54cd\u5e94\n    */\n    if (usb_endpoint_xfer_control(&urb->ep->desc))\n        return rh_call_control (hcd, urb);\n    return -EINVAL;\n}\n\n|\u2192\n\nstatic int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)\n{\n\n    /* (1.1) \u5c06 urb \u6302\u8f7d\u5230\u5bf9\u5e94\u7684 ep \u94fe\u8868\u4e2d */\n    retval = usb_hcd_link_urb_to_ep(hcd, urb);\n    if (retval)\n        goto done;\n\n    /* (1.2) \u5c06 urb \u8d4b\u503c\u7ed9 hcd->status_urb\n            \u5728 hcd \u9a71\u52a8\u4e2d\uff0c\u4f1a\u901a\u8fc7\u8fd9\u4e9b\u63a5\u53e3\u6765\u901a\u77e5 roothub \u7684\u7aef\u53e3\u72b6\u6001\u53d8\u5316\n    */\n    hcd->status_urb = urb;\n    urb->hcpriv = hcd;      /* indicate it's queued */\n    if (!hcd->uses_new_polling)\n        mod_timer(&hcd->rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));\n\n}\n\n|\u2192\n\nstatic int rh_call_control (struct usb_hcd *hcd, struct urb *urb)\n{\n    /* (2.1) \u8f6f\u4ef6\u6a21\u62df\u5bf9 roothub \u914d\u7f6e\u8bfb\u5199\u7684\u54cd\u5e94 */\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"52-usb-device-layer",children:"5.2. USB Device Layer"}),"\n",(0,i.jsx)(n.h4,{id:"521-device-struct-usb_device",children:"5.2.1. Device (struct usb_device)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"USB Device"})," Device \u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e3a ",(0,i.jsx)(n.code,{children:"struct usb_device"})," \uff0c\u4f1a\u5728\u4e24\u79cd\u60c5\u51b5\u4e0b\u88ab\u521b\u5efa\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"roothub device\u3002\u5728 HCD \u9a71\u52a8\u6ce8\u518c\u65f6\u521b\u5efa\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* (1) \u9996\u5148\u521b\u5efa\u548c\u521d\u59cb\u5316 `usb_device` \u7ed3\u6784\uff1a */\nusb_add_hcd() \u2192 usb_alloc_dev():\nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\n                struct usb_bus *bus, unsigned port1)\n{\n\n    /* (1.1) dev \u603b\u7ebf\u521d\u59cb\u5316\u4e3a usb_bus_type */\n    dev->dev.bus = &usb_bus_type;\n    /* (1.2) dev \u7c7b\u578b\u521d\u59cb\u5316\u4e3a usb_device_type\uff0c\u6807\u660e\u81ea\u5df1\u662f\u4e00\u4e2a usb device */\n    dev->dev.type = &usb_device_type;\n    dev->dev.groups = usb_device_groups;\n\n}\n\n/* (2) \u7136\u540e\u6ce8\u518c  `usb_device` \u7ed3\u6784\uff1a */\nusb_add_hcd() \u2192 register_root_hub() \u2192 usb_new_device() \u2192 device_add()\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u666e\u901a usb device\u3002\u5728 Hub \u68c0\u6d4b\u5230\u7aef\u53e3\u6709\u8bbe\u5907 attach \u65f6\u521b\u5efa\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* (1) \u9996\u5148\u521b\u5efa\u548c\u521d\u59cb\u5316 `usb_device` \u7ed3\u6784\uff1a */\nhub_event() \u2192 port_event() \u2192 hub_port_connect_change() \u2192 hub_port_connect() \u2192 usb_alloc_dev()\n\n/* (2) \u7136\u540e\u6ce8\u518c  `usb_device` \u7ed3\u6784\uff1a */\nhub_event() \u2192 port_event() \u2192 hub_port_connect_change() \u2192 hub_port_connect() \u2192 usb_new_device() \u2192 device_add()\n"})}),"\n",(0,i.jsx)(n.h4,{id:"522-driver-struct-usb_device_driver",children:"5.2.2. Driver (struct usb_device_driver)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"USB Device"})," Driver \u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e3a ",(0,i.jsx)(n.code,{children:"struct usb_device_driver"}),"\uff0c\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"usb_register_device_driver()"})," \u51fd\u6570\u8fdb\u884c\u6ce8\u518c\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"int usb_register_device_driver(struct usb_device_driver *new_udriver,\n        struct module *owner)\n{\n\n    /* (1) \u8bbe\u7f6efor_devices\u6807\u5fd7\u4e3a1\uff0c\u8868\u9762\u8fd9\u4e2a\u9a71\u52a8\u65f6\u7ed9 usb device \u4f7f\u7528\u7684 */\n    new_udriver->drvwrap.for_devices = 1;\n    new_udriver->drvwrap.driver.name = new_udriver->name;\n    new_udriver->drvwrap.driver.bus = &usb_bus_type;\n    new_udriver->drvwrap.driver.probe = usb_probe_device;\n    new_udriver->drvwrap.driver.remove = usb_unbind_device;\n    new_udriver->drvwrap.driver.owner = owner;\n    new_udriver->drvwrap.driver.dev_groups = new_udriver->dev_groups;\n\n    retval = driver_register(&new_udriver->drvwrap.driver);\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u6ce8\u518c\u7684 ",(0,i.jsx)(n.code,{children:"USB Device"})," Driver \u9a71\u52a8\u975e\u5e38\u5c11\uff0c\u4e00\u822c\u60c5\u51b5\u4e0b\u6240\u6709\u7684 ",(0,i.jsx)(n.code,{children:"USB Device"})," Device \u90fd\u4f1a\u9002\u914d\u5230 ",(0,i.jsx)(n.code,{children:"usb_generic_driver"}),"\u3002\u56e0\u4e3a\u8fd9\u4e00\u5c42\u6b21\u9a71\u52a8\u7684\u76ee\u7684\u5f88\u5355\u7eaf\uff0c\u5c31\u662f\u7ed9 ",(0,i.jsx)(n.code,{children:"USB Device"})," \u4e0b\u6240\u6709\u7684 ",(0,i.jsx)(n.code,{children:"Interface"})," \u521b\u5efa\u5bf9\u5e94\u7684 ",(0,i.jsx)(n.code,{children:"USB Interface"})," Device\u3002"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'usb_init() \u2192 usb_register_device_driver() :\n\nstatic int __init usb_init(void)\n{\n\n    retval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);\n\n}\n\nstruct usb_device_driver usb_generic_driver = {\n    .name = "usb",\n    .match = usb_generic_driver_match,\n    .probe = usb_generic_driver_probe,\n    .disconnect = usb_generic_driver_disconnect,\n#ifdef      CONFIG_PM\n    .suspend = usb_generic_driver_suspend,\n    .resume = usb_generic_driver_resume,\n#endif\n    .supports_autosuspend = 1,\n};\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u9a71\u52a8 probe() \u8fc7\u7a0b\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_probe_device() \u2192 usb_generic_driver_probe() \u2192 usb_set_configuration():\n\nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n\n    /* (1) \u521b\u5efa\u548c\u521d\u59cb\u5316 `struct usb_interface` */\n    for (i = 0; i < nintf; ++i) {\n        /* (1.1) dev \u603b\u7ebf\u521d\u59cb\u5316\u4e3a usb_bus_type */\n        intf->dev.bus = &usb_bus_type;\n        /* (1.2) dev \u7c7b\u578b\u521d\u59cb\u5316\u4e3a usb_if_device_type\uff0c\u6807\u660e\u81ea\u5df1\u662f\u4e00\u4e2a usb interface */\n        intf->dev.type = &usb_if_device_type;\n        intf->dev.groups = usb_interface_groups;\n    }\n\n    /* (2) \u6ce8\u518c `struct usb_interface` */\n    for (i = 0; i < nintf; ++i) {\n        ret = device_add(&intf->dev);\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"523-bus-usb_bus_type",children:"5.2.3. Bus (usb_bus_type)"}),"\n",(0,i.jsxs)(n.p,{children:["\u53ef\u4ee5\u770b\u5230 ",(0,i.jsx)(n.code,{children:"struct usb_device"})," \u548c ",(0,i.jsx)(n.code,{children:"struct usb_interface"})," \u4f7f\u7528\u7684\u603b\u7ebf\u90fd\u662f ",(0,i.jsx)(n.code,{children:"usb_bus_type"}),"\u3002\u4ed6\u4eec\u662f\u901a\u8fc7\u5b57\u6bb5 ",(0,i.jsx)(n.code,{children:"dev.type"})," \u6765\u533a\u5206\u7684\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* (1) `struct usb_device` \u7684 `dev.type` \u503c\u4e3a `usb_device_type`\uff1a */\nusb_add_hcd() \u2192 usb_alloc_dev():\nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\n                struct usb_bus *bus, unsigned port1)\n{\n    dev->dev.type = &usb_device_type;\n}\n\n/* (2) `struct usb_interface` \u7684 `dev.type` \u503c\u4e3a `usb_if_device_type` */\nusb_probe_device() \u2192 usb_generic_driver_probe() \u2192 usb_set_configuration():\nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n    for (i = 0; i < nintf; ++i) {\n        intf->dev.type = &usb_if_device_type;\n    }\n}\n\nstatic inline int is_usb_device(const struct device *dev)\n{\n    /* (3) \u5224\u65ad\u5f53\u524d Device \u662f\u5426\u4e3a Usb Device */\n    return dev->type == &usb_device_type;\n}\n\nstatic inline int is_usb_interface(const struct device *dev)\n{\n    /* (4) \u5224\u65ad\u5f53\u524d Device \u662f\u5426\u4e3a Usb Interface */\n    return dev->type == &usb_if_device_type;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u53e6\u5916 ",(0,i.jsx)(n.code,{children:"struct usb_device_driver"})," \u548c ",(0,i.jsx)(n.code,{children:"struct usb_driver"})," \u4f7f\u7528\u7684\u603b\u7ebf\u90fd\u662f ",(0,i.jsx)(n.code,{children:"usb_bus_type"}),"\u3002\u4ed6\u4eec\u662f\u901a\u8fc7\u5b57\u6bb5 ",(0,i.jsx)(n.code,{children:"drvwrap.for_devices"})," \u6765\u533a\u5206\u7684\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* (1) `struct usb_device_driver` \u7684 `drvwrap.for_devices` \u503c\u4e3a 1\uff1a */\nint usb_register_device_driver(struct usb_device_driver *new_udriver,\n        struct module *owner)\n{\n    new_udriver->drvwrap.for_devices = 1;\n}\n\n/* (2) `struct usb_driver` \u7684 `drvwrap.for_devices` \u503c\u4e3a 0\uff1a */\nint usb_register_driver(struct usb_driver *new_driver, struct module *owner,\n            const char *mod_name)\n{\n    new_driver->drvwrap.for_devices = 0;\n}\n\n/* (3) \u5224\u65ad\u5f53\u524d Driver \u662f\u9002\u914d Usb Device \u8fd8\u662f Usb Interface */\nstatic inline int is_usb_device_driver(struct device_driver *drv)\n{\n    return container_of(drv, struct usbdrv_wrap, driver)->\n            for_devices;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 ",(0,i.jsx)(n.code,{children:"usb_bus_type"})," \u7684 ",(0,i.jsx)(n.code,{children:"match()"})," \u51fd\u6570\u4e2d\u5229\u7528 ",(0,i.jsx)(n.code,{children:"dev.type"})," \u8fdb\u884c\u5224\u522b\u5206\u5f00\u5904\u7406\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'struct bus_type usb_bus_type = {\n    .name =         "usb",\n    .match =        usb_device_match,\n    .uevent =       usb_uevent,\n    .need_parent_lock =     true,\n};\n\nstatic int usb_device_match(struct device *dev, struct device_driver *drv)\n{\n    /* devices and interfaces are handled separately */\n    /* (1) Device \u662f `Usb Device` \u7684\u5904\u7406 */\n    if (is_usb_device(dev)) {\n        struct usb_device *udev;\n        struct usb_device_driver *udrv;\n\n        /* interface drivers never match devices */\n        /* (1.1) \u53ea\u67e5\u627e `Usb Device` \u7684 Driver */\n        if (!is_usb_device_driver(drv))\n            return 0;\n\n        udev = to_usb_device(dev);\n        udrv = to_usb_device_driver(drv);\n\n        /* If the device driver under consideration does not have a\n        * id_table or a match function, then let the driver\'s probe\n        * function decide.\n        */\n        if (!udrv->id_table && !udrv->match)\n            return 1;\n\n        return usb_driver_applicable(udev, udrv);\n\n    /* (2) Device \u662f `Usb Interface` \u7684\u5904\u7406 */\n    } else if (is_usb_interface(dev)) {\n        struct usb_interface *intf;\n        struct usb_driver *usb_drv;\n        const struct usb_device_id *id;\n\n        /* device drivers never match interfaces */\n        /* (2.1) \u53ea\u67e5\u627e `Usb Interface` \u7684 Driver */\n        if (is_usb_device_driver(drv))\n            return 0;\n\n        intf = to_usb_interface(dev);\n        usb_drv = to_usb_driver(drv);\n\n        id = usb_match_id(intf, usb_drv->id_table);\n        if (id)\n            return 1;\n\n        id = usb_match_dynamic_id(intf, usb_drv);\n        if (id)\n            return 1;\n    }\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"53-usb-interface-layer",children:"5.3. USB Interface Layer"}),"\n",(0,i.jsx)(n.h4,{id:"531-device-struct-usb_interface",children:"5.3.1. Device (struct usb_interface)"}),"\n",(0,i.jsxs)(n.p,{children:["\u5982\u4e0a\u4e00\u8282\u63cf\u8ff0\uff0c ",(0,i.jsx)(n.code,{children:"USB Interface"})," Device \u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e3a ",(0,i.jsx)(n.code,{children:"struct usb_interface"})," \uff0c\u4f1a\u5728 ",(0,i.jsx)(n.code,{children:"USB Device"})," Driver \u9a71\u52a8 probe() \u65f6 \u88ab\u521b\u5efa\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_probe_device() \u2192 usb_generic_driver_probe() \u2192 usb_set_configuration():\n\nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n\n    /* (1) \u521b\u5efa\u548c\u521d\u59cb\u5316 `struct usb_interface` */\n    for (i = 0; i < nintf; ++i) {\n        /* (1.1) dev \u603b\u7ebf\u521d\u59cb\u5316\u4e3a usb_bus_type */\n        intf->dev.bus = &usb_bus_type;\n        /* (1.2) dev \u7c7b\u578b\u521d\u59cb\u5316\u4e3a usb_if_device_type\uff0c\u6807\u660e\u81ea\u5df1\u662f\u4e00\u4e2a usb interface */\n        intf->dev.type = &usb_if_device_type;\n        intf->dev.groups = usb_interface_groups;\n    }\n\n    /* (2) \u6ce8\u518c `struct usb_interface` */\n    for (i = 0; i < nintf; ++i) {\n        ret = device_add(&intf->dev);\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"532-driver-struct-usb_driver",children:"5.3.2. Driver (struct usb_driver)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"USB Interface"})," \u8fd9\u4e00\u5c42\u6b21\u7684\u9a71\u52a8\u5c31\u975e\u5e38\u7684\u591a\u4e86\uff0c\u8fd9\u4e00\u5c42\u4e3b\u8981\u662f\u5728 USB \u4f20\u8f93\u5c42\u4e4b\u4e0a\uff0c\u9488\u5bf9 USB Device \u7684\u67d0\u4e2a\u529f\u80fd ",(0,i.jsx)(n.code,{children:"Function"})," \u5f00\u53d1\u5bf9\u5e94\u7684 USB \u529f\u80fd\u4e1a\u52a1\u9a71\u52a8\uff0c\u5373\u5e38\u8bf4\u7684 ",(0,i.jsx)(n.code,{children:"USB Client Software"}),"\u3002\u5728 USB \u5b9a\u4e49\u4e2d\uff0c\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Interface"})," \u5c31\u662f\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Function"}),"\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"USB Interface"})," Driver \u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e3a ",(0,i.jsx)(n.code,{children:"struct usb_driver"})," \uff0c\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"usb_register_driver()"})," \u51fd\u6570\u8fdb\u884c\u6ce8\u518c\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"int usb_register_driver(struct usb_driver *new_driver, struct module *owner,\n            const char *mod_name)\n{\n\n    /* (1) \u8bbe\u7f6efor_devices\u6807\u5fd7\u4e3a0\uff0c\u8868\u9762\u8fd9\u4e2a\u9a71\u52a8\u65f6\u7ed9 usb interface \u4f7f\u7528\u7684 */\n    new_driver->drvwrap.for_devices = 0;\n    new_driver->drvwrap.driver.name = new_driver->name;\n    new_driver->drvwrap.driver.bus = &usb_bus_type;\n    new_driver->drvwrap.driver.probe = usb_probe_interface;\n    new_driver->drvwrap.driver.remove = usb_unbind_interface;\n    new_driver->drvwrap.driver.owner = owner;\n    new_driver->drvwrap.driver.mod_name = mod_name;\n    new_driver->drvwrap.driver.dev_groups = new_driver->dev_groups;\n    spin_lock_init(&new_driver->dynids.lock);\n    INIT_LIST_HEAD(&new_driver->dynids.list);\n\n    retval = driver_register(&new_driver->drvwrap.driver);\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u4e00\u4e2a\u6700\u7b80\u5355\u7684 ",(0,i.jsx)(n.code,{children:"Usb Interface Driver"})," \u662f ",(0,i.jsx)(n.code,{children:"usb_mouse_driver"})," :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static const struct usb_device_id usb_mouse_id_table[] = {\n    { USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,\n        USB_INTERFACE_PROTOCOL_MOUSE) },\n    { }     /* Terminating entry */\n};\nMODULE_DEVICE_TABLE (usb, usb_mouse_id_table);\n\nstatic struct usb_driver usb_mouse_driver = {\n    .name           = "usbmouse",\n    .probe          = usb_mouse_probe,\n    .disconnect     = usb_mouse_disconnect,\n    .id_table       = usb_mouse_id_table,\n};\n\nmodule_usb_driver(usb_mouse_driver);\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u9996\u5148\u6839\u636e\u5f97\u5230\u7684 endpoint \u51c6\u5907\u597d urb\uff0c\u521b\u5efa\u597d input \u8bbe\u5907\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static int usb_mouse_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n    struct usb_device *dev = interface_to_usbdev(intf);\n    struct usb_host_interface *interface;\n    struct usb_endpoint_descriptor *endpoint;\n    struct usb_mouse *mouse;\n    struct input_dev *input_dev;\n    int pipe, maxp;\n    int error = -ENOMEM;\n\n    interface = intf->cur_altsetting;\n\n    if (interface->desc.bNumEndpoints != 1)\n        return -ENODEV;\n\n    /* (1) \u5f97\u5230\u5f53\u524d interface \u4e2d\u7684\u7b2c\u4e00\u4e2a endpoint\uff0cmouse\u8bbe\u5907\u53ea\u9700\u4e00\u4e2a endpoint */\n    endpoint = &interface->endpoint[0].desc;\n    if (!usb_endpoint_is_int_in(endpoint))\n        return -ENODEV;\n\n    pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n    maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));\n\n    mouse = kzalloc(sizeof(struct usb_mouse), GFP_KERNEL);\n    /* (2.1) \u5206\u914d input device */\n    input_dev = input_allocate_device();\n    if (!mouse || !input_dev)\n        goto fail1;\n\n    mouse->data = usb_alloc_coherent(dev, 8, GFP_ATOMIC, &mouse->data_dma);\n    if (!mouse->data)\n        goto fail1;\n\n    /* (3.1) \u5206\u914d urb */\n    mouse->irq = usb_alloc_urb(0, GFP_KERNEL);\n    if (!mouse->irq)\n        goto fail2;\n\n    mouse->usbdev = dev;\n    mouse->dev = input_dev;\n\n    if (dev->manufacturer)\n        strlcpy(mouse->name, dev->manufacturer, sizeof(mouse->name));\n\n    if (dev->product) {\n        if (dev->manufacturer)\n            strlcat(mouse->name, " ", sizeof(mouse->name));\n        strlcat(mouse->name, dev->product, sizeof(mouse->name));\n    }\n\n    if (!strlen(mouse->name))\n        snprintf(mouse->name, sizeof(mouse->name),\n            "USB HIDBP Mouse %04x:%04x",\n            le16_to_cpu(dev->descriptor.idVendor),\n            le16_to_cpu(dev->descriptor.idProduct));\n\n    usb_make_path(dev, mouse->phys, sizeof(mouse->phys));\n    strlcat(mouse->phys, "/input0", sizeof(mouse->phys));\n\n    /* (2.2) \u521d\u59cb\u5316 input device */\n    input_dev->name = mouse->name;\n    input_dev->phys = mouse->phys;\n    usb_to_input_id(dev, &input_dev->id);\n    input_dev->dev.parent = &intf->dev;\n\n    input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\n    input_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\n        BIT_MASK(BTN_RIGHT) | BIT_MASK(BTN_MIDDLE);\n    input_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\n    input_dev->keybit[BIT_WORD(BTN_MOUSE)] |= BIT_MASK(BTN_SIDE) |\n        BIT_MASK(BTN_EXTRA);\n    input_dev->relbit[0] |= BIT_MASK(REL_WHEEL);\n\n    input_set_drvdata(input_dev, mouse);\n\n    input_dev->open = usb_mouse_open;\n    input_dev->close = usb_mouse_close;\n\n    /* (3.2) \u521d\u59cb\u5316 urb */\n    usb_fill_int_urb(mouse->irq, dev, pipe, mouse->data,\n            (maxp > 8 ? 8 : maxp),\n            usb_mouse_irq, mouse, endpoint->bInterval);\n    mouse->irq->transfer_dma = mouse->data_dma;\n    mouse->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n    /* (2.3) \u6ce8\u518c input device */\n    error = input_register_device(mouse->dev);\n    if (error)\n        goto fail3;\n\n    usb_set_intfdata(intf, mouse);\n    return 0;\n\nfail3:\n    usb_free_urb(mouse->irq);\nfail2:\n    usb_free_coherent(dev, 8, mouse->data, mouse->data_dma);\nfail1:\n    input_free_device(input_dev);\n    kfree(mouse);\n    return error;\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u5728 input device \u88ab open \u65f6\u63d0\u4ea4 urb \u542f\u52a8\u4f20\u8f93\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static int usb_mouse_open(struct input_dev *dev)\n{\n    struct usb_mouse *mouse = input_get_drvdata(dev);\n\n    mouse->irq->dev = mouse->usbdev;\n    /* (1) \u63d0\u4ea4\u521d\u59cb\u5316\u597d\u7684 usb\uff0c\u5f00\u59cb\u67e5\u8be2\u6570\u636e */\n    if (usb_submit_urb(mouse->irq, GFP_KERNEL))\n        return -EIO;\n\n    return 0;\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u5728\u4f20\u8f93\u5b8c urb \u7684\u56de\u8c03\u51fd\u6570\u4e2d\uff0c\u6839\u636e\u8bfb\u56de\u7684\u6570\u636e\u4e0a\u62a5 input \u4e8b\u4ef6\uff0c\u5e76\u4e14\u91cd\u65b0\u63d0\u4ea4 urb \u7ee7\u7eed\u67e5\u8be2\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static void usb_mouse_irq(struct urb *urb)\n{\n    struct usb_mouse *mouse = urb->context;\n    signed char *data = mouse->data;\n    struct input_dev *dev = mouse->dev;\n    int status;\n\n    switch (urb->status) {\n    case 0:                 /* success */\n        break;\n    case -ECONNRESET:       /* unlink */\n    case -ENOENT:\n    case -ESHUTDOWN:\n        return;\n    /* -EPIPE:  should clear the halt */\n    default:                /* error */\n        goto resubmit;\n    }\n\n    /* (1) \u6839\u636e urb \u8bfb\u56de\u7684\u6570\u636e\uff0c\u4e0a\u62a5 input event */\n    input_report_key(dev, BTN_LEFT,   data[0] & 0x01);\n    input_report_key(dev, BTN_RIGHT,  data[0] & 0x02);\n    input_report_key(dev, BTN_MIDDLE, data[0] & 0x04);\n    input_report_key(dev, BTN_SIDE,   data[0] & 0x08);\n    input_report_key(dev, BTN_EXTRA,  data[0] & 0x10);\n\n    input_report_rel(dev, REL_X,     data[1]);\n    input_report_rel(dev, REL_Y,     data[2]);\n    input_report_rel(dev, REL_WHEEL, data[3]);\n\n    input_sync(dev);\nresubmit:\n    /* (2) \u91cd\u65b0\u63d0\u4ea4 urb \u7ee7\u7eed\u67e5\u8be2 */\n    status = usb_submit_urb (urb, GFP_ATOMIC);\n    if (status)\n        dev_err(&mouse->usbdev->dev,\n            "can\'t resubmit intr, %s-%s/input0, status %d\\n",\n            mouse->usbdev->bus->bus_name,\n            mouse->usbdev->devpath, status);\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"533-usb-hub-driver",children:"5.3.3. USB Hub Driver"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hub1-170676426846137.png",alt:"image3"})}),"\n",(0,i.jsx)(n.p,{children:"\u666e\u901a\u7684 Usb Device \u901a\u8fc7\u5185\u90e8\u7684 Interface \u63d0\u4f9b\u5404\u79cd\u4e1a\u52a1\u529f\u80fd\u3002\u800c Hub \u8fd9\u7c7b\u7279\u6b8a\u7684 Usb Device \u529f\u80fd\u5c31\u4e00\u79cd\uff0c\u90a3\u5c31\u662f\u76d1\u63a7\u7aef\u53e3\u7684\u72b6\u6001\u53d8\u5316\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u5728\u7aef\u53e3\u4e0a\u6709\u8bbe\u5907 attach \u65f6\uff0c\u521b\u5efa\u65b0\u7684 usb device\uff0c\u7ed9\u5176\u9002\u914d\u9a71\u52a8\u3002\u5982\u679c\u662f hub device\uff0c\u5b50 usb \u9a71\u52a8\u4f1a\u8fdb\u4e00\u6b65\u626b\u63cf\u7aef\u53e3\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u5728\u7aef\u53e3\u4e0a\u6709\u8bbe\u5907 deattach \u65f6\uff0c\u79fb\u9664\u6389\u5bf9\u5e94\u7684 usb device\u3002\u5982\u679c\u662f hub device \u8fdb\u4e00\u6b65\u79fb\u9664\u5176\u6240\u6709\u7684\u5b50 usb device\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Hub \u4e5f\u662f\u6807\u51c6\u7684 Usb Device\uff0c\u5b83\u4e5f\u662f\u6807\u51c6\u7684\u6d41\u7a0b\u88ab\u4e0a\u4e00\u7ea7\u8bbe\u5907\u53d1\u73b0\u540e ",(0,i.jsx)(n.code,{children:"\u521b\u5efa Usb Device"})," \u2192 ",(0,i.jsx)(n.code,{children:"\u521b\u5efa Usb Interface"})," \uff0c\u7136\u540e\u88ab ",(0,i.jsx)(n.code,{children:"Usb Hub Interface"})," Driver \u7ed9\u9002\u914d\u5230\u3002\u7cfb\u7edf\u4e2d\u53ea\u6709\u4e00\u4e2a Hub \u9a71\u52a8\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static const struct usb_device_id hub_id_table[] = {\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n                | USB_DEVICE_ID_MATCH_PRODUCT\n                | USB_DEVICE_ID_MATCH_INT_CLASS,\n    .idVendor = USB_VENDOR_SMSC,\n    .idProduct = USB_PRODUCT_USB5534B,\n    .bInterfaceClass = USB_CLASS_HUB,\n    .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n            | USB_DEVICE_ID_MATCH_INT_CLASS,\n    .idVendor = USB_VENDOR_GENESYS_LOGIC,\n    .bInterfaceClass = USB_CLASS_HUB,\n    .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,\n    .bDeviceClass = USB_CLASS_HUB},\n    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n    .bInterfaceClass = USB_CLASS_HUB},\n    { }                                             /* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, hub_id_table);\n\nstatic struct usb_driver hub_driver = {\n    .name =         "hub",\n    .probe =        hub_probe,\n    .disconnect =   hub_disconnect,\n    .suspend =      hub_suspend,\n    .resume =       hub_resume,\n    .reset_resume = hub_reset_resume,\n    .pre_reset =    hub_pre_reset,\n    .post_reset =   hub_post_reset,\n    .unlocked_ioctl = hub_ioctl,\n    .id_table =     hub_id_table,\n    .supports_autosuspend = 1,\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["hub_driver \u9a71\u52a8\u542f\u52a8\u4ee5\u540e\uff0c\u53ea\u505a\u4e00\u4ef6\u4e8b\u60c5\u53d1\u9001\u4e00\u4e2a\u67e5\u8be2\u7aef\u53e3\u72b6\u6001\u7684 ",(0,i.jsx)(n.code,{children:"urb"})," \uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"hub_probe() \u2192 hub_configure():\n\nstatic int hub_configure(struct usb_hub *hub,\n    struct usb_endpoint_descriptor *endpoint)\n{\n\n    /* (1) \u5206\u914d urb */\n    hub->urb = usb_alloc_urb(0, GFP_KERNEL);\n    if (!hub->urb) {\n        ret = -ENOMEM;\n        goto fail;\n    }\n\n    /* (2) \u521d\u59cb\u5316 urb\uff0c\u4f5c\u7528\u5c31\u662f\u901a\u8fc7 ep0 \u67e5\u8be2 hub \u7684\u7aef\u53e3\u72b6\u6001\n            urb \u7684\u56de\u8c03\u51fd\u6570\u662f hub_irq()\n    */\n    usb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\n        hub, endpoint->bInterval);\n\n    /* (3) \u53d1\u9001 urb */\n    hub_activate(hub, HUB_INIT);\n\n}\n\n\u2193\n\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n    /*  (3.1) \u63d0\u4ea4 urb */\n    status = usb_submit_urb(hub->urb, GFP_NOIO);\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"5331-normal-hub-port-op",children:"5.3.3.1. Normal Hub Port op"}),"\n",(0,i.jsx)(n.p,{children:"\u5728\u666e\u901a\u7684 hub \u4e2d\uff0c\u7aef\u53e3\u64cd\u4f5c\u662f\u901a\u8fc7\u6807\u51c6\u7684 urb \u53d1\u8d77 usb ep0 \u8bfb\u5199\u3002\u5206\u4e3a\u4e24\u7c7b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u901a\u8fc7\u8f6e\u8be2\u8bfb\u53d6 Hub Class-specific Requests \u914d\u7f6e\u6765\u67e5\u8be2\u7aef\u53e3\u7684\u72b6\u6001\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hub_get_port-170676429678339.png",alt:"image4"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u8bbe\u7f6e\u548c\u4f7f\u80fd\u7aef\u53e3\u4e5f\u662f\u901a\u8fc7 Hub Class-specific Requests \u4e2d\u76f8\u5e94\u7684\u547d\u4ee4\u5b9e\u73b0\u7684\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_hub_set_port-170676430705641.png",alt:"image5"})}),"\n",(0,i.jsx)(n.h5,{id:"5332-roothub-port-op",children:"5.3.3.2. RootHub Port op"}),"\n",(0,i.jsx)(n.p,{children:"\u800c\u5bf9\u4e8e roothub \u6765\u8bf4\uff0c\u5bf9\u7aef\u53e3\u7684\u64cd\u4f5c\u7684 urb \u90fd\u9700\u8981\u7279\u6b8a\u5904\u7406 (\u4ee5 EHCI \u7684\u9a71\u52a8\u4e3a\u4f8b)\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u7aef\u53e3\u72b6\u6001\u7684\u53d8\u5316\u53ef\u4ee5\u901a\u8fc7 HCD \u89e6\u53d1\u4e2d\u65ad\u518d\u4e0a\u62a5\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ehci_irq() \u2192 usb_hcd_poll_rh_status() :\n\nvoid usb_hcd_poll_rh_status(struct usb_hcd *hcd)\n{\n\n    /* (1) \u83b7\u53d6\u7aef\u53e3\u72b6\u6001\u7684\u53d8\u5316 */\n    length = hcd->driver->hub_status_data(hcd, buffer);\n    if (length > 0) {\n\n        /* try to complete the status urb */\n        spin_lock_irqsave(&hcd_root_hub_lock, flags);\n\n        /* (2) \u901a\u8fc7\u56de\u590d hcd->status_urb \u6765\u8fdb\u884c\u4e0a\u62a5 */\n        urb = hcd->status_urb;\n        if (urb) {\n            clear_bit(HCD_FLAG_POLL_PENDING, &hcd->flags);\n            hcd->status_urb = NULL;\n            urb->actual_length = length;\n            memcpy(urb->transfer_buffer, buffer, length);\n\n            usb_hcd_unlink_urb_from_ep(hcd, urb);\n            usb_hcd_giveback_urb(hcd, urb, 0);\n        } else {\n            length = 0;\n            set_bit(HCD_FLAG_POLL_PENDING, &hcd->flags);\n        }\n        spin_unlock_irqrestore(&hcd_root_hub_lock, flags);\n    }\n\n}\n\n\u2193\n\nhcd->driver->hub_status_data() \u2192 ehci_hub_status_data():\n\nstatic int\nehci_hub_status_data (struct usb_hcd *hcd, char *buf)\n{\n    /* (1.1) \u901a\u8fc7 HCD \u9a71\u52a8\uff0c\u83b7\u53d6 roothub \u7aef\u53e3\u7684\u72b6\u6001 */\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u8bbe\u7f6e\u548c\u4f7f\u80fd\u7aef\u53e3\u9700\u8981\u5ac1\u63a5\u5230 HCD \u9a71\u52a8\u76f8\u5173\u51fd\u6570\u4e0a\u5b9e\u73b0\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_hcd_submit_urb() \u2192 rh_urb_enqueue() \u2192 rh_call_control() \u2192 hcd->driver->hub_control() \u2192 ehci_hub_control():\n\nint ehci_hub_control(\n    struct usb_hcd  *hcd,\n    u16             typeReq,\n    u16             wValue,\n    u16             wIndex,\n    char            *buf,\n    u16             wLength\n) {\n    /* (1) \u901a\u8fc7 HCD \u9a71\u52a8\uff0c\u8bbe\u7f6e roothub \u7684\u7aef\u53e3 */\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"5333-device-attach",children:"5.3.3.3. Device Attach"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"hub_event() \u2192 port_event() \u2192 hub_port_connect_change() \u2192 hub_port_connect():\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n        u16 portchange)\n{\n\n    for (i = 0; i < PORT_INIT_TRIES; i++) {\n\n        /* (1) \u7ed9\u7aef\u53e3\u4e0a\u65b0 Device \u5206\u914d `struct usb_device` \u6570\u636e\u7ed3\u6784 */\n        udev = usb_alloc_dev(hdev, hdev->bus, port1);\n        if (!udev) {\n            dev_err(&port_dev->dev,\n                    \"couldn't allocate usb_device\\n\");\n            goto done;\n        }\n\n        /* (2) \u7ed9\u65b0\u7684 Device \u5206\u914d\u4e00\u4e2a\u65b0\u7684 Address */\n        choose_devnum(udev);\n        if (udev->devnum <= 0) {\n            status = -ENOTCONN;     /* Don't retry */\n            goto loop;\n        }\n\n        /* reset (non-USB 3.0 devices) and get descriptor */\n        usb_lock_port(port_dev);\n        /* (3) \u4f7f\u80fd\u7aef\u53e3\uff0c\u5e76\u4e14\u8c03\u7528 hub_set_address() \u7ed9 Device \u914d\u7f6e\u4e0a\u65b0\u5206\u914d\u7684 Address */\n        status = hub_port_init(hub, udev, port1, i);\n        usb_unlock_port(port_dev);\n\n        /* (4) \u6ce8\u518c `struct usb_device` */\n            status = usb_new_device(udev);\n\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"5334-device-deattach",children:"5.3.3.4. Device Deattach"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"hub_event() \u2192 port_event() \u2192 hub_port_connect_change() \u2192 hub_port_connect():\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n        u16 portchange)\n{\n\n    /* (1) \u79fb\u9664\u7aef\u53e3\u4e0a\u7684 `struct usb_device` */\n    if (udev) {\n        if (hcd->usb_phy && !hdev->parent)\n            usb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n        usb_disconnect(&port_dev->child);\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"534-bus-usb_bus_type",children:"5.3.4. Bus (usb_bus_type)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"USB Interface"})," \u8fd9\u4e00\u5c42\u6b21\u603b\u7ebf\u4e5f\u662f ",(0,i.jsx)(n.code,{children:"usb_bus_type"})," \uff0c\u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\uff0c\u8fd9\u91cc\u5c31\u4e0d\u91cd\u590d\u89e3\u6790\u4e86\u3002"]}),"\n",(0,i.jsx)(n.h3,{id:"54-usb-host-controller-layer",children:"5.4. USB Host Controller Layer"}),"\n",(0,i.jsx)(n.p,{children:"Usb Host Controller \u63d0\u4f9b\u4e86 endpoint \u5c42\u7ea7\u7684\u6570\u636e\u6536\u53d1\uff0c\u4e3b\u8981\u5206\u4e3a\u4ee5\u4e0b\u79cd\u7c7b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Usb1.0 \u6709\u4e24\u79cd\u63a7\u5236\u5668\u6807\u51c6\uff1a ",(0,i.jsx)(n.code,{children:"OHCI"})," \u5eb7\u67cf\u7684\u5f00\u653e\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\uff0c ",(0,i.jsx)(n.code,{children:"UHCI"})," Intel \u7684\u901a\u7528\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\u3002\u5b83\u4eec\u7684\u4e3b\u8981\u533a\u522b\u662f UHCI \u66f4\u52a0\u4f9d\u8d56\u8f6f\u4ef6\u9a71\u52a8\uff0c\u56e0\u6b64\u5bf9 CPU \u8981\u6c42\u66f4\u9ad8\uff0c\u4f46\u662f\u81ea\u8eab\u7684\u786c\u4ef6\u4f1a\u66f4\u5ec9\u4ef7\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["Usb2.0 \u53ea\u6709\u4e00\u79cd\u63a7\u5236\u5668\u6807\u51c6\uff1a ",(0,i.jsx)(n.code,{children:"EHCI"})," \u3002\u56e0\u4e3a ",(0,i.jsx)(n.code,{children:"EHCI"})," \u53ea\u652f\u6301\u9ad8\u901f\u4f20\u8f93\uff0c\u6240\u4ee5EHCI\u63a7\u5236\u5668\u5305\u62ec\u56db\u4e2a\u865a\u62df\u7684\u5168\u901f\u6216\u8005\u6162\u901f\u63a7\u5236\u5668\u3002 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u4e3b\u8981\u7528\u4e8e USB 2.0\uff0c\u8001\u7684 USB 1.1 \u7528 ",(0,i.jsx)(n.code,{children:"OHCI"})," \u548c ",(0,i.jsx)(n.code,{children:"UHCI"})," \u3002 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u4e3a\u4e86\u517c\u5bb9 USB 1.1\uff0c\u5c06\u8001\u7684 ",(0,i.jsx)(n.code,{children:"OHCI"})," \u548c ",(0,i.jsx)(n.code,{children:"UHCI"})," \u5408\u5e76\u5230 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u89c4\u8303\u91cc\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["USB 3.0 \u63a7\u5236\u5668\u6807\u51c6\uff1a ",(0,i.jsx)(n.code,{children:"XHCI"})," \u3002 ",(0,i.jsx)(n.code,{children:"XHCI"})," \u662f Intel \u6700\u65b0\u5f00\u53d1\u7684\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\uff0c\u5e7f\u6cdb\u7528\u6237 Intel \u516d\u4ee3 Skylake \u5904\u7406\u5668\u5bf9\u5e94\u7684 100 \u7cfb\u5217\u4e3b\u677f\u4e0a\uff0c\u652f\u6301 USB3.0 \u63a5\u53e3\uff0c\u5f80\u4e0b\u4e5f\u517c\u5bb9 USB2.0 \u3002 XHCI \u82f1\u6587\u5168\u79f0 ",(0,i.jsx)(n.code,{children:"eXtensible Host Controller Interface"})," \uff0c\u662f\u4e00\u79cd\u53ef\u6269\u5c55\u7684\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\uff0c\u662f Intel \u5f00\u53d1\u7684 USB \u4e3b\u673a\u63a7\u5236\u5668\u3002Intel \u7cfb\u5217\u82af\u7247\u7684 USB \u534f\u8bae\u91c7\u7528\u7684\u5c31\u662f ",(0,i.jsx)(n.code,{children:"XHCI"})," \u4e3b\u63a7\uff0c\u4e3b\u8981\u9762\u5411 USB 3.0 \u6807\u51c6\u7684\uff0c\u540c\u65f6\u4e5f\u517c\u5bb9 2.0 \u4ee5\u4e0b\u7684\u8bbe\u5907\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"541-aic-usb-host-controller",children:"5.4.1. AIC USB Host Controller"}),"\n",(0,i.jsx)(n.p,{children:"ArtinChip \u63d0\u4f9b\u4e86\u517c\u5bb9\u6807\u51c6 EHCI \u7684 USB Host Controller\u3002"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EHCI"})," \u53ea\u652f\u6301 USB 2.0 \u9ad8\u901f\u4f20\u8f93\uff0c\u4e3a\u4e86\u5411\u4e0b\u517c\u5bb9 USB 1.1\uff0c\u5b83\u76f4\u63a5\u5728\u5185\u90e8\u96c6\u6210\u6700\u591a4\u4e2a\u5168\u901f\u6216\u8005\u6162\u901f\u63a7\u5236\u5668 ",(0,i.jsx)(n.code,{children:"OHCI"}),"\u3002\u5728 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u534f\u8bae\u5185\u79f0\u8fd9\u79cd\u4f34\u751f\u7684 ",(0,i.jsx)(n.code,{children:"OHCI"})," \u63a7\u5236\u5668\u4e3a ",(0,i.jsx)(n.code,{children:"companion host controllers"}),"\u3002"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_ohci-170676434261143.png",alt:"image6"})}),"\n",(0,i.jsxs)(n.p,{children:["\u7531 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u9a71\u52a8\u6839\u636e\u7aef\u53e3\u901f\u7387\u60c5\u51b5\u6765\u51b3\u5b9a\u7531\u8c01\u6765\u5904\u7406\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u6bcf\u4e2a\u7aef\u53e3\u6709\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Owner"})," \u5c5e\u6027\uff0c\u7528\u6765\u51b3\u5b9a\u662f ",(0,i.jsx)(n.code,{children:"EHCI"})," \u7ba1\u7406\u8fd8\u662f ",(0,i.jsx)(n.code,{children:"OHCI"})," \u7ba1\u7406\u3002\u5c31\u662f\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Switch"})," \u5f00\u5173\uff0c\u51b3\u5b9a USB \u6570\u636e\u5207\u5230\u54ea\u8fb9\u5904\u7406\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["\u521d\u59cb\u72b6\u6001\u65f6\u7aef\u53e3\u9ed8\u8ba4\u5c5e\u4e8e ",(0,i.jsx)(n.code,{children:"OHCI"})," \u7ba1\u7406\u3002\u6240\u4ee5\u5bf9\u4e8e\u786c\u4ef6\u4e0a\u4ece ",(0,i.jsx)(n.code,{children:"OHCI"})," \u5347\u7ea7\u5230 ",(0,i.jsx)(n.code,{children:"EHCI"})," \uff0c\u800c\u8f6f\u4ef6\u4e0a\u53ea\u6709 ",(0,i.jsx)(n.code,{children:"OHCI"})," \u9a71\u52a8\u800c\u6ca1\u6709 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u9a71\u52a8\u7684\u7cfb\u7edf\u6765\u8bf4\u662f\u900f\u660e\u7684\uff0c\u5b83\u7ee7\u7eed\u628a ",(0,i.jsx)(n.code,{children:"EHCI"})," \u5f53\u6210 ",(0,i.jsx)(n.code,{children:"OHCI"})," \u786c\u4ef6\u6765\u4f7f\u7528\u5c31\u884c\u4e86\uff0c\u4fdd\u6301\u5b8c\u7f8e\u7684\u5411\u524d\u517c\u5bb9\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["\u5982\u679c\u7cfb\u7edf\u8f6f\u4ef6\u4e0a\u542f\u7528\u4e86 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u9a71\u52a8\uff0c\u5b83\u9996\u5148\u4f1a\u628a\u6240\u6709\u7aef\u53e3\u7684 ",(0,i.jsx)(n.code,{children:"Owner"})," \u914d\u7f6e\u6210 ",(0,i.jsx)(n.code,{children:"EHCI"})," \u7ba1\u7406\u3002\u5982\u679c ",(0,i.jsx)(n.code,{children:"EHCI"})," \u9a71\u52a8\u53d1\u73b0\u7aef\u53e3\u8fde\u63a5\u4e14\u901f\u7387\u662f\u5168\u901f\u6216\u8005\u6162\u901f\uff0c\u5219\u628a\u7aef\u53e3\u7684 ",(0,i.jsx)(n.code,{children:"Owner"})," \u914d\u7f6e\u6210 ",(0,i.jsx)(n.code,{children:"OHCI"})," \u7ba1\u7406\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\u5bf9\u4e8e EHCI \u8fd9\u79cd\u5305\u542b\u4e24\u79cd\u63a7\u5236\u5668\u7684\u517c\u5bb9\u65b9\u5f0f\uff0c\u8f6f\u4ef6\u4e0a\u9700\u8981\u540c\u65f6\u542f\u52a8 EHCI Driver \u548c OHCI Driver\uff0c\u624d\u80fd\u5b8c\u6574\u7684\u517c\u5bb9 USB 1.0 \u548c USB 2.0\uff1a"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_ohci_sw-170676434898945.png",alt:"image7"})}),"\n",(0,i.jsx)(n.h4,{id:"542-ehci-\u5185\u90e8\u7ed3\u6784",children:"5.4.2. EHCI \u5185\u90e8\u7ed3\u6784"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule-170676435836747.png",alt:"image8"})}),"\n",(0,i.jsx)(n.p,{children:"EHCI \u7684\u6838\u5fc3\u5c31\u662f\u628a\u6570\u636e\u4f20\u8f93\u5206\u6210\u4e86\u4e24\u7c7b\u6765\u8fdb\u884c\u8c03\u5ea6\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Asynchronous Schedule"}),"\u3002\u7528\u6765\u4f20\u8f93\u5bf9\u65f6\u95f4\u5ef6\u8fdf\u8981\u6c42\u4e0d\u9ad8\u7684 Endpoint \u6570\u636e\uff0c\u5305\u62ec ",(0,i.jsx)(n.code,{children:"Control Transfer"})," \u548c ",(0,i.jsx)(n.code,{children:"Bulk Transfer"}),"\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Periodic Schedule"}),"\u3002\u7528\u6765\u4f20\u8f93\u5bf9\u65f6\u95f4\u5ef6\u8fdf\u8981\u6c42\u9ad8\u7684 Endpoint \u6570\u636e\uff0c\u5305\u62ec ",(0,i.jsx)(n.code,{children:"Isochronous Transfer"})," \u548c ",(0,i.jsx)(n.code,{children:"Interrupt Transfer"}),"\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"5421-asynchronous-queue-schedule",children:"5.4.2.1. Asynchronous Queue Schedule"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_async-170676441968351.png",alt:"image9"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Asynchronous Schedule"})," \u5185\u90e8\u5b9e\u73b0\u975e\u5e38\u7684\u7b80\u5355\u5c31\u53ea\u6709\u4e00\u7ea7\u94fe\u8868\uff0c\u94fe\u8868\u4e2d\u53ea\u6709 ",(0,i.jsx)(n.code,{children:"Queue Head"})," \u7c7b\u578b\u7684\u63cf\u8ff0\u7b26\u3002\u6bcf\u4e2a\u65f6\u95f4\u7247\u5185\u4f20\u8f93\u5b8c Period \u6570\u636e\u4ee5\u540e\uff0c\u518d\u5c3d\u53ef\u80fd\u7684\u4f20\u8f93 Asynchronous \u6570\u636e\u5373\u53ef\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"\u6838\u5fc3\u7684\u63cf\u8ff0\u7b26\u5982\u4e0b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Queue Head"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_qh-170676447313453.png",alt:"image10"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Queue Element Transfer Descriptor (qTD)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_qtd-170676448884155.png",alt:"image11"})}),"\n",(0,i.jsx)(n.h5,{id:"5422-periodic-queue-schedule",children:"5.4.2.2. Periodic Queue Schedule"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_period-170676452863457.png",alt:"image12"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Periodic Schedule"})," \u5185\u90e8\u5b9e\u73b0\u5982\u4e0a\u56fe\u6240\u793a\uff0c\u6838\u5fc3\u662f\u4e24\u7ea7\u94fe\u8868\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u7b2c\u4e00\u7ea7\u94fe\u8868\u5982\u4e0a\u56fe ",(0,i.jsx)(n.code,{children:"\u7eff\u8272"})," \u6240\u793a\u3002\u662f\u5404\u79cd\u4f20\u8f93\u7ed3\u6784\u7684\u5b9e\u9645\u63cf\u8ff0\u7b26\uff0c\u4e3b\u8981\u5305\u542b\u4ee5\u4e0b\u51e0\u79cd\u7c7b\u578b\u7684\u63cf\u8ff0\u7b26\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_period_type-170676454719259.png",alt:"image13"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u7b2c\u4e8c\u7ea7\u94fe\u8868\u5982\u4e0a\u56fe ",(0,i.jsx)(n.code,{children:"\u6a59\u8272"})," \u6240\u793a\u3002\u662f\u4e00\u4e2a\u6307\u9488\u6570\u7ec4\uff0c\u6570\u7ec4\u4e2d\u4fdd\u5b58\u7684\u662f\u6307\u5411\u7b2c\u4e00\u7ea7\u94fe\u8868\u7684\u6307\u9488\u3002\u8fd9\u91cc\u6bcf\u4e2a\u6570\u7ec4\u6210\u5458\u4ee3\u8868\u4e00\u4e2a\u65f6\u95f4\u5206\u7247 Frame/Micro-Frame \u7684\u8d77\u59cb\u4f4d\u7f6e\uff0c\u6bcf\u4e2a\u65f6\u95f4\u7247\u4f1a\u6839\u636e\u6307\u9488\u4f20\u8f93\u7b2c\u4e00\u7ea7\u94fe\u8868\u4e2d\u7684\u6570\u636e\uff0c\u76f4\u5230\u7b2c\u4e00\u7ea7\u94fe\u8868\u7684\u7ed3\u5c3e\u3002\u6307\u9488\u7684\u683c\u5f0f\u5982\u4e0b\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_period_framelist-170676455945561.png",alt:"image14"})}),"\n",(0,i.jsx)(n.p,{children:"\u6ce8\u89e3"}),"\n",(0,i.jsx)(n.p,{children:"\u8fd9\u91cc\u7684\u8c03\u5ea6\u601d\u60f3\u5c31\u662f\uff1a\u7b2c\u4e00\u7ea7\u94fe\u8868\u662f\u4e00\u4e2a\u4f20\u8f93\u6570\u636e\u5168\u96c6\uff0c\u7b2c\u4e8c\u7ea7\u94fe\u8868\u51b3\u5b9a\u4e86\u67d0\u4e2a\u65f6\u95f4\u7247\u91cc\u8981\u4f20\u8f93\u7684\u6570\u636e\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u8fd9\u6837\u5408\u7406\u7684\u5b89\u6392\u4e8c\u7ea7\u94fe\u8868\u7684\u6307\u9488\uff0c\u6bd4\u5982\u95f4\u9694 8 \u6b21\u6307\u5411\u540c\u4e00\u4f4d\u7f6e\u8fd9\u90e8\u5206\u6570\u636e\u7684 interval \u5c31\u662f 8\uff0c\u95f4\u9694 4 \u6b21\u6307\u5411\u540c\u4e00\u4f4d\u7f6e\u8fd9\u90e8\u5206\u6570\u636e\u7684 interval \u5c31\u662f 4\u3002 \u7b2c\u4e00\u7ea7\u94fe\u8868\u4e5f\u662f\u8981\u6839\u636e interval \u6392\u5e8f\u7684\u3002"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Periodic Schedule"})," \u6838\u5fc3\u7684\u63cf\u8ff0\u7b26\u9664\u4e86 QH\u3001QTD \u8fd8\u6709 ITD\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Isochronous (High-Speed) Transfer Descriptor (iTD)"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_ehci_schedule_itd-170676457166363.png",alt:"image15"})}),"\n",(0,i.jsx)(n.h4,{id:"543-ehci-driver",children:"5.4.3. EHCI Driver"}),"\n",(0,i.jsx)(n.p,{children:"ehci driver \u8d1f\u8d23\u628a echi \u529f\u80fd\u5c01\u88c5\u6210\u6807\u51c6\u7684 hcd \u9a71\u52a8\u3002\u5b83\u4e3b\u8981\u5b8c\u6210\u4e24\u9879\u5de5\u4f5c\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u6ce8\u518c\u6807\u51c6\u7684 hcd \u9a71\u52a8\u3002\u628a ",(0,i.jsx)(n.code,{children:"Client Software"})," \u4f20\u9001\u4e0b\u6765\u7684 ",(0,i.jsx)(n.code,{children:"urb"})," \u6620\u5c04\u5230 EHCI \u7684\u94fe\u8868\u4e2d\u8fdb\u884c\u4f20\u8f93\u3002"]}),"\n",(0,i.jsx)(n.li,{children:"\u521b\u5efa\u4e00\u4e2a\u865a\u62df\u7684\u6839 hub \u8bbe\u5907\uff0c\u5373 roothub\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"5431-urb-transfer",children:"5.4.3.1. URB Transfer"}),"\n",(0,i.jsx)(n.p,{children:"ehci \u6ce8\u518c hcd \u9a71\u52a8\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static int ehci_platform_probe(struct platform_device *dev)\n{\n\n    /* (1) \u5206\u914d hcd\uff0c\u5e76\u4e14\u628a hcd->driver \u521d\u59cb\u5316\u6210 ehci_hc_driver */\n    ehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);\n    hcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,\n                dev_name(&dev->dev));\n\n    /* (2) \u6ce8\u518c\u6807\u51c6\u7684 hcd \u9a71\u52a8 */\n    err = usb_add_hcd(hcd, irq, IRQF_SHARED);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["hcd \u9a71\u52a8\u5411\u4e0a\u63d0\u4f9b\u4e86\u6807\u51c6\u63a5\u53e3\uff0c\u6700\u7ec8\u7684\u5b9e\u73b0\u4f1a\u8c03\u7528\u5230 ",(0,i.jsx)(n.code,{children:"ehci_hc_driver"})," \u5f53\u4e2d\u3002"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static const struct hc_driver ehci_hc_driver = {\n    .description =          hcd_name,\n    .product_desc =         "EHCI Host Controller",\n    .hcd_priv_size =        sizeof(struct ehci_hcd),\n\n    /*\n    * generic hardware linkage\n    */\n    .irq =                  ehci_irq,\n    .flags =                HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,\n\n    /*\n    * basic lifecycle operations\n    */\n    .reset =                ehci_setup,\n    .start =                ehci_run,\n    .stop =                 ehci_stop,\n    .shutdown =             ehci_shutdown,\n\n    /*\n    * managing i/o requests and associated device resources\n    */\n    .urb_enqueue =          ehci_urb_enqueue,\n    .urb_dequeue =          ehci_urb_dequeue,\n    .endpoint_disable =     ehci_endpoint_disable,\n    .endpoint_reset =       ehci_endpoint_reset,\n    .clear_tt_buffer_complete =     ehci_clear_tt_buffer_complete,\n\n    /*\n    * scheduling support\n    */\n    .get_frame_number =     ehci_get_frame,\n\n    /*\n    * root hub support\n    */\n    .hub_status_data =      ehci_hub_status_data,\n    .hub_control =          ehci_hub_control,\n    .bus_suspend =          ehci_bus_suspend,\n    .bus_resume =           ehci_bus_resume,\n    .relinquish_port =      ehci_relinquish_port,\n    .port_handed_over =     ehci_port_handed_over,\n    .get_resuming_ports =   ehci_get_resuming_ports,\n\n    /*\n    * device support\n    */\n    .free_dev =             ehci_remove_device,\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 urb transfer \u8fc7\u7a0b\u4e2d\uff0c\u6700\u6838\u5fc3\u7684\u662f\u8c03\u7528\u4e0a\u8ff0\u7684 ",(0,i.jsx)(n.code,{children:"ehci_urb_enqueue()"})," \u548c ",(0,i.jsx)(n.code,{children:"ehci_urb_dequeue()"})," \u51fd\u6570\u3002"]}),"\n",(0,i.jsx)(n.h5,{id:"5432-roothub",children:"5.4.3.2. Roothub"}),"\n",(0,i.jsx)(n.p,{children:"\u9996\u5148\u521b\u5efa\u865a\u62df\u7684 roothub:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* (1) \u9996\u5148\u521b\u5efa\u548c\u521d\u59cb\u5316 `usb_device` \u7ed3\u6784\uff1a */\nehci_platform_probe() \u2192 usb_add_hcd() \u2192 usb_alloc_dev():\nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\n                struct usb_bus *bus, unsigned port1)\n{\n\n    /* (1.1) dev \u603b\u7ebf\u521d\u59cb\u5316\u4e3a usb_bus_type */\n    dev->dev.bus = &usb_bus_type;\n    /* (1.2) dev \u7c7b\u578b\u521d\u59cb\u5316\u4e3a usb_device_type\uff0c\u6807\u660e\u81ea\u5df1\u662f\u4e00\u4e2a usb device */\n    dev->dev.type = &usb_device_type;\n    dev->dev.groups = usb_device_groups;\n\n}\n\n/* (2) \u7136\u540e\u6ce8\u518c  `usb_device` \u7ed3\u6784\uff1a */\nusb_add_hcd() \u2192 register_root_hub() \u2192 usb_new_device() \u2192 device_add()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u7136\u540e\u56e0\u4e3a roothub \u5e76\u4e0d\u662f\u5728 Usb \u7269\u7406\u603b\u7ebf\u4e0a\uff0c\u6240\u4ee5\u5bf9\u5b83\u7684\u67e5\u8be2\u548c\u914d\u7f6e\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002\u8be6\u89c1 ",(0,i.jsx)(n.code,{children:"Usb Hub Driver"})," \u8fd9\u4e00\u8282\u3002"]}),"\n",(0,i.jsx)(n.h2,{id:"6-usb-device-\u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784",children:"6. USB Device \u5b50\u7cfb\u7edf\u4ee3\u7801\u67b6\u6784"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_flow_detail1-170676467857865.png",alt:"image0"})}),"\n",(0,i.jsx)(n.p,{children:"\u6574\u4e2a USB \u7cfb\u7edf\u7684\u901a\u8baf\u6a21\u578b\u5982\u4e0a\u56fe\u6240\u793a\uff0cDevice \u6846\u67b6\u89c1\u53f3\u4fa7\u5f69\u56fe\u90e8\u5206\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"61-usb-device-controller-layer",children:"6.1. USB Device Controller Layer"}),"\n",(0,i.jsx)(n.p,{children:"\u4e0a\u8ff0\u8f6f\u4ef6\u6808\u7684\u6700\u5e95\u5c42\u662f UDC (USB Device Controller)\uff0cUDC \u5c42\u6700\u4e3b\u8981\u7684\u4f5c\u7528\u662f\u63d0\u4f9b\u4e00\u4e2a endpoint \u8d44\u6e90\u6c60\uff0c\u8d1f\u8d23\u5904\u7406 endpoint \u5c42\u7ea7\u7684\u6570\u636e\u6536\u53d1\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"611-aic-usb-device-controller",children:"6.1.1. AIC USB Device Controller"}),"\n",(0,i.jsx)(n.p,{children:"ArtinChip UDC \u5728\u786c\u4ef6\u5c42\u9762\u5b9e\u73b0\u4e86\u4ee5\u4e0b\u529f\u80fd\uff1a"}),"\n",(0,i.jsx)(n.h5,{id:"6111-data-mode",children:"6.1.1.1. Data Mode"}),"\n",(0,i.jsx)(n.p,{children:"UDC \u5b9e\u73b0\u7684\u4e00\u9879\u4e3b\u8981\u5de5\u4f5c\u662f\u6570\u636e\u642c\u79fb\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"UDC \u53d1\u9001\u65f6\uff0c\u6570\u636e\u5148\u4ece\u5185\u5b58 Memory \u642c\u79fb\u5230 UDC \u7684\u5185\u90e8 FIFO \u5f53\u4e2d\uff0c\u7136\u540e\u7531 UDC \u53d1\u9001\u5230 USB \u7269\u7406\u7ebf\u8def\u4e0a\u3002"}),"\n",(0,i.jsx)(n.li,{children:"UDC \u63a5\u6536\u65f6\uff0c\u6570\u636e\u5148\u4ece USB \u7269\u7406\u7ebf\u8def\u63a5\u6536\u5230 UDC \u7684\u5185\u90e8 FIFO \u5f53\u4e2d\uff0c\u7136\u540e\u518d\u4ece FIFO \u62f7\u8d1d\u5230 \u5185\u5b58 Memory \u5f53\u4e2d\u3002"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u5bf9\u4e8e ",(0,i.jsx)(n.code,{children:"FIFO"})," \u548c ",(0,i.jsx)(n.code,{children:"Memory"})," \u4e4b\u95f4\u7684\u6570\u636e\u642c\u79fb\u5de5\u4f5c\uff0c\u5f53\u524d UDC \u652f\u6301\u4e24\u79cd\u65b9\u5f0f\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"DMA Mode\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_mode_dma-170676470897567.png",alt:"image1"})}),"\n",(0,i.jsx)(n.p,{children:"\u7531 UDC \u5185\u90e8\u7684 DMA \u6a21\u5757\u6765\u627f\u62c5\u6570\u636e\u642c\u79fb\u5de5\u4f5c\uff0c\u53ea\u8981\u4f7f\u7528\u5bc4\u5b58\u5668\u914d\u7f6e\u597d FIFO \u7684\u5206\u914d\uff0c\u4ee5\u53ca\u5728\u5bc4\u5b58\u5668\u4e2d\u914d\u7f6e\u597d DMA \u7684\u5176\u5b9e\u5730\u5740\uff0cDMA \u4f1a\u5b8c\u6210\u6570\u636e\u7684\u642c\u79fb\u3002"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Slave Mode\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_mode_slave-170676471760269.png",alt:"image2"})}),"\n",(0,i.jsx)(n.p,{children:"\u4e5f\u53ef\u4ee5\u4e0d\u4f7f\u7528 DMA \u800c\u76f4\u63a5\u4f7f\u7528 CPU \u6765\u642c\u79fb\uff0c\u8fd9\u79cd\u65b9\u5f0f\u975e\u5e38\u6d88\u8017 CPU \u7684\u5e26\u5bbd\uff0cCPU \u88ab\u7b80\u5355\u91cd\u590d\u7684\u6570\u636e\u62f7\u8d1d\u62d6\u4f4f\u4e0d\u80fd\u505a\u5176\u4ed6\u7684\u4e8b\u60c5\u3002\u8fd9\u79cd\u65b9\u5f0f\u4e00\u822c\u7528\u4e8e Debug \u6a21\u5f0f\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"6112-endpoint-fifo-mode",children:"6.1.1.2. Endpoint FIFO Mode"}),"\n",(0,i.jsxs)(n.p,{children:["\u4e0d\u540c\u7684 UDC \u4e2d Endpoint \u5bf9 FIFO \u7684\u4f7f\u7528\u6709\u591a\u79cd\u6a21\u5f0f\uff0c\u5f53\u524d UDC \u9009\u7528\u7684\u662f ",(0,i.jsx)(n.code,{children:"Shared Transmit FIFO"})," \u6a21\u5f0f\u3002\u5728 ",(0,i.jsx)(n.code,{children:"Shared Transmit FIFO"})," \u6a21\u5f0f\u4e2d\uff0c ",(0,i.jsx)(n.code,{children:"Endpoint"})," \u5bf9 ",(0,i.jsx)(n.code,{children:"FIFO"})," \u4f7f\u7528\u6a21\u5f0f\u5982\u4e0b\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u6240\u6709\u7684 ",(0,i.jsx)(n.code,{children:"non-periodic IN endpoints"})," \u5171\u4eab\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"transmit FIFO"})," \u3002 ",(0,i.jsx)(n.code,{children:"non-periodic endpoints"})," \u5305\u62ec ",(0,i.jsx)(n.code,{children:"isochronous transfers"})," \u548c ",(0,i.jsx)(n.code,{children:"interrupt transfers"}),"\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["\u6bcf\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"periodic IN endpoint"})," \u72ec\u7acb\u62e5\u6709\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"transmit FIFO"})," \u3002 ",(0,i.jsx)(n.code,{children:"periodic endpoints"})," \u5305\u62ec ",(0,i.jsx)(n.code,{children:"bulk transfers"})," \u548c ",(0,i.jsx)(n.code,{children:"control transfers"}),"\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["\u6240\u6709\u7684 ",(0,i.jsx)(n.code,{children:"OUT endpoints"})," \u5171\u4eab\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"receive FIFO"}),"\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"6113-endpoint-resource",children:"6.1.1.3. Endpoint Resource"}),"\n",(0,i.jsx)(n.p,{children:"USB \u534f\u8bae\u5b9a\u4e49\u4e00\u4e2a Device \u6700\u591a\u53ef\u4ee5\u5b9e\u73b0 16 \u4e2a IN endpoint + 16 \u4e2a OUT endpoint\u3002\u5f53\u524d UDC \u5b9e\u73b0\u4e86 5 \u4e2a IN endpoint + 5 \u4e2a OUT endpoint\uff0c\u9664\u4e86 endpoint 0 IN/OUT \u88ab\u7cfb\u7edf\u9ed8\u8ba4\u4f7f\u7528\uff0c\u5269\u4e0b\u7684\u53ef\u4ee5\u88ab\u9a71\u52a8\u52a8\u6001\u5206\u914d\u4f7f\u7528\u3002"}),"\n",(0,i.jsxs)(n.p,{children:["\u5982\u4e0a\u4e00\u8282\u6240\u63cf\u8ff0\uff0cUDC \u662f ",(0,i.jsx)(n.code,{children:"Shared Transmit FIFO"})," \u6a21\u5f0f\uff0c ",(0,i.jsx)(n.code,{children:"periodic IN endpoint"})," \u9700\u8981\u62e5\u6709\u4e00\u4e2a\u72ec\u7acb\u7684 ",(0,i.jsx)(n.code,{children:"transmit FIFO"}),"\u3002\u5f53\u524d UDC \u62e5\u6709\u4e24\u4e2a\u8fd9\u6837\u7684 ",(0,i.jsx)(n.code,{children:"transmit FIFO"})," \u8d44\u6e90\uff0c\u4f9b\u9a71\u52a8\u52a8\u6001\u5206\u914d\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:["\u5982\u679c\u9a71\u52a8\u521b\u5efa\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"periodic IN endpoint"})," \u5b83\u5206\u914d\u5230\u4e86\u7b2c\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"endpoint"})," \u8d44\u6e90\uff0c\u4f46\u662f\u6ca1\u6709\u5206\u914d\u5230 ",(0,i.jsx)(n.code,{children:"transmit FIFO"})," \u8d44\u6e90\uff0c\u4e5f\u4f1a\u521b\u5efa\u5931\u8d25\u3002"]}),"\n",(0,i.jsx)(n.h5,{id:"6114-calculating-fifo-size",children:"6.1.1.4. Calculating FIFO Size"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_fifo_size-170676474040571.png",alt:"image3"})}),"\n",(0,i.jsx)(n.p,{children:"\u7531\u4e0a\u51e0\u8282\u7684\u63cf\u8ff0\u53ef\u4ee5\u770b\u5230\uff0cUDC \u6709\u591a\u4e2a\u6a21\u5757\u9700\u8981\u4f7f\u7528\u5185\u90e8 FIFO\u3002\u5305\u62ec\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"OUT endpoints RxFIFO"}),"\n",(0,i.jsx)(n.li,{children:"IN non-periodic endpoints TxFIFO"}),"\n",(0,i.jsx)(n.li,{children:"IN periodic endpoints TxFIFO"}),"\n",(0,i.jsx)(n.li,{children:"DMA"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"UDC \u5185\u90e8 FIFO \u603b\u5927\u5c0f\u662f\u56fa\u5b9a\u7684\uff0c\u90a3\u4e48\u600e\u4e48\u6837\u6765\u5206\u914d FIFO \u7a7a\u95f4\u7ed9\u8fd9\u4e9b\u6a21\u5757\u5462\uff1f UDC \u63d0\u4f9b\u4e86\u4ee5\u4e0b\u8ba1\u7b97\u516c\u5f0f\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Receive FIFO RAM allocation"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"RAM for SETUP Packets: 4 * n + 6 locations in Scatter/Gather DMA mode and 5 * n+6 locations in Slave and Buffer DMA mode must be reserved in the RxFIFO to receive up to n SETUP packets on control endpoints, where n is the number of control endpoints the device core supports. The core does not use these locations, which are Reserved for SETUP packets, to write any other data."}),"\n",(0,i.jsx)(n.p,{children:"// Setup \u5305\u7684\u4fdd\u7559 RAM \u7a7a\u95f4(DMA \u6a21\u5f0f)\uff1a 5*n + 6 locations\uff0cn \u4e3a control endpoints \u7684\u4e2a\u6570\u3002\u8be5\u90e8\u5206\u53ea\u4e3a SETUP \u5305\u4fdd\u7559\uff0c\u4e0d\u4f1a\u5199\u5165\u5176\u4ed6\u6570\u636e\u3002"}),"\n",(0,i.jsx)(n.p,{children:"One location for Global OUT NAK"}),"\n",(0,i.jsx)(n.p,{children:"// Global OUT NAK: 1 location"}),"\n",(0,i.jsx)(n.p,{children:"Status information is written to the FIFO along with each received packet. Therefore, a minimum space of (Largest Packet Size / 4) + 1 must be allotted to receive packets. If a high-bandwidth endpoint is enabled, or multiple isochronous endpoints are enabled, then at least two (Largest Packet Size / 4) + 1 spaces must be allotted to receive back-to-back packets. Typically, two (Largest Packet Size / 4) + 1 spaces are recommended so that when the previous packet is being transferred to AHB, the USB can receive the subsequent packet. If AHB latency is high, you must allocate enough space to receive multiple packets. This is critical to prevent dropping of any isochronous packets."}),"\n",(0,i.jsx)(n.p,{children:"// \u5305\u63a5\u6536\u7a7a\u95f4\uff1a \u6700\u5c11 (Largest Packet Size / 4) + 1 spaces\uff0c\u5982\u679c\u7a7a\u95f4\u5145\u88d5\u4f7f\u7528 two (Largest Packet Size / 4) + 1 spaces"}),"\n",(0,i.jsx)(n.p,{children:"Along with each endpoint\u2019s last packet, transfer complete status information is also pushed to the FIFO. Typically, one location for each OUT endpoint is recommended."}),"\n",(0,i.jsx)(n.p,{children:"// \u5bf9\u4e8e\u6bcf\u4e2a OUT endpoint \uff0c\u6700\u540e\u4e00\u4e2a\u5305\u9700\u8981\u4e00\u4e2a\u4f4d\u7f6e\u5b58\u653e transfer complete status information"}),"\n",(0,i.jsx)(n.p,{children:"An additional endpoint for each EPDisable is also required."}),"\n",(0,i.jsx)(n.p,{children:"// \u5bf9\u4e8e\u6bcf\u4e2a OUT endpoint \uff0c\u8fd8\u9700\u8981\u4e00\u4e2a\u4f4d\u7f6e\u5b58\u653e EPDisable"}),"\n",(0,i.jsx)(n.p,{children:"\u8ba1\u7b97\u516c\u5f0f\uff1a"}),"\n",(0,i.jsx)(n.p,{children:"Device RxFIFO = (5 * number of control endpoints + 8) + ((largest USB packet used / 4) + 1 for status information) + (2 * number of OUT endpoints) + 1 for Global NAK"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Transmit FIFO RAM allocation"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"The RAM size for the Periodic Transmit FIFO must equal the maximum amount of data that can be transmitted in a single microframe. The core does not use any data RAM allocated over this requirement, and when data RAM allocated is less than this requirement, the core can malfunction."}),"\n",(0,i.jsx)(n.p,{children:"// Periodic Transmit FIFO RAM\u5927\u5c0f\u5fc5\u987b\u7b49\u4e8e\u5728\u5355\u4e2a\u5fae\u5e27\u4e2d\u53ef\u4ee5\u4f20\u8f93\u7684\u6700\u5927\u6570\u636e\u91cf\u3002\u6838\u5fc3\u4e0d\u4f7f\u7528\u4efb\u4f55\u5206\u914d\u7ed9\u8fd9\u4e2a\u9700\u6c42\u7684\u6570\u636eRAM\uff0c\u5f53\u5206\u914d\u7684\u6570\u636eRAM\u5c0f\u4e8e\u8fd9\u4e2a\u9700\u6c42\u65f6\uff0c\u6838\u5fc3\u53ef\u80fd\u4f1a\u53d1\u751f\u6545\u969c\u3002"}),"\n",(0,i.jsx)(n.p,{children:"The minimum amount of RAM required for the Non-periodic Transmit FIFO is the largest maximum packet size among all supported non-periodic IN endpoints."}),"\n",(0,i.jsx)(n.p,{children:"// Non-periodic Transmit FIFO \u6700\u5c0fRAM\u6570\u91cf\u662f\u6240\u6709\u652f\u6301\u7684\u975e\u5468\u671fIN\u7aef\u70b9\u4e2d\u6700\u5927\u7684\u5305\u5927\u5c0f\u3002"}),"\n",(0,i.jsx)(n.p,{children:"More space allocated in the Transmit Non-periodic FIFO results in better performance on the USB and can hide AHB latencies. Typically, two Largest Packet Sizes\u2019 worth of space is recommended, so that when the current packet is under transfer to the USB, the AHB can get the next packet. If the AHB latency is large, then you must allocate enough space to buffer multiple packets."}),"\n",(0,i.jsx)(n.p,{children:"// Transmit Non-periodic FIFO \u4e2d\u5206\u914d\u66f4\u591a\u7684\u7a7a\u95f4\uff0c\u53ef\u4ee5\u5728USB\u4e0a\u83b7\u5f97\u66f4\u597d\u7684\u6027\u80fd\uff0c\u5e76\u53ef\u4ee5\u9690\u85cfAHB\u5ef6\u8fdf\u3002\u901a\u5e38\uff0c\u5efa\u8bae\u4f7f\u7528\u4e24\u4e2a\u6700\u5927\u5305\u5927\u5c0f\u7684\u7a7a\u95f4\uff0c\u4ee5\u4fbf\u5f53\u5f53\u524d\u5305\u6b63\u5728\u4f20\u8f93\u5230USB\u65f6\uff0cAHB\u53ef\u4ee5\u83b7\u5f97\u4e0b\u4e00\u4e2a\u5305\u3002\u5982\u679cAHB\u5ef6\u8fdf\u8f83\u5927\uff0c\u5219\u5fc5\u987b\u5206\u914d\u8db3\u591f\u7684\u7a7a\u95f4\u6765\u7f13\u51b2\u591a\u4e2a\u5305\u3002"}),"\n",(0,i.jsx)(n.p,{children:"It is assumed that i number of periodic FIFOs is implemented in Device mode."}),"\n",(0,i.jsx)(n.p,{children:"// i \u662f periodic FIFOs \u7684\u4e2a\u6570\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u8ba1\u7b97\u516c\u5f0f\uff1a"}),"\n",(0,i.jsx)(n.p,{children:"Non-Periodic TxFIFO = largest non-periodic USB packet used / 4"}),"\n",(0,i.jsx)(n.p,{children:"Periodic Endpoint-Specific TxFIFOs= largest periodic USB packet used for an endpoint / 4"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Internal Register Storage Space Allocation"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"When operating in Internal DMA mode, the core stores the Endpoint DMA address register (DI/OEPDMA) in the SPRAM. One location must be allocated for each endpoint."}),"\n",(0,i.jsx)(n.p,{children:"// \u5f53\u5728\u5185\u90e8DMA\u6a21\u5f0f\u4e0b\u8fd0\u884c\u65f6\uff0c\u6838\u5fc3\u5c06\u7aef\u70b9DMA\u5730\u5740\u5bc4\u5b58\u5668(DI/OEPDMA)\u5b58\u50a8\u5728SPRAM\u4e2d\u3002\u5fc5\u987b\u4e3a\u6bcf\u4e2a\u7aef\u70b9\u5206\u914d\u4e00\u4e2a\u4f4d\u7f6e\u3002"}),"\n",(0,i.jsx)(n.p,{children:"For example, if an endpoint is bidirectional, then two locations must be allocated. If an endpoint is IN or OUT, then only one location must be allocated."}),"\n",(0,i.jsx)(n.p,{children:"// \u4f8b\u5982\uff0c\u5982\u679c\u4e00\u4e2a\u7aef\u70b9\u662f\u53cc\u5411\u7684\uff0c\u90a3\u4e48\u5fc5\u987b\u5206\u914d\u4e24\u4e2a\u4f4d\u7f6e\u3002\u5982\u679c\u7aef\u70b9\u662fIN\u6216OUT\uff0c\u5219\u5fc5\u987b\u53ea\u5206\u914d\u4e00\u4e2a\u4f4d\u7f6e\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Example"})}),"\n",(0,i.jsxs)(n.p,{children:["The MPS is 1,024 bytes for a ",(0,i.jsx)(n.code,{children:"periodic USB packet"})," and 512 bytes for a ",(0,i.jsx)(n.code,{children:"non-periodic USB packet"}),". There are three ",(0,i.jsx)(n.code,{children:"OUT endpoints"}),", three ",(0,i.jsx)(n.code,{children:"IN endpoints"}),", one ",(0,i.jsx)(n.code,{children:"control endpoint"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Device RxFIFO = (5 * 1 + 8) + ((1,024 / 4) +1) + (2 * 4) + 1 = 279\nNon-Periodic TxFIFO = (512 / 4) = 128\nDevice Periodic TxFIFO:\n EP 1 = (1,024 / 4) = 256\n EP 2 = (1,024 / 4) = 256\n EP 3 = (1,024 / 4) = 256\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"\u5f53\u524d UDC"})}),"\n",(0,i.jsxs)(n.p,{children:["The MPS is 1,024 bytes for a ",(0,i.jsx)(n.code,{children:"periodic USB packet"})," and 1024 bytes for a ",(0,i.jsx)(n.code,{children:"non-periodic USB packet"}),". There are 4 ",(0,i.jsx)(n.code,{children:"OUT endpoints"}),", 4 ",(0,i.jsx)(n.code,{children:"IN endpoints"}),", 1 ",(0,i.jsx)(n.code,{children:"control endpoint"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Device RxFIFO = (5 * 1 + 8) + ((1,024 / 4) +1) + (2 * 5) + 1 = 281 = 0x119\nNon-Periodic TxFIFO = (1024 / 4) = 256 = 0x100\nDevice Periodic TxFIFO:\n EP 1 = (1,024 / 4) = 256 = 0x100\n EP 2 = remain space = 0x3F6 - 0x119 - 0x100 - 0x100 = 0xDD\nInternal Register Storage Space = 5 * 2 = 10 = 0xA\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u6216\u8005\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Device RxFIFO = (5 * 1 + 8) + ((1,024 / 4) +1) + (2 * 5) + 1 = 281 = 0x119\nNon-Periodic TxFIFO = (1024 / 4) = 256 = 0x200\nDevice Periodic TxFIFO:\n EP 1 = (0x3F6 - 0x119 - 0x200) / 2 = 0x6E\n EP 2 = (0x3F6 - 0x119 - 0x200) / 2 = 0x6E\nInternal Register Storage Space = 5 * 2 = 10 = 0xA\n"})}),"\n",(0,i.jsx)(n.h5,{id:"6115-fifo-mapping",children:"6.1.1.5. FIFO Mapping"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_fifo_mapping-170676477619873.png",alt:"image4"})}),"\n",(0,i.jsx)(n.p,{children:"\u7531\u4e0a\u51e0\u8282\u53ef\u77e5\u5bf9\u4e00\u4e2a\u7aef\u70b9 Endpoint \u6765\u8bf4\uff0c\u5b83\u5bf9\u5e94\u7684 FIFO \u662f\u52a8\u6001\u5206\u914d\u7684\u3002\u5728 DMA \u6a21\u5f0f\u4e0b\uff0c\u4e00\u65e6\u521d\u59cb\u5316\u65f6\u914d\u7f6e\u5b8c\u6210\u5c31\u4e0d\u7528\u518d\u53bb\u7ba1 Endpoint FIFO \u7684\u5730\u5740\u3002\u4f46\u662f\u5bf9 Slave \u6a21\u5f0f\u6765\u8bf4\uff0c\u5728\u6570\u636e\u6536\u53d1\u8fc7\u7a0b\u4e2d\u9700\u8981 CPU \u8bbf\u95ee\u5bf9\u5e94 FIFO \u7a7a\u95f4\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u4e3a\u4e86\u65b9\u4fbf CPU \u5bf9 Endpoint FIFO \u7684\u8bbf\u95ee\uff0cUDC \u628a Endpoint FIFO \u6620\u5c04\u5230\u4e86\u56fa\u5b9a\u5730\u5740\u3002\u5176\u4e2d\u8bfb\u64cd\u4f5c\u4f1a\u6620\u5c04\u5230 OUT Endpoint FIFO\uff0c\u5199\u64cd\u4f5c\u4f1a\u6620\u5c04\u5230 IN Endpoint FIFO\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"6116-interrupt-cascade",children:"6.1.1.6. Interrupt Cascade"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_interrupt-170676478596475.png",alt:"image5"})}),"\n",(0,i.jsx)(n.p,{children:"\u7531\u4e8e UDC \u7684\u4e2d\u65ad\u72b6\u6001\u8f83\u591a\uff0c\u6240\u4ee5\u5206\u6210 3 \u7ea7\u7ea7\u8054\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["layer1: ",(0,i.jsx)(n.code,{children:"GINTSTS"})," & ",(0,i.jsx)(n.code,{children:"GINTMSK"})," \u3002\u5168\u5c40\u4e2d\u65ad\uff0c\u6bcf\u4e00 bit \u8868\u793a\u4e00\u4e2a\u5168\u5c40\u4e2d\u65ad\u72b6\u6001\u3002\u5176\u4e2d\uff1a ",(0,i.jsx)(n.code,{children:"OEPInt"})," \u8868\u793a\u6709 ",(0,i.jsx)(n.code,{children:"Out Endpoint"})," \u4e2d\u65ad\u53d1\u751f \uff0c ",(0,i.jsx)(n.code,{children:"IEPInt"})," \u8868\u793a\u6709 ",(0,i.jsx)(n.code,{children:"In Endpoint"})," \u4e2d\u65ad\u53d1\u751f\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["layer2: ",(0,i.jsx)(n.code,{children:"DAINT"})," & ",(0,i.jsx)(n.code,{children:"DAINTMSK"})," \u3002Endpoint \u4e2d\u65ad\uff0c\u6bcf\u4e00 bit \u8868\u793a\u4e00\u4e2a Endpoint \u53d1\u751f\u4e86\u4e2d\u65ad\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["layer3: ",(0,i.jsx)(n.code,{children:"DOEPINTn"})," & ",(0,i.jsx)(n.code,{children:"DOEPMSK"})," \uff0c ",(0,i.jsx)(n.code,{children:"DIEPINTn"})," & ",(0,i.jsx)(n.code,{children:"DIEPMSK"})," \u3002Endpoint \u4e2d\u65ad\u7ec6\u8282\uff0c\u6bcf\u4e00\u4e2a Endpoint \u62e5\u6709\u4e00\u7ec4\u8fd9\u6837\u7684\u5bc4\u5b58\u5668\u3002 \u5bc4\u5b58\u5668\u4e2d\u7684\u6bcf\u4e00 bit \u4ee3\u8868\u67d0\u4e2a Endpoint \u7684\u67d0\u79cd\u4e2d\u65ad\u72b6\u6001\u3002"]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"6117-data-transfer",children:"6.1.1.7. Data Transfer"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_trandfer-170676480019777.png",alt:"image6"})}),"\n",(0,i.jsx)(n.p,{children:"UDC \u5185\u90e8\u7684\u6570\u636e\u6536\u53d1\u6d41\u7a0b\u5982\u4e0a\u56fe\u6240\u793a\u3002\u4e3b\u8981\u7684\u5de5\u4f5c\u5c31\u662f\u6839\u636e USB \u63a5\u6536\u5230\u7684\u8bfb\u5199\u6307\u4ee4\uff0c\u628a\u6570\u636e\u5728 FIFO \u548c Memory \u4e4b\u95f4\u8fdb\u884c\u642c\u79fb\u3002\u5177\u4f53\u5206\u4e3a\u51e0\u79cd\u60c5\u51b5\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["OUT Endpoint\u3002\u6240\u6709 OUT Endpoint \u7684\u7ebf\u8def\u6570\u636e\u4f1a\u63a5\u6536\u5230\u4e00\u4e2a\u7edf\u4e00\u7684 ",(0,i.jsx)(n.code,{children:"Rx FIFO"})," \u5f53\u4e2d\uff0c\u7136\u540e\u6839\u636e\u63a5\u6536\u6570\u636e\u7684\u5177\u4f53 Endpoint\u914d\u7f6e\u7684 Memory \u5730\u5740\u548c\u957f\u5ea6\uff0cDMA \u628a\u6570\u636e\u4ece FIFO \u642c\u79fb\u5230\u5bf9\u5e94 Memory \u5f53\u4e2d\uff0c\u6700\u540e\u4ea7\u751f\u4e2d\u65ad\u3002"]}),"\n",(0,i.jsxs)(n.li,{children:["IN Non-period Endpoint\u3002\u6240\u6709 IN Non-period Endpoint \u5171\u4eab\u4e00\u4e2a\u7edf\u4e00\u7684 ",(0,i.jsx)(n.code,{children:"Tx Non-period FIFO"})," \uff0c\u6839\u636eEndpoint\u914d\u7f6e\u7684 Memory \u5730\u5740\u548c\u957f\u5ea6\uff0cDMA \u628a\u6570\u636e\u4ece Memory \u642c\u79fb\u5230\u7edf\u4e00\u7684 FIFO \u5f53\u4e2d\uff0c\u53d1\u9001\u5230\u7ebf\u8def\u4e0a\u540e\u4ea7\u751f\u4e2d\u65ad\u3002IN Non-period Endpoint \u9700\u8981\u914d\u7f6e ",(0,i.jsx)(n.code,{children:"Next Endpoint"})," \u6307\u9488\uff0c\u8fd9\u6837 DMA\u5904\u7406\u5b8c\u4e00\u4e2a Endpoint \u7684\u6570\u636e\u540e\u624d\u77e5\u9053\u4e0b\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684 Endpoint\u3002"]}),"\n",(0,i.jsx)(n.li,{children:"IN Period Endpoint\u3002\u6bcf\u4e00\u4e2a IN Period Endpoint \u62e5\u6709\u81ea\u5df1\u72ec\u7acb\u7684 FIFO\uff0c\u6839\u636eEndpoint\u914d\u7f6e\u7684 Memory \u5730\u5740\u548c\u957f\u5ea6\uff0cDMA \u628a\u6570\u636e\u4ece Memory \u642c\u79fb\u5230\u5bf9\u5e94\u7684 FIFO \u5f53\u4e2d\uff0c\u53d1\u9001\u5230\u7ebf\u8def\u4e0a\u540e\u4ea7\u751f\u4e2d\u65ad\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"612-aic-udc-driver",children:"6.1.2. AIC UDC Driver"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"UDC Driver"})," \u5728\u9700\u8981\u5b8c\u6210\u7684\u5de5\u4f5c\u6709\u4e24\u70b9\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u628a UDC \u786c\u4ef6\u6ce8\u518c\u6210\u6807\u51c6\u7684 Gadget Device\uff0c\u4ee5\u4fbf\u63d0\u4f9b\u6807\u51c6\u7684 Gadget API \u7ed9 Gadget Function \u9a71\u52a8\u6765\u4f7f\u7528\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u63d0\u4f9b endpoint \u8d44\u6e90\u6c60\uff0c\u5904\u7406 endpoint \u5c42\u7ea7\u7684\u6570\u636e\u6536\u53d1\u3002"}),"\n",(0,i.jsx)(n.li,{children:"\u9700\u8981\u5904\u7406\u90e8\u5206 Endpoint0 Setup \u903b\u8f91\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"6121-init",children:"6.1.2.1. Init"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_init-170676481980279.png",alt:"image7"})}),"\n",(0,i.jsx)(n.p,{children:"UDC \u9a71\u52a8\u628a\u8d44\u6e90\u521d\u59cb\u5316\u597d\u4ee5\u540e\uff0c\u6ce8\u518c\u6210\u4e00\u4e2a\u6807\u51c6\u7684 gadget \u8bbe\u5907\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"6122-gadgetops",children:"6.1.2.2. gadget.ops"}),"\n",(0,i.jsxs)(n.p,{children:["UDC \u9a71\u52a8\u9700\u8981\u63d0\u4f9b gadget \u8bbe\u5907\u7684\u64cd\u4f5c\u51fd\u6570\u96c6 ",(0,i.jsx)(n.code,{children:"gadget.ops"}),"\u3002\u7b80\u5355\u5b9a\u4e49\u5982\u4e0b\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static const struct usb_gadget_ops aic_usb_gadget_ops = {\n    .get_frame              = aic_gg_getframe,\n    .udc_start              = aic_gg_udc_start,\n    .udc_stop               = aic_gg_udc_stop,\n    .pullup                 = aic_gg_pullup,\n    .vbus_session           = aic_gg_vbus_session,\n    .vbus_draw              = aic_gg_vbus_draw,\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5176\u4e2d\u7684\u6838\u5fc3\u51fd\u6570\u4e3a ",(0,i.jsx)(n.code,{children:".udc_start()"})," \uff0c\u5728\u8c03\u7528\u8be5\u51fd\u6570\u4ee5\u540e UDC \u624d\u771f\u6b63\u8fdb\u5165\u5de5\u4f5c\u72b6\u6001\u3002\u5176\u4e3b\u8981\u6d41\u7a0b\u5982\u4e0b\uff1a"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_start-170676484417081.png",alt:"image8"})}),"\n",(0,i.jsx)(n.h5,{id:"6123-epops",children:"6.1.2.3. ep.ops"}),"\n",(0,i.jsxs)(n.p,{children:["UDC \u9a71\u52a8\u9700\u8981\u63d0\u4f9b endpoint \u7684\u64cd\u4f5c\u51fd\u6570\u96c6 ",(0,i.jsx)(n.code,{children:"ep.ops"}),"\u3002\u7b80\u5355\u5b9a\u4e49\u5982\u4e0b\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static const struct usb_ep_ops aic_usb_ep_ops = {\n    .enable                 = aic_ep_enable,\n    .disable                = aic_ep_disable,\n    .alloc_request          = aic_ep_alloc_request,\n    .free_request           = aic_ep_free_request,\n    .queue                  = aic_ep_queue_request,\n    .dequeue                = aic_ep_dequeue_request,\n    .set_halt               = aic_ep_sethalt,\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5176\u4e2d ",(0,i.jsx)(n.code,{children:".queue()"})," \u51fd\u6570\u8d1f\u8d23\u63a5\u6536 Gadget Function \u9a71\u52a8\u53d1\u9001\u4e0b\u6765\u7684 ",(0,i.jsx)(n.code,{children:"usb_request"}),"\u3002\u5176\u4e3b\u8981\u6d41\u7a0b\u5982\u4e0b\uff1a"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_queue-170676485559783.png",alt:"image9"})}),"\n",(0,i.jsx)(n.h5,{id:"6124-interrupt",children:"6.1.2.4. Interrupt"}),"\n",(0,i.jsxs)(n.p,{children:["UDC \u9a71\u52a8\u4e3b\u8981\u627f\u62c5\u7684\u662f\u6570\u636e\u6536\u53d1\uff0c\u5728\u4e0a\u4e00\u8282\u6536\u5230 ",(0,i.jsx)(n.code,{children:"usb_request"})," \u8bf7\u6c42\u4ee5\u540e\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u7b49\u5f85\u786c\u4ef6\u5904\u7406\u5b8c\u6210\u4ea7\u751f\u4e2d\u65ad\u4e86\u3002\u4e2d\u65ad\u5904\u7406\u7684\u4e3b\u8981\u6d41\u7a0b\u5982\u4e0b\uff1a"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_interrupt_flow-170676486451685.png",alt:"image10"})}),"\n",(0,i.jsx)(n.h5,{id:"6125-ep0-setup",children:"6.1.2.5. EP0 Setup"}),"\n",(0,i.jsxs)(n.p,{children:["UDC \u9a71\u52a8\u8fd8\u6709\u4e00\u9879\u91cd\u8981\u5de5\u4f5c\u5c31\u662f\u8d1f\u8d23 EP0 Control \u72b6\u6001\u673a\u7684\u5904\u7406\u3002USB ep0 \u4e0a\u7684 Control Transfer \u5904\u7406\u5206\u4e3a3\u4e2a\u9636\u6bb5\uff1a ",(0,i.jsx)(n.code,{children:"Setup Stage"})," \u3001 ",(0,i.jsx)(n.code,{children:"Data In/Out Stage"})," \u3001 ",(0,i.jsx)(n.code,{children:"Status In/Out Stage"})," \u3002\u5177\u4f53\u5bf9\u5e94\u4ee5\u4e0b 5 \u79cd\u72b6\u6001\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* Gadget ep0 states */\nenum ep0_state {\n    EP0_SETUP,\n    EP0_DATA_IN,\n    EP0_DATA_OUT,\n    EP0_STATUS_IN,\n    EP0_STATUS_OUT,\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u8fd9\u51e0\u79cd\u72b6\u6001\u4e4b\u95f4\u7684\u8f6c\u6362\u6d41\u7a0b\u5982\u4e0b\u6240\u793a\uff1a"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://photos.100ask.net/artinchip-docs/d213-devkit/usb_udc_ep0_control-170676488914487.png",alt:"image11"})}),"\n",(0,i.jsx)(n.h3,{id:"62-usb-device-layer",children:"6.2. USB Device Layer"}),"\n",(0,i.jsxs)(n.p,{children:["Linux \u4f7f\u7528\u4e86\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Gadget"})," \u7684\u6982\u5ff5\u6765\u7ec4\u7ec7 USB Device\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"Gadget Layer \u5c42\u628a UDC \u63d0\u4f9b\u7684 endpoint \u5c01\u88c5\u6210\u6807\u51c6\u7684 Gadget Device\uff0c\u63d0\u4f9b\u7edf\u4e00\u7684\u5411\u4e0a\u63a5\u53e3\u3002"}),"\n",(0,i.jsx)(n.p,{children:"Gadget Driver \u53c8\u628a\u5404\u5f0f\u5404\u6837\u7684 Function \u548c Gadget Device \u94fe\u63a5\u8d77\u6765\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"621-gadget-bus",children:"6.2.1. Gadget Bus"}),"\n",(0,i.jsx)(n.p,{children:"Gadget Layer \u5c42\u6ca1\u6709\u5b9a\u4e49\u4e00\u4e2a\u6807\u51c6\u7684 Bus \u603b\u7ebf\uff0c\u800c\u662f\u81ea\u5b9a\u4e49\u4e86\u4e24\u6761\u94fe\u8868\u6765\u5206\u522b\u5b58\u50a8 Device \u548c Driver\uff1a"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"list"}),(0,i.jsx)(n.th,{children:"escript"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Device"}),(0,i.jsx)(n.td,{children:"udc_list"}),(0,i.jsx)(n.td,{children:"\u6240\u6709Device\u5168\u96c6"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Driver"}),(0,i.jsx)(n.td,{children:"gadget_driver_pending_list"}),(0,i.jsx)(n.td,{children:"\u53ea\u5305\u542b\u6ca1\u6709\u9002\u914dDevice\u7684Driver"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"\u5b83\u4eec\u7684\u4f7f\u7528\u573a\u666f\u5982\u4e0b\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u5728 Gadget Device \u521b\u5efa\u65f6\uff0c\u9996\u5148\u628a Device \u52a0\u5165\u5230 ",(0,i.jsx)(n.code,{children:"udc_list"})," \u94fe\u8868\uff0c\u7136\u540e\u5c1d\u8bd5\u548c ",(0,i.jsx)(n.code,{children:"gadget_driver_pending_list"})," \u94fe\u8868\u4e2d\u7684 Driver \u8fdb\u884c match():"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_add_gadget_udc() \u2192 usb_add_gadget_udc_release() \u2192 usb_add_gadget():\n\nint usb_add_gadget(struct usb_gadget *gadget)\n{\n\n    /* (1) \u5c06 device \u52a0\u5165\u5168\u5c40\u94fe\u8868 */\n    list_add_tail(&udc->list, &udc_list);\n\n    /* pick up one of pending gadget drivers */\n    /* (2) \u5c1d\u8bd5 match gadget \u7684 device \u548c driver */\n    ret = check_pending_gadget_drivers(udc);\n    if (ret)\n        goto err_del_udc;\n\n    mutex_unlock(&udc_lock);\n}\n\n\u2193\n\nstatic int check_pending_gadget_drivers(struct usb_udc *udc)\n{\n    struct usb_gadget_driver *driver;\n    int ret = 0;\n\n    /* (2.1) \u904d\u5386 `gadget_driver_pending_list` \u94fe\u8868\u4e2d\u7684 Driver\uff0c\u548c Device \u8fdb\u884c match()\n            \u4e14\u4e00\u4e2a Driver \u53ea\u80fd match \u4e00\u4e2a Device\uff0cDriver match \u6210\u529f\u540e\u4f1a\u4ece\u94fe\u8868\u5220\u9664\n    */\n    list_for_each_entry(driver, &gadget_driver_pending_list, pending)\n        if (!driver->udc_name || strcmp(driver->udc_name,\n                        dev_name(&udc->dev)) == 0) {\n            /* (2.2) Match \u6210\u529f\uff0c\u5bf9 Device \u548c Driver \u8fdb\u884c bind() */\n            ret = udc_bind_to_driver(udc, driver);\n            if (ret != -EPROBE_DEFER)\n                /* (2.3) Driver Match \u6210\u529f\u540e\uff0c\u4ecepending\u94fe\u8868\u5220\u9664 */\n                list_del_init(&driver->pending);\n            break;\n        }\n\n    return ret;\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u5728 Gadget Driver \u521b\u5efa\u65f6\uff0c\u9996\u5148\u5c1d\u8bd5\u548c ",(0,i.jsx)(n.code,{children:"udc_list"})," \u94fe\u8868\u4e2d\u7684 Device \u8fdb\u884c match()\uff0cmatch() \u4e0d\u6210\u529f\u5219\u628a Driver \u52a0\u5165\u5230 ",(0,i.jsx)(n.code,{children:"gadget_driver_pending_list"})," \u94fe\u8868\u4e2d:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'gadget_dev_desc_UDC_store() \u2192 usb_gadget_probe_driver():\n\nint usb_gadget_probe_driver(struct usb_gadget_driver *driver)\n{\n    struct usb_udc          *udc = NULL;\n    int                     ret = -ENODEV;\n\n    if (!driver || !driver->bind || !driver->setup)\n        return -EINVAL;\n\n    mutex_lock(&udc_lock);\n    /* (1.1) \u5982\u679c Driver \u6709 udc_name\uff0c\u5c1d\u8bd5\u548c udc_list \u94fe\u8868\u4e2d Device \u7684 Name \u8fdb\u884c match()  */\n    if (driver->udc_name) {\n        list_for_each_entry(udc, &udc_list, list) {\n            ret = strcmp(driver->udc_name, dev_name(&udc->dev));\n            if (!ret)\n                break;\n        }\n        if (ret)\n            ret = -ENODEV;\n        else if (udc->driver)\n            ret = -EBUSY;\n        else\n            goto found;\n    /* (1.2) \u5982\u679c Driver \u6ca1\u6709 udc_name\uff0c\u5c1d\u8bd5\u9002\u914d udc_list \u94fe\u8868\u4e2d\u7b2c\u4e00\u4e2a\u6ca1\u6709\u9002\u914d\u7684 Device */\n    } else {\n        list_for_each_entry(udc, &udc_list, list) {\n            /* For now we take the first one */\n            if (!udc->driver)\n                goto found;\n        }\n    }\n\n    if (!driver->match_existing_only) {\n        /* (2) \u5982\u679c\u6ca1\u6709 match() \u6210\u529f\uff0c\u5219\u628a Driver \u52a0\u5165\u5230 pending \u94fe\u8868 */\n        list_add_tail(&driver->pending, &gadget_driver_pending_list);\n        pr_info("udc-core: couldn\'t find an available UDC - added [%s] to list of pending drivers\\n",\n            driver->function);\n        ret = 0;\n    }\n\n    mutex_unlock(&udc_lock);\n    if (ret)\n        pr_warn("udc-core: couldn\'t find an available UDC or it\'s busy\\n");\n    return ret;\nfound:\n    /* (3) \u5982\u679c Match \u6210\u529f\uff0c\u5bf9 Device \u548c Driver \u8fdb\u884c bind() */\n    ret = udc_bind_to_driver(udc, driver);\n    mutex_unlock(&udc_lock);\n    return ret;\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"\u5728 Device \u548c Driver Match \u6210\u529f\u65f6\u7684 bind() \u52a8\u4f5c\uff1a"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *driver)\n{\n    int ret;\n\n    dev_dbg(&udc->dev, "registering UDC driver [%s]\\n",\n            driver->function);\n\n    /* (1) \u6570\u636e\u6210\u5458\u7684\u8d4b\u503c */\n    udc->driver = driver;\n    udc->dev.driver = &driver->driver;\n    udc->gadget->dev.driver = &driver->driver;\n\n    usb_gadget_udc_set_speed(udc, driver->max_speed);\n\n    /* (2) \u8c03\u7528 Gadget Driver \u7684 bind() \u51fd\u6570 */\n    ret = driver->bind(udc->gadget, driver);\n    if (ret)\n        goto err1;\n\n    /* (3) \u8c03\u7528 Gadget Device \u7684 start() \u51fd\u6570\n            udc->gadget->ops->udc_start(udc->gadget, udc->driver);\n    */\n    ret = usb_gadget_udc_start(udc);\n    if (ret) {\n        driver->unbind(udc->gadget);\n        goto err1;\n    }\n\n    /* (4) \u8c03\u7528 Gadget Device \u7684 pullup() \u51fd\u6570\n            gadget->ops->pullup(gadget, 1/0);\n    */\n    usb_udc_connect_control(udc);\n\n    kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\n    return 0;\n\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["\u6ce8\u610f\uff1a\u8fd9\u91cc\u548c\u4e00\u822c\u7684 Device \u548c Driver \u7684\u9002\u914d\u89c4\u5219\u6709\u4e9b\u4e0d\u4e00\u6837\u3002\u4e00\u822c\u7684\u89c4\u5219\u662f\u4e00\u4e2a Dirver \u53ef\u4ee5\u9002\u914d\u591a\u4e2a Device\uff0c\u800c\u4e00\u4e2a Device \u53ea\u80fd\u9002\u914d\u4e00\u4e2a Driver\u3002\u800c\u8fd9\u91cc\u7684\u89c4\u5219\u662f\u4e00\u4e2a Gadget Device \u53ea\u80fd\u9002\u914d\u4e00\u4e2a Gadget Driver\uff0c\u800c\u4e00\u4e2a Gadget Driver \u53ea\u80fd\u9002\u914d\u4e00\u4e2a Gadget Device\u3002 Gadget Driver \u4ee3\u8868\u7684\u662f\u4e00\u4e2a ",(0,i.jsx)(n.code,{children:"Composite Device"}),"\u3002"]}),"\n",(0,i.jsx)(n.h4,{id:"622-gadget-device",children:"6.2.2. Gadget Device"}),"\n",(0,i.jsx)(n.p,{children:"\u4e0a\u4e00\u8282\u8bf4\u8fc7 Gadget Device \u7531 UDC Driver \u521b\u5efa\u3002"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"dwc2_driver_probe() \u2192 usb_add_gadget_udc() \u2192 usb_add_gadget_udc_release() \u2192 usb_add_gadget()\n"})}),"\n",(0,i.jsx)(n.p,{children:"Gadget Device \u7684\u4e3b\u8981\u4f5c\u7528\u662f\u63d0\u4f9b\u4e86 Endpoint \u8d44\u6e90\uff0c\u4f9b Function Layer \u4f7f\u7528\u6807\u51c6\u7684 Gadget API \u6765\u8fdb\u884c\u8bbf\u95ee\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"6221-endpoint-alloc",children:"6.2.2.1. Endpoint Alloc"}),"\n",(0,i.jsx)(n.p,{children:"UDC Driver \u5728\u8c03\u7528 usb_add_gadget_udc() \u6ce8\u518c Gadget Device \u4e4b\u524d\uff0c\u521d\u59cb\u5316\u4e86 Gadget \u7684 Endpoint \u8d44\u6e90\u94fe\u8868\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"dwc2_driver_probe() \u2192 dwc2_gadget_init():\n\nint dwc2_gadget_init(struct dwc2_hsotg *hsotg)\n{\n\n    /* (1) \u521d\u59cb\u5316 Gadget Device \u7684 Endpoint \u8d44\u6e90\u94fe\u8868\u4e3a\u7a7a  */\n    INIT_LIST_HEAD(&hsotg->gadget.ep_list);\n    hsotg->gadget.ep0 = &hsotg->eps_out[0]->ep;\n\n\n    /* initialise the endpoints now the core has been initialised */\n    /* (2) \u521d\u59cb\u5316 UDC \u62e5\u6709\u7684 Endpoint\uff0c\u52a0\u5165\u5230 Gadget Device \u7684 Endpoint \u8d44\u6e90\u94fe\u8868\u4e2d */\n    for (epnum = 0; epnum < hsotg->num_of_eps; epnum++) {\n        if (hsotg->eps_in[epnum])\n            dwc2_hsotg_initep(hsotg, hsotg->eps_in[epnum],\n                    epnum, 1);\n        if (hsotg->eps_out[epnum])\n            dwc2_hsotg_initep(hsotg, hsotg->eps_out[epnum],\n                    epnum, 0);\n    }\n\n}\n\n\u2193\n\nstatic void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,\n                struct dwc2_hsotg_ep *hs_ep,\n                    int epnum,\n                    bool dir_in)\n{\n\n\n    INIT_LIST_HEAD(&hs_ep->queue);\n    INIT_LIST_HEAD(&hs_ep->ep.ep_list);\n\n    /* add to the list of endpoints known by the gadget driver */\n    /* (2.1) UDC \u4e2d\u9664\u4e86 endpoint0 \u4ee5\u5916\uff0c\u5176\u4ed6\u7684 endpoint \u90fd\u52a0\u5165\u5230Gadget Device \u7684 Endpoint \u8d44\u6e90\u94fe\u8868 `gadget.ep_list` \u4e2d\n            endpoint0 \u7684\u64cd\u4f5c\u7531 UDC \u9a71\u52a8\u81ea\u5df1\u6765\u5904\u7406\n    */\n    if (epnum)\n        list_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);\n\n    /* (2.2) \u521d\u59cb\u5316 endpoint \u7684\u7ed3\u6784\u4f53\u6210\u5458 */\n    hs_ep->parent = hsotg;\n    hs_ep->ep.name = hs_ep->name;\n\n    if (hsotg->params.speed == DWC2_SPEED_PARAM_LOW)\n        usb_ep_set_maxpacket_limit(&hs_ep->ep, 8);\n    else\n        usb_ep_set_maxpacket_limit(&hs_ep->ep,\n                    epnum ? 1024 : EP0_MPS_LIMIT);\n\n    /* (2.3) endpoint \u6700\u91cd\u8981\u7684\u7ed3\u6784\u4f53\u6210\u5458\uff0cendpoint \u64cd\u4f5c\u51fd\u6570\u96c6\n        endpoint \u7684\u76f8\u5173\u64cd\u4f5c\u6700\u540e\u8c03\u7528\u5230\u8fd9\u4e9b\u51fd\u6570\u4e0a\n    */\n    hs_ep->ep.ops = &dwc2_hsotg_ep_ops;\n\n    if (epnum == 0) {\n        hs_ep->ep.caps.type_control = true;\n    } else {\n        if (hsotg->params.speed != DWC2_SPEED_PARAM_LOW) {\n            hs_ep->ep.caps.type_iso = true;\n            hs_ep->ep.caps.type_bulk = true;\n        }\n        hs_ep->ep.caps.type_int = true;\n    }\n\n    if (dir_in)\n        hs_ep->ep.caps.dir_in = true;\n    else\n        hs_ep->ep.caps.dir_out = true;\n\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Gadget Device \u51c6\u5907\u597d\u4e86 Endpoint \u8d44\u6e90\u94fe\u8868\u4ee5\u540e\uff0c\u901a\u8fc7 usb_add_gadget_udc() \u6ce8\u518c\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5 Function Layer \u5c31\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 Gadget Api \u6765\u52a8\u6001\u5206\u914d Endpoint \u4e86\u3002\u4f8b\u5982\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static int\nacm_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\n    /* allocate instance-specific endpoints */\n    /* (1) \u4ece Gadget Device \u4e2d\u5206\u914d\u4e00\u4e2a in endpoint */\n    ep = usb_ep_autoconfig(cdev->gadget, &acm_fs_in_desc);\n    if (!ep)\n        goto fail;\n    acm->port.in = ep;\n\n    /* (2) \u4ece Gadget Device \u4e2d\u5206\u914d\u4e00\u4e2a out endpoint */\n    ep = usb_ep_autoconfig(cdev->gadget, &acm_fs_out_desc);\n    if (!ep)\n        goto fail;\n    acm->port.out = ep;\n\n    /* (3) \u4ece Gadget Device \u4e2d\u5206\u914d\u4e00\u4e2a notify endpoint */\n    ep = usb_ep_autoconfig(cdev->gadget, &acm_fs_notify_desc);\n    if (!ep)\n        goto fail;\n    acm->notify = ep;\n\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"\u5176\u4e2d\u901a\u8fc7 usb_ep_autoconfig() \u51fd\u6570\u4ece Gadget Device \u7684 Endpoint \u8d44\u6e90\u94fe\u8868\u4e2d\u5206\u914d\u7a7a\u95f2\u7684 endpoint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\function\\f_acm.c:\n\nusb_ep_autoconfig() \u2192 usb_ep_autoconfig_ss():\n\nstruct usb_ep *usb_ep_autoconfig_ss(\n    struct usb_gadget               *gadget,\n    struct usb_endpoint_descriptor  *desc,\n    struct usb_ss_ep_comp_descriptor *ep_comp\n)\n{\n    struct usb_ep   *ep;\n\n    if (gadget->ops->match_ep) {\n        ep = gadget->ops->match_ep(gadget, desc, ep_comp);\n        if (ep)\n            goto found_ep;\n    }\n\n    /* Second, look at endpoints until an unclaimed one looks usable */\n    /* (1) \u4ece Gadget Device \u7684 Endpoint \u8d44\u6e90\u94fe\u8868\u4e2d\u67e5\u627e\u4e00\u4e2a\u7a7a\u95f2\u7684(ep->claimed\u4e3a\u7a7a) \u4e14\u7b26\u5408\u8981\u6c42\u7684 endpoint  */\n    list_for_each_entry (ep, &gadget->ep_list, ep_list) {\n        if (usb_gadget_ep_match_desc(gadget, ep, desc, ep_comp))\n            goto found_ep;\n    }\n\n    /* Fail */\n    return NULL;\nfound_ep:\n\n    ...\n\n    ep->address = desc->bEndpointAddress;\n    ep->desc = NULL;\n    ep->comp_desc = NULL;\n    /* (2) \u8bbe\u7f6e endpoint \u4e3a\u5df2\u5206\u914d */\n    ep->claimed = true;\n    return ep;\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"6222-endpoint-access",children:"6.2.2.2. EndPoint Access"}),"\n",(0,i.jsxs)(n.p,{children:["Gadget Device \u4e0d\u4ec5\u4ec5\u4e3a Gadget Api \u63d0\u4f9b\u4e86\u5206\u914d endpoint \u7684\u652f\u6301\uff0c\u8fd8\u652f\u6301\u5bf9 endpoint \u6536\u53d1\u6570\u636e\u7684\u5e95\u5c42\u652f\u6301\u3002\u5728\u4e0a\u4e00\u8282\u7684 endpoint \u521d\u59cb\u5316\u65f6\uff0c\u5c31\u5df2\u7ecf\u8bbe\u7f6e endpoint \u7684\u64cd\u4f5c\u51fd\u6570\u96c6 ",(0,i.jsx)(n.code,{children:"dwc2_hsotg_ep_ops"})," \uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"dwc2_driver_probe() \u2192 dwc2_gadget_init() \u2192 dwc2_hsotg_initep():\n\nstatic void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,\n                struct dwc2_hsotg_ep *hs_ep,\n                    int epnum,\n                    bool dir_in)\n{\n\n    /* (2.3) endpoint \u6700\u91cd\u8981\u7684\u7ed3\u6784\u4f53\u6210\u5458\uff0cendpoint \u64cd\u4f5c\u51fd\u6570\u96c6\n        endpoint \u7684\u76f8\u5173\u64cd\u4f5c\u6700\u540e\u8c03\u7528\u5230\u8fd9\u4e9b\u51fd\u6570\u4e0a\n    */\n    hs_ep->ep.ops = &dwc2_hsotg_ep_ops;\n\n}\n\n\u2193\n\nstatic const struct usb_ep_ops dwc2_hsotg_ep_ops = {\n    .enable         = dwc2_hsotg_ep_enable,\n    .disable        = dwc2_hsotg_ep_disable_lock,\n    .alloc_request  = dwc2_hsotg_ep_alloc_request,\n    .free_request   = dwc2_hsotg_ep_free_request,\n    .queue          = dwc2_hsotg_ep_queue_lock,\n    .dequeue        = dwc2_hsotg_ep_dequeue,\n    .set_halt       = dwc2_hsotg_ep_sethalt_lock,\n    /* note, don't believe we have any call for the fifo routines */\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Gadget Api \u63d0\u4f9b\u4e86\u4ee5\u4e0b\u63a5\u53e3\u6765\u64cd\u4f5c endpoint \u8bfb\u5199\u6570\u636e\u3002\u5728 Host \u4fa7\u5bf9 endpoint \u8fdb\u884c\u4e00\u6b21\u64cd\u4f5c\u8bf7\u6c42\u7684\u6570\u636e\u7ed3\u6784\u662f ",(0,i.jsx)(n.code,{children:"struct urb"})," \uff0c\u800c\u5728 Device \u4fa7\u4e5f\u6709\u7c7b\u4f3c\u7684\u6570\u636e\u7ed3\u6784\u79f0\u4e3a ",(0,i.jsx)(n.code,{children:"struct usb_request"})," \uff0c\u5bf9 endpoint \u7684\u6570\u636e\u8bfb\u5199\u5c31\u662f\u56f4\u7ed5 ",(0,i.jsx)(n.code,{children:"struct usb_request"})," \u5c55\u5f00\u7684\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\function\\f_acm.c:\n\nstatic int acm_cdc_notify(struct f_acm *acm, u8 type, u16 value,\n        void *data, unsigned length)\n{\n    struct usb_ep                   *ep = acm->notify;\n    struct usb_request              *req;\n    struct usb_cdc_notification     *notify;\n    const unsigned                  len = sizeof(*notify) + length;\n    void                            *buf;\n    int                             status;\n\n    /* (1) \u521d\u59cb\u5316 `struct usb_request` \u6570\u636e\u7ed3\u6784 */\n    req = acm->notify_req;\n    acm->notify_req = NULL;\n    acm->pending = false;\n\n    req->length = len;\n    notify = req->buf;\n    buf = notify + 1;\n\n    notify->bmRequestType = USB_DIR_IN | USB_TYPE_CLASS\n            | USB_RECIP_INTERFACE;\n    notify->bNotificationType = type;\n    notify->wValue = cpu_to_le16(value);\n    notify->wIndex = cpu_to_le16(acm->ctrl_id);\n    notify->wLength = cpu_to_le16(length);\n    memcpy(buf, data, length);\n\n    /* ep_queue() can complete immediately if it fills the fifo... */\n    spin_unlock(&acm->lock);\n    /* (2) \u63d0\u4ea4 `usb_request` \u8bf7\u6c42\u5230 endpoint \u5904\u7406\u961f\u5217\u4e2d */\n    status = usb_ep_queue(ep, req, GFP_ATOMIC);\n    spin_lock(&acm->lock);\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5176\u4e2d usb_ep_queue() \u51fd\u6570\u5c31\u4f1a\u8c03\u7528 endpoint \u7684\u64cd\u4f5c\u51fd\u6570\u96c6 ",(0,i.jsx)(n.code,{children:"dwc2_hsotg_ep_ops"})," \u4e2d\u7684 ",(0,i.jsx)(n.code,{children:".queue"})," \u51fd\u6570\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"int usb_ep_queue(struct usb_ep *ep,\n                struct usb_request *req, gfp_t gfp_flags)\n{\n    int ret = 0;\n\n    if (WARN_ON_ONCE(!ep->enabled && ep->address)) {\n        ret = -ESHUTDOWN;\n        goto out;\n    }\n\n    /* (1) \u5b9e\u9645\u8c03\u7528 dwc2_hsotg_ep_queue_lock() */\n    ret = ep->ops->queue(ep, req, gfp_flags);\n\nout:\n    trace_usb_ep_queue(ep, req, ret);\n\n    return ret;\n}\n"})}),"\n",(0,i.jsx)(n.h5,{id:"6223-udc-control",children:"6.2.2.3. UDC Control"}),"\n",(0,i.jsx)(n.p,{children:"Gadget Device \u8fd8\u63d0\u4f9b\u4e86 UDC \u5c42\u7ea7\u7684\u4e00\u4e9b\u64cd\u4f5c\u51fd\u6570\uff0cUDC Driver \u5728\u8c03\u7528 usb_add_gadget_udc() \u6ce8\u518c Gadget Device \u4e4b\u524d\uff0c\u521d\u59cb\u5316\u4e86 Gadget \u7684 \u64cd\u4f5c\u51fd\u6570\u96c6\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"dwc2_driver_probe() \u2192 dwc2_gadget_init():\n\nint dwc2_gadget_init(struct dwc2_hsotg *hsotg)\n{\n\n    hsotg->gadget.max_speed = USB_SPEED_HIGH;\n    /* (1) \u521d\u59cb\u5316 Gadget Device \u7684\u64cd\u4f5c\u51fd\u6570\u96c6  */\n    hsotg->gadget.ops = &dwc2_hsotg_gadget_ops;\n    hsotg->gadget.name = dev_name(dev);\n    hsotg->remote_wakeup_allowed = 0;\n\n}\n\n\u2193\n\nstatic const struct usb_gadget_ops dwc2_hsotg_gadget_ops = {\n    .get_frame      = dwc2_hsotg_gadget_getframe,\n    .set_selfpowered        = dwc2_hsotg_set_selfpowered,\n    .udc_start              = dwc2_hsotg_udc_start,\n    .udc_stop               = dwc2_hsotg_udc_stop,\n    .pullup                 = dwc2_hsotg_pullup,\n    .vbus_session           = dwc2_hsotg_vbus_session,\n    .vbus_draw              = dwc2_hsotg_vbus_draw,\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"Gadget Api \u63d0\u4f9b\u4e86\u4e00\u4e9b\u5185\u90e8\u51fd\u6570\u6765\u8c03\u7528\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"static inline int usb_gadget_udc_start(struct usb_udc *udc)\n{\n    return udc->gadget->ops->udc_start(udc->gadget, udc->driver);\n}\n\nstatic inline void usb_gadget_udc_stop(struct usb_udc *udc)\n{\n    udc->gadget->ops->udc_stop(udc->gadget);\n}\n\nstatic inline void usb_gadget_udc_set_speed(struct usb_udc *udc,\n                        enum usb_device_speed speed)\n{\n    if (udc->gadget->ops->udc_set_speed) {\n        enum usb_device_speed s;\n\n        s = min(speed, udc->gadget->max_speed);\n        udc->gadget->ops->udc_set_speed(udc->gadget, s);\n    }\n}\n\nint usb_gadget_connect(struct usb_gadget *gadget)\n{\n    int ret = 0;\n\n    if (!gadget->ops->pullup) {\n        ret = -EOPNOTSUPP;\n        goto out;\n    }\n\n    if (gadget->deactivated) {\n        /*\n        * If gadget is deactivated we only save new state.\n        * Gadget will be connected automatically after activation.\n        */\n        gadget->connected = true;\n        goto out;\n    }\n\n    ret = gadget->ops->pullup(gadget, 1);\n    if (!ret)\n        gadget->connected = 1;\n\nout:\n    trace_usb_gadget_connect(gadget, ret);\n\n    return ret;\n}\n\nint usb_gadget_disconnect(struct usb_gadget *gadget)\n{\n    int ret = 0;\n\n    if (!gadget->ops->pullup) {\n        ret = -EOPNOTSUPP;\n        goto out;\n    }\n\n    if (!gadget->connected)\n        goto out;\n\n    if (gadget->deactivated) {\n        /*\n        * If gadget is deactivated we only save new state.\n        * Gadget will stay disconnected after activation.\n        */\n        gadget->connected = false;\n        goto out;\n    }\n\n    ret = gadget->ops->pullup(gadget, 0);\n    if (!ret) {\n        gadget->connected = 0;\n        gadget->udc->driver->disconnect(gadget);\n    }\n\nout:\n    trace_usb_gadget_disconnect(gadget, ret);\n\n    return ret;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"623-gadget-driver-configfs",children:"6.2.3. Gadget Driver (Configfs)"}),"\n",(0,i.jsx)(n.p,{children:"Gadget Device \u652f\u6491\u4e86\u6838\u5fc3 Gadget Api \u7684\u5b9e\u73b0\uff0c\u800c Function Layer \u53c8\u9700\u8981\u4f7f\u7528\u8fd9\u4e9b Api\u3002\u600e\u4e48\u6837\u5c06\u4e24\u8005\u9002\u914d\u8d77\u6765\uff1fGadget Driver \u5c31\u662f\u7528\u6765\u5b8c\u6210\u8fd9\u9879\u5de5\u4f5c\u7684\u3002"}),"\n",(0,i.jsx)(n.p,{children:"\u76ee\u524d\u5b58\u5728\u4e24\u79cd\u98ce\u683c\u7684 Gadget Driver\uff0c\u5176\u4e2d\u5305\u62ec\uff1a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Legacy\u3002\u8fd9\u662f\u65e9\u671f\u98ce\u683c\u7684 Gadget Driver\uff0c\u53ea\u80fd\u901a\u8fc7\u9759\u6001\u7f16\u8bd1\u7684\u65b9\u5f0f\u6307\u5b9a\u4f7f\u7528\u54ea\u4e9b Function\u3002"}),"\n",(0,i.jsx)(n.li,{children:"Configfs\u3002\u8fd9\u662f\u76ee\u524d\u6d41\u884c\u7684 Gadget Driver\uff0c\u53ef\u4ee5\u901a\u8fc7 configfs \u6587\u4ef6\u7cfb\u7edf\uff0c\u4e0d\u7528\u91cd\u65b0\u7f16\u8bd1\u5185\u6838\uff0c\u52a8\u6001\u7684\u914d\u7f6e\u9700\u8981\u4f7f\u7528\u7684 Function\u3002"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"\u6211\u4eec\u9996\u5148\u4ecb\u7ecd configfs \u98ce\u683c\u7684 Gadget Driver\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"6231-configfs-\u4f7f\u7528",children:"6.2.3.1. Configfs \u4f7f\u7528"}),"\n",(0,i.jsx)(n.p,{children:"\u9996\u5148\u4ece\u4f7f\u7528\u4e0a\u4f53\u9a8c\u4e00\u4e0b configfs \u7684\u4fbf\u6377\u3002\u4f8b\u5982\u521b\u5efa\u4e00\u4e2a ACM Function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'// 1\u3001\u6302\u8f7dconfigfs\u6587\u4ef6\u7cfb\u7edf\u3002\nmount -t configfs none /sys/kernel/config\ncd /sys/kernel/config/usb_gadget\n\n// 2\u3001\u521b\u5efag1\u76ee\u5f55\uff0c\u5b9e\u4f8b\u5316\u4e00\u4e2a\u65b0\u7684gadget\u6a21\u677f (composite device)\u3002\nmkdir g1\ncd g1\n\n// 3.1\u3001\u5b9a\u4e49USB\u4ea7\u54c1\u7684VID\u548cPID\u3002\necho "0x1d6b" > idVendor\necho "0x0104" > idProduct\n\n// 3.2\u3001\u5b9e\u4f8b\u5316\u82f1\u8bed\u8bed\u8a00ID\u3002(0x409\u662fUSB language ID \u7f8e\u56fd\u82f1\u8bed\uff0c\u4e0d\u662f\u4efb\u610f\u7684\uff0c\u53ef\u4ee5\u5728USBIF\u7f51\u7ad9\u4e0a\u4e0b\u8f7d\u6587\u6863\u67e5\u8be2\u3002)\nmkdir strings/0x409\nls strings/0x409/\n// 3.3\u3001\u5c06\u5f00\u53d1\u5546\u3001\u4ea7\u54c1\u548c\u5e8f\u5217\u53f7\u5b57\u7b26\u4e32\u5199\u5165\u5185\u6838\u3002\necho "0123456789" > strings/0x409/serialnumber\necho "AAAA Inc." > strings/0x409/manufacturer\necho "Bar Gadget" > strings/0x409/product\n\n// 4\u3001\u521b\u5efa `Function` \u529f\u80fd\u5b9e\u4f8b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e00\u4e2a\u529f\u80fd\u5982\u679c\u6709\u591a\u4e2a\u5b9e\u4f8b\u7684\u8bdd\uff0c\u6269\u5c55\u540d\u5fc5\u987b\u7528\u6570\u5b57\u7f16\u53f7\u3002\nmkdir functions/acm.GS0\n\n// 5.1\u3001\u521b\u5efa\u4e00\u4e2aUSB `Configuration` \u914d\u7f6e\u5b9e\u4f8b\uff1a\nmkdir configs/c.1\nls configs/c.1\n// 5.2\u3001\u5b9a\u4e49\u914d\u7f6e\u63cf\u8ff0\u7b26\u4f7f\u7528\u7684\u5b57\u7b26\u4e32\nmkdir configs/c.1/strings/0x409\nls configs/c.1/strings/0x409/\necho "ACM" > configs/c.1/strings/0x409/configuration\n\n// 6\u3001\u6346\u7ed1\u529f\u80fd `Function` \u5b9e\u4f8b\u5230 `Configuration` \u914d\u7f6ec.1\nln -s functions/acm.GS0 configs/c.1\n\n// 7.1\u3001\u67e5\u627e\u672c\u673a\u53ef\u83b7\u5f97\u7684UDC\u5b9e\u4f8b (\u5373 gadget device)\n# ls /sys/class/udc/\n10200000.usb\n// 7.2\u3001\u5c06gadget\u9a71\u52a8\u6ce8\u518c\u5230UDC\u4e0a\uff0c\u63d2\u4e0aUSB\u7ebf\u5230\u7535\u8111\u4e0a\uff0c\u7535\u8111\u5c31\u4f1a\u679a\u4e3eUSB\u8bbe\u5907\u3002\necho "10200000.usb" > UDC\n'})}),"\n",(0,i.jsx)(n.h5,{id:"6232-configfs-\u5c42\u6b21\u7ed3\u6784",children:"6.2.3.2. Configfs \u5c42\u6b21\u7ed3\u6784"}),"\n",(0,i.jsx)(n.p,{children:"configfs \u5e76\u4e0d\u662f gadget \u4e13\u7528\u7684\uff0c\u5b83\u662f\u4e00\u4e2a\u901a\u7528\u6587\u4ef6\u7cfb\u7edf\uff0c\u65b9\u4fbf\u7528\u6237\u901a\u8fc7\u6587\u4ef6\u7cfb\u7edf\u521b\u5efa\u6587\u4ef6\u5939\u3001\u6587\u4ef6\u7684\u65b9\u5f0f\u6765\u521b\u5efa\u5185\u6838\u5bf9\u8c61\u3002"}),"\n",(0,i.jsxs)(n.p,{children:["configfs \u662f\u5f88\u597d\u7406\u89e3\u7684\uff0c ",(0,i.jsx)(n.code,{children:"struct config_group"})," \u76f8\u5f53\u4e8e\u4e00\u4e2a\u6587\u4ef6\u5939\uff0c ",(0,i.jsx)(n.code,{children:"struct config_item_type"})," \u662f\u8fd9\u4e2a\u6587\u4ef6\u5939\u7684\u5c5e\u6027\u96c6\u3002\u5176\u4e2d ",(0,i.jsx)(n.code,{children:"config_item_type->ct_group_ops->make_group()/drop_item()"})," \u5b9a\u4e49\u4e86\u521b\u5efa/\u9500\u6bc1\u4e0b\u4e00\u5c42\u5b50\u6587\u4ef6\u5939\u7684\u65b9\u6cd5\uff0c ",(0,i.jsx)(n.code,{children:"config_item_type->ct_attrs"})," \u5b9a\u4e49\u4e86\u5b50\u6587\u4ef6\u548c\u76f8\u5173\u64cd\u4f5c\u51fd\u6570\u3002"]}),"\n",(0,i.jsxs)(n.p,{children:["\u6211\u4eec\u901a\u8fc7\u89e3\u6790 ",(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\configfs.c"})," \u6587\u4ef6\u6765\u6df1\u5165\u7406\u89e3 ",(0,i.jsx)(n.code,{children:"configfs"})," \u7684\u4f7f\u7528\u65b9\u6cd5\uff1a"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u9996\u5148\u521b\u5efa\u9996\u5c42\u6587\u4ef6\u5939 ",(0,i.jsx)(n.code,{children:"/sys/kernel/config/usb_gadget"})," \uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static struct configfs_group_operations gadgets_ops = {\n    .make_group     = &gadgets_make,\n    .drop_item      = &gadgets_drop,\n};\n\nstatic const struct config_item_type gadgets_type = {\n    .ct_group_ops   = &gadgets_ops,\n    .ct_owner       = THIS_MODULE,\n};\n\nstatic struct configfs_subsystem gadget_subsys = {\n    .su_group = {\n        .cg_item = {\n            .ci_namebuf = "usb_gadget",\n            .ci_type = &gadgets_type,\n        },\n    },\n    .su_mutex = __MUTEX_INITIALIZER(gadget_subsys.su_mutex),\n};\n\nstatic int __init gadget_cfs_init(void)\n{\n    int ret;\n\n    config_group_init(&gadget_subsys.su_group);\n\n    ret = configfs_register_subsystem(&gadget_subsys);\n    return ret;\n}\nmodule_init(gadget_cfs_init);\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u521b\u5efa ",(0,i.jsx)(n.code,{children:"/sys/kernel/config/usb_gadget/g1"})," \uff0c\u76f8\u5f53\u4e8e\u521b\u5efa\u4e00\u4e2a\u5168\u65b0\u7684 ",(0,i.jsx)(n.code,{children:"composite device"}),"\u3002\u4f1a\u8c03\u7528\u9876\u5c42 ",(0,i.jsx)(n.code,{children:"struct config_group"})," \u7684 ",(0,i.jsx)(n.code,{children:"config_item_type->ct_group_ops->make_group()"})," \u51fd\u6570\uff0c\u5373 ",(0,i.jsx)(n.code,{children:"gadgets_make()"})," \uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static struct config_group *gadgets_make(\n        struct config_group *group,\n        const char *name)\n{\n    struct gadget_info *gi;\n\n    gi = kzalloc(sizeof(*gi), GFP_KERNEL);\n    if (!gi)\n        return ERR_PTR(-ENOMEM);\n\n    /* (1) \u521b\u5efa\u9876\u5c42\u6587\u4ef6\u5939 `/sys/kernel/config/usb_gadget/g1` \u5bf9\u5e94\u7684 `struct config_group` \u7ed3\u6784\n            `/sys/kernel/config/usb_gadget/g1` \u4e0b\u5bf9\u5e94\u4e0d\u5c11\u5b50\u6587\u4ef6\uff0c\u5728 gadget_root_type.ct_attrs \u4e2d\u5b9a\u4e49\uff0c\u5373 `gadget_root_attrs`:\n            static struct configfs_attribute *gadget_root_attrs[] = {\n                &gadget_dev_desc_attr_bDeviceClass,\n                &gadget_dev_desc_attr_bDeviceSubClass,\n                &gadget_dev_desc_attr_bDeviceProtocol,\n                &gadget_dev_desc_attr_bMaxPacketSize0,\n                &gadget_dev_desc_attr_idVendor,\n                &gadget_dev_desc_attr_idProduct,\n                &gadget_dev_desc_attr_bcdDevice,\n                &gadget_dev_desc_attr_bcdUSB,\n                &gadget_dev_desc_attr_UDC,\n                &gadget_dev_desc_attr_max_speed,\n                NULL,\n            };\n    */\n    config_group_init_type_name(&gi->group, name, &gadget_root_type);\n\n    /* (2) \u521b\u5efa\u5b50\u6587\u4ef6\u5939 `/sys/kernel/config/usb_gadget/g1/functions`\n            `functions_type` \u4e2d\u5b9a\u4e49\u4e86\u8fdb\u4e00\u6b65\u521b\u5efa\u5b50\u6587\u4ef6\u5939\u7684\u64cd\u4f5c\u51fd\u6570\n    */\n    config_group_init_type_name(&gi->functions_group, "functions",\n            &functions_type);\n    configfs_add_default_group(&gi->functions_group, &gi->group);\n\n    /* (3) \u521b\u5efa\u5b50\u6587\u4ef6\u5939 `/sys/kernel/config/usb_gadget/g1/configs`\n            `config_desc_type` \u4e2d\u5b9a\u4e49\u4e86\u8fdb\u4e00\u6b65\u521b\u5efa\u5b50\u6587\u4ef6\u5939\u7684\u64cd\u4f5c\u51fd\u6570\n    */\n    config_group_init_type_name(&gi->configs_group, "configs",\n            &config_desc_type);\n    configfs_add_default_group(&gi->configs_group, &gi->group);\n\n    /* (4) \u521b\u5efa\u5b50\u6587\u4ef6\u5939 `/sys/kernel/config/usb_gadget/g1/strings`\n            `gadget_strings_strings_type` \u4e2d\u5b9a\u4e49\u4e86\u8fdb\u4e00\u6b65\u521b\u5efa\u5b50\u6587\u4ef6\u5939\u7684\u64cd\u4f5c\u51fd\u6570\n    */\n    config_group_init_type_name(&gi->strings_group, "strings",\n            &gadget_strings_strings_type);\n    configfs_add_default_group(&gi->strings_group, &gi->group);\n\n    /* (5) \u521b\u5efa\u5b50\u6587\u4ef6\u5939 `/sys/kernel/config/usb_gadget/g1/os_desc`\n            `os_desc_type` \u4e2d\u5b9a\u4e49\u4e86\u8fdb\u4e00\u6b65\u521b\u5efa\u54ea\u4e9b\u5b50\u6587\u4ef6\n    */\n    config_group_init_type_name(&gi->os_desc_group, "os_desc",\n            &os_desc_type);\n    configfs_add_default_group(&gi->os_desc_group, &gi->group);\n\n    /* (6) `configfs.c` \u7684\u76ee\u7684\u5f88\u660e\u786e\u5c31\u662f\u521b\u5efa\u4e00\u4e2a `composite device`\n            \u7531\u7528\u6237\u6dfb\u52a0\u548c\u914d\u7f6e\u8fd9\u4e2a `device` \u5f53\u4e2d\u7684\u591a\u4e2a `interface` \u5373 `function`\n    */\n    gi->composite.bind = configfs_do_nothing;\n    gi->composite.unbind = configfs_do_nothing;\n    gi->composite.suspend = NULL;\n    gi->composite.resume = NULL;\n    gi->composite.max_speed = USB_SPEED_SUPER_PLUS;\n\n    spin_lock_init(&gi->spinlock);\n    mutex_init(&gi->lock);\n    INIT_LIST_HEAD(&gi->string_list);\n    INIT_LIST_HEAD(&gi->available_func);\n\n    composite_init_dev(&gi->cdev);\n    gi->cdev.desc.bLength = USB_DT_DEVICE_SIZE;\n    gi->cdev.desc.bDescriptorType = USB_DT_DEVICE;\n    gi->cdev.desc.bcdDevice = cpu_to_le16(get_default_bcdDevice());\n\n    gi->composite.gadget_driver = configfs_driver_template;\n\n    gi->composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);\n    gi->composite.name = gi->composite.gadget_driver.function;\n\n    if (!gi->composite.gadget_driver.function)\n        goto err;\n\n    return &gi->group;\nerr:\n    kfree(gi);\n    return ERR_PTR(-ENOMEM);\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\u521b\u5efa ",(0,i.jsx)(n.code,{children:"/sys/kernel/config/usb_gadget/g1/functions/acm.GS0"}),"\u3002\u4f1a\u8c03\u7528 ",(0,i.jsx)(n.code,{children:"functions_type"})," \u4e2d\u5b9a\u4e49\u7684 function_make() \u51fd\u6570\uff1a"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'static struct config_group *function_make(\n        struct config_group *group,\n        const char *name)\n{\n    struct gadget_info *gi;\n    struct usb_function_instance *fi;\n    char buf[MAX_NAME_LEN];\n    char *func_name;\n    char *instance_name;\n    int ret;\n\n    ret = snprintf(buf, MAX_NAME_LEN, "%s", name);\n    if (ret >= MAX_NAME_LEN)\n        return ERR_PTR(-ENAMETOOLONG);\n\n    /* (1) \u628a `acm.GS0` \u5206\u5272\u6210\u4e24\u90e8\u5206\uff1a\n            func_name = `acm`\n            instance_name = `GS0`\n    */\n    func_name = buf;\n    instance_name = strchr(func_name, \'.\');\n    if (!instance_name) {\n        pr_err("Unable to locate . in FUNC.INSTANCE\\n");\n        return ERR_PTR(-EINVAL);\n    }\n    *instance_name = \'\\0\';\n    instance_name++;\n\n    /* (2) \u6839\u636e func_name \u5728\u5168\u5c40\u94fe\u8868\u4e2d\u67e5\u627e\u5bf9\u5e94 function\n            usb_get_function_instance() \u2192 try_get_usb_function_instance() \u2192 fd->alloc_inst() \u2192 acm_alloc_instance():\n            \u5e76\u8c03\u7528 usb_function_driver->alloc_inst() \u5206\u914d\u4e00\u4e2a function \u5b9e\u4f8b\n    */\n    fi = usb_get_function_instance(func_name);\n    if (IS_ERR(fi))\n        return ERR_CAST(fi);\n\n    /* (3) \u521d\u59cb\u5316 function \u5b9e\u4f8b */\n    ret = config_item_set_name(&fi->group.cg_item, "%s", name);\n    if (ret) {\n        usb_put_function_instance(fi);\n        return ERR_PTR(ret);\n    }\n    if (fi->set_inst_name) {\n        ret = fi->set_inst_name(fi, instance_name);\n        if (ret) {\n            usb_put_function_instance(fi);\n            return ERR_PTR(ret);\n        }\n    }\n\n    gi = container_of(group, struct gadget_info, functions_group);\n\n    mutex_lock(&gi->lock);\n    /* (4) \u5c06 function \u5b9e\u4f8b\u6302\u8f7d\u5230 composite device \u7684 function \u94fe\u8868\u5f53\u4e2d\u53bb */\n    list_add_tail(&fi->cfs_list, &gi->available_func);\n    mutex_unlock(&gi->lock);\n    return &fi->group;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 ",(0,i.jsx)(n.code,{children:"ln -s functions/acm.GS0 configs/c.1"})," \u65f6\u7ed9 function \u5b9e\u4f8b\u5b89\u88c5\u5b9e\u9645\u7684\u51fd\u6570\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'config_usb_cfg_link() \u2192 usb_get_function() \u2192 fi->fd->alloc_func() \u2192 acm_alloc_func()\uff1a\n\nstatic struct usb_function *acm_alloc_func(struct usb_function_instance *fi)\n{\n    struct f_serial_opts *opts;\n    struct f_acm *acm;\n\n    /* (2.1) \u5bf9\u5e94\u5206\u914d\u4e00\u4e2a func \u5b9e\u4f8b */\n    acm = kzalloc(sizeof(*acm), GFP_KERNEL);\n    if (!acm)\n        return ERR_PTR(-ENOMEM);\n\n    spin_lock_init(&acm->lock);\n\n    /* (2.2) \u521d\u59cb\u5316 func \u5b9e\u4f8b\u7684\u6210\u5458\u51fd\u6570 */\n    acm->port.connect = acm_connect;\n    acm->port.disconnect = acm_disconnect;\n    acm->port.send_break = acm_send_break;\n\n    acm->port.func.name = "acm";\n    acm->port.func.strings = acm_strings;\n    /* descriptors are per-instance copies */\n    acm->port.func.bind = acm_bind;\n    acm->port.func.set_alt = acm_set_alt;\n    acm->port.func.setup = acm_setup;\n    acm->port.func.disable = acm_disable;\n\n    opts = container_of(fi, struct f_serial_opts, func_inst);\n    acm->port_num = opts->port_num;\n    acm->port.func.unbind = acm_unbind;\n    acm->port.func.free_func = acm_free_func;\n    acm->port.func.resume = acm_resume;\n    acm->port.func.suspend = acm_suspend;\n\n    return &acm->port.func;\n}\n'})}),"\n",(0,i.jsx)(n.h5,{id:"6233-gadget-driver",children:"6.2.3.3. Gadget Driver"}),"\n",(0,i.jsx)(n.p,{children:"Configfs \u98ce\u683c\u7684 gadget driver \u7684\u5b9a\u4e49\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'drivers\\usb\\gadget\\configfs.c\uff1a\n\nstatic const struct usb_gadget_driver configfs_driver_template = {\n    .bind           = configfs_composite_bind,\n    .unbind         = configfs_composite_unbind,\n\n    .setup          = configfs_composite_setup,\n    .reset          = configfs_composite_disconnect,\n    .disconnect     = configfs_composite_disconnect,\n\n    .suspend        = configfs_composite_suspend,\n    .resume         = configfs_composite_resume,\n\n    .max_speed      = USB_SPEED_SUPER_PLUS,\n    .driver = {\n        .owner          = THIS_MODULE,\n        .name               = "configfs-gadget",\n    },\n    .match_existing_only = 1,\n};\n'})}),"\n",(0,i.jsxs)(n.p,{children:["\u5728\u8c03\u7528 ",(0,i.jsx)(n.code,{children:'echo "/sys/class/udc/10200000.usb" > /sys/kernel/config/usb_gadget/g1/UDC'})," \u65f6\uff0c\u5c06\u4e0a\u8ff0 ",(0,i.jsx)(n.code,{children:"gadget driver"})," \u8fdb\u884c\u6ce8\u518c\uff0c\u548c UDC \u5df2\u7ecf\u6ce8\u518c\u597d\u7684 ",(0,i.jsx)(n.code,{children:"gadget device"})," \u8fdb\u884c\u52a8\u6001\u9002\u914d\u3002"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"gadget_dev_desc_UDC_store() \u2192 usb_gadget_probe_driver(&gi->composite.gadget_driver) \u2192 udc_bind_to_driver()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u672c\u8d28\u4e0a\u662f \u4f7f\u7528 configfs \u521b\u5efa\u597d\u7684 ",(0,i.jsx)(n.code,{children:"composite device"})," \u548c ",(0,i.jsx)(n.code,{children:"gadget device"})," \u8fdb\u884c\u7ed1\u5b9a\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"gadget_dev_desc_UDC_store() \u2192 usb_gadget_probe_driver() \u2192 udc_bind_to_driver() \u2192 configfs_composite_bind() \u2192 usb_add_function() \u2192 function->bind() \u2192 acm_bind():\n\nstatic int\nacm_bind(struct usb_configuration *c, struct usb_function *f)\n{\n    /* (1) \u8fd9\u6837 function \u5b9e\u4f8b\u548c gadget device \u8fdb\u884c\u4e86\u7ed1\u5b9a */\n    struct usb_composite_dev *cdev = c->cdev;\n    struct f_acm            *acm = func_to_acm(f);\n\n    /* allocate instance-specific endpoints */\n    /* (2) function \u5b9e\u4f8b\u53ef\u4ee5\u4ece gadget device \u4e2d\u5206\u914d\u5f97\u5230 endpoint */\n    ep = usb_ep_autoconfig(cdev->gadget, &acm_fs_in_desc);\n    if (!ep)\n        goto fail;\n    acm->port.in = ep;\n\n    ep = usb_ep_autoconfig(cdev->gadget, &acm_fs_out_desc);\n    if (!ep)\n        goto fail;\n    acm->port.out = ep;\n\n    ep = usb_ep_autoconfig(cdev->gadget, &acm_fs_notify_desc);\n    if (!ep)\n        goto fail;\n    acm->notify = ep;\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u4f46\u662f bind() \u4ee5\u540e function \u5b9e\u4f8b\u53ea\u662f\u5206\u914d\u4e86 endpoint \u8d44\u6e90\u8fd8\u6ca1\u6709\u88ab\u542f\u52a8\uff0c\u56e0\u4e3a Device \u662f\u88ab\u52a8\u72b6\u6001\uff0c\u53ea\u6709\u8fde\u4e0a Host\uff0c\u88ab Host ",(0,i.jsx)(n.code,{children:"Set Configuration"})," \u64cd\u4f5c\u4ee5\u540e\u3002\u67d0\u4e00\u7ec4 ",(0,i.jsx)(n.code,{children:"Configuration"})," \u88ab\u914d\u7f6e\uff0c\u76f8\u5e94\u7684 ",(0,i.jsx)(n.code,{children:"Function \u5b9e\u4f8b"})," \u624d\u4f1a\u88ab\u542f\u7528\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'dwc2_hsotg_complete_setup() \u2192 dwc2_hsotg_process_control() \u2192 hsotg->driver->setup() \u2192 configfs_composite_setup() \u2192 composite_setup() \u2192 set_config() \u2192 f->set_alt() \u2192 acm_set_alt():\n\nstatic int acm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n    struct f_acm            *acm = func_to_acm(f);\n    struct usb_composite_dev *cdev = f->config->cdev;\n\n    /* we know alt == 0, so this is an activation or a reset */\n\n    /* (1) \u4f7f\u80fd endpoint\uff0c\u5e76\u4e14\u63d0\u4ea4 `struct usb_request` \u8bf7\u6c42  */\n    if (intf == acm->ctrl_id) {\n        if (acm->notify->enabled) {\n            dev_vdbg(&cdev->gadget->dev,\n                    "reset acm control interface %d\\n", intf);\n            usb_ep_disable(acm->notify);\n        }\n\n        if (!acm->notify->desc)\n            if (config_ep_by_speed(cdev->gadget, f, acm->notify))\n                return -EINVAL;\n\n        usb_ep_enable(acm->notify);\n\n    } else if (intf == acm->data_id) {\n        if (acm->notify->enabled) {\n            dev_dbg(&cdev->gadget->dev,\n                "reset acm ttyGS%d\\n", acm->port_num);\n            gserial_disconnect(&acm->port);\n        }\n        if (!acm->port.in->desc || !acm->port.out->desc) {\n            dev_dbg(&cdev->gadget->dev,\n                "activate acm ttyGS%d\\n", acm->port_num);\n            if (config_ep_by_speed(cdev->gadget, f,\n                        acm->port.in) ||\n                config_ep_by_speed(cdev->gadget, f,\n                        acm->port.out)) {\n                acm->port.in->desc = NULL;\n                acm->port.out->desc = NULL;\n                return -EINVAL;\n            }\n        }\n        gserial_connect(&acm->port, acm->port_num);\n\n    } else\n        return -EINVAL;\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"624-gadget-driver-legacy",children:"6.2.4. Gadget Driver (Legacy)"}),"\n",(0,i.jsx)(n.p,{children:"\u5bf9\u4e8e Legacy Gadget Driver \u9a71\u52a8\u6765\u8bf4\uff0c\u76f8\u5f53\u4e8e Configfs Gadget Driver \u7684\u4e00\u4e2a\u7b80\u5316\u7248\u3002"}),"\n",(0,i.jsx)(n.h5,{id:"6241-gadget-drive",children:"6.2.4.1. Gadget Drive"}),"\n",(0,i.jsx)(n.p,{children:"Legacy \u98ce\u683c\u7684 gadget driver \u7684\u5b9a\u4e49\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"drivers\\usb\\gadget\\composite.c:\n\nstatic const struct usb_gadget_driver composite_driver_template = {\n    .bind           = composite_bind,\n    .unbind         = composite_unbind,\n\n    .setup          = composite_setup,\n    .reset          = composite_disconnect,\n    .disconnect     = composite_disconnect,\n\n    .suspend        = composite_suspend,\n    .resume         = composite_resume,\n\n    .driver = {\n        .owner              = THIS_MODULE,\n    },\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u9a71\u52a8\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6ce8\u518c\u51fd\u6570 usb_composite_probe()\uff0c\u4ee5\u4f9b ",(0,i.jsx)(n.code,{children:"composite device"})," \u6765\u8fdb\u884c\u8c03\u7528\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'int usb_composite_probe(struct usb_composite_driver *driver)\n{\n    struct usb_gadget_driver *gadget_driver;\n\n    if (!driver || !driver->dev || !driver->bind)\n        return -EINVAL;\n\n    if (!driver->name)\n        driver->name = "composite";\n\n    /* (1) \u628a\u4f20\u9012\u8fc7\u6765\u7684 `usb_composite_driver` \u5305\u88c5\u6210 `usb_gadget_driver` */\n    driver->gadget_driver = composite_driver_template;\n    gadget_driver = &driver->gadget_driver;\n\n    gadget_driver->function =  (char *) driver->name;\n    gadget_driver->driver.name = driver->name;\n    gadget_driver->max_speed = driver->max_speed;\n\n    /* (2) \u6ce8\u518c gadget driver\uff0c\u8ba9\u5176\u548c gadget device \u9002\u914d */\n    return usb_gadget_probe_driver(gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_probe);\n'})}),"\n",(0,i.jsx)(n.h5,{id:"6242-composite-device",children:"6.2.4.2. Composite Device"}),"\n",(0,i.jsxs)(n.p,{children:["\u6ca1\u6709\u4e86 configfs \u7531\u7528\u6237\u6765\u521b\u5efa ",(0,i.jsx)(n.code,{children:"composite device"})," \uff0c\u53ea\u80fd\u4f7f\u7528\u4e00\u4e2a\u6587\u4ef6\u6765\u521b\u5efa ",(0,i.jsx)(n.code,{children:"composite device"})," \u5b9a\u4e49\u5176\u4f7f\u7528\u54ea\u4e9b ",(0,i.jsx)(n.code,{children:"function"})," \u548c\u4e00\u7cfb\u5217\u914d\u7f6e\u3002\u4f8b\u5982\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'drivers\\usb\\gadget\\legacy\\acm_ms.c\n\nstatic struct usb_composite_driver acm_ms_driver = {\n    .name           = "g_acm_ms",\n    .dev            = &device_desc,\n    .max_speed      = USB_SPEED_SUPER,\n    .strings        = dev_strings,\n    .bind           = acm_ms_bind,\n    .unbind         = acm_ms_unbind,\n};\n\n/* (1) \u9a71\u52a8\u4e00\u5f00\u59cb\u5c31\u8c03\u7528 usb_composite_probe() \u6765\u6ce8\u518c acm_ms_driver\n        \u56e0\u4e3a acm_ms_driver \u6ca1\u6709\u6307\u5b9a udc_name \u6240\u4ee5\u53ea\u80fd\u9002\u914d\u7b2c\u4e00\u4e2a udc\n*/\nmodule_usb_composite_driver(acm_ms_driver);\n\n#define module_usb_composite_driver(__usb_composite_driver) \\\n    module_driver(__usb_composite_driver, usb_composite_probe, \\\n            usb_composite_unregister)\n'})}),"\n",(0,i.jsx)(n.p,{children:"\u5728 gadget driver \u9a71\u52a8\u9002\u914d\u540e\uff0c\u8c03\u7528 bind() \u51fd\u6570\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_gadget_probe_driver() \u2192 udc_bind_to_driver() \u2192 composite_bind() \u2192 acm_ms_bind()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 acm_ms_bind() \u51fd\u6570\u4e2d\u521b\u5efa ",(0,i.jsx)(n.code,{children:"composite device"})," \u7684 ",(0,i.jsx)(n.code,{children:"Configuration"})," \u548c ",(0,i.jsx)(n.code,{children:"Function/Interface"})," \uff0c\u5e76\u4e14\u548c Gadget Device / UDC \u8fdb\u884c\u7ed1\u5b9a\u3002"]}),"\n",(0,i.jsx)(n.p,{children:"\u5176\u4ed6\u64cd\u4f5c\u548c Configfs Gadget Driver \u7c7b\u4f3c\u3002"}),"\n",(0,i.jsx)(n.h3,{id:"63-usb-interface-layer",children:"6.3. USB Interface Layer"}),"\n",(0,i.jsx)(n.p,{children:"Linux \u4f7f\u7528 Function \u6765\u5b9e\u73b0 USB Interface \u7b49\u7ea7\u7684\u529f\u80fd\u3002"}),"\n",(0,i.jsx)(n.h4,{id:"631-function-\u6ce8\u518c",children:"6.3.1. Function \u6ce8\u518c"}),"\n",(0,i.jsxs)(n.p,{children:["\u5728 ",(0,i.jsx)(n.code,{children:"drivers/usb/gadget/function/"})," \u8def\u5f84\u4e0b\u6709\u4e00\u6279 Gadget Function \u7684\u5b9a\u4e49\uff1a"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ ls drivers/usb/gadget/function/f*\nf_acm.c  f_ecm.c  f_eem.c  f_fs.c  f_hid.c  f_loopback.c  f_mass_storage.c  f_mass_storage.h\nf_midi.c  f_ncm.c  f_obex.c  f_phonet.c  f_printer.c  f_rndis.c  f_serial.c  f_sourcesink.c\nf_subset.c  f_tcm.c  f_uac1.c  f_uac1_legacy.c  f_uac2.c  f_uvc.c  f_uvc.h\n"})}),"\n",(0,i.jsxs)(n.p,{children:["\u5927\u5bb6\u4f7f\u7528 ",(0,i.jsx)(n.code,{children:"DECLARE_USB_FUNCTION_INIT()"})," \u5b8f\u5b9a\u4e49\u6765\u8c03\u7528 usb_function_register() \u51fd\u6570\uff0c\u628a ",(0,i.jsx)(n.code,{children:"usb_function_driver"})," \u6ce8\u518c\u5230\u5168\u5c40\u94fe\u8868 ",(0,i.jsx)(n.code,{children:"func_list"})," \u4e2d\u3002\u7b49\u5f85 ",(0,i.jsx)(n.code,{children:"composite device"})," \u6765\u8fdb\u884c\u5b9e\u4f8b\u5316\u3002"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'DECLARE_USB_FUNCTION_INIT(acm, acm_alloc_instance, acm_alloc_func);\n\n#define DECLARE_USB_FUNCTION(_name, _inst_alloc, _func_alloc)               \\\n    static struct usb_function_driver _name ## usb_func = {         \\\n        .name = __stringify(_name),                         \\\n        .mod  = THIS_MODULE,                                        \\\n        .alloc_inst = _inst_alloc,                          \\\n        .alloc_func = _func_alloc,                          \\\n    };                                                              \\\n    MODULE_ALIAS("usbfunc:"__stringify(_name));\n\n#define DECLARE_USB_FUNCTION_INIT(_name, _inst_alloc, _func_alloc)  \\\n    DECLARE_USB_FUNCTION(_name, _inst_alloc, _func_alloc)           \\\n    static int __init _name ## mod_init(void)                       \\\n    {                                                               \\\n        return usb_function_register(&_name ## usb_func);   \\\n    }                                                               \\\n    static void __exit _name ## mod_exit(void)                      \\\n    {                                                               \\\n        usb_function_unregister(&_name ## usb_func);                \\\n    }                                                               \\\n    module_init(_name ## mod_init);                                 \\\n    module_exit(_name ## mod_exit)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"632-gadget-api",children:"6.3.2. Gadget API"}),"\n",(0,i.jsx)(n.p,{children:"\u5728 Function Layer \u4e3b\u8981\u4f7f\u7528\u4ee5\u4e0b Gadget Layer \u5c42\u63d0\u4f9b\u7684 API\uff1a"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"usb_ep_autoconfig()\nusb_ep_enable()\nusb_ep_disable()\nusb_ep_alloc_request()\nusb_ep_free_request()\nusb_ep_queue()\nusb_ep_dequeue()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"7-\u5e38\u89c1\u95ee\u9898",children:"7. \u5e38\u89c1\u95ee\u9898"}),"\n",(0,i.jsx)(n.h3,{id:"71-\u81ea\u52a8\u5207\u6362-hostdevice",children:"7.1. \u81ea\u52a8\u5207\u6362 Host/Device"}),"\n",(0,i.jsx)(n.p,{children:"\u8be5\u529f\u80fd\u662f\u5728\u7528\u6237\u6001\u624b\u52a8\u5207\u6362 USB \u7aef\u53e3\u4e3a Host \u6216\u8005 Device"}),"\n",(0,i.jsx)(n.h4,{id:"711-\u914d\u7f6e\u4fee\u6539",children:"7.1.1. \u914d\u7f6e\u4fee\u6539"}),"\n",(0,i.jsx)(n.p,{children:"\u5728 \u76f8\u5e94\u5de5\u7a0b\u7684 board.dts \u4e2d\u6253\u5f00 otg \u7684\u5b8f\uff0c\u5e76\u914d\u7f6e otg-mode\uff0c \u53ef\u9009\u503c\u4e3a"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"auto\uff1a \u901a\u8fc7\u786c\u4ef6\u7684 ID \u7ba1\u811a\u5207\u6362"}),"\n",(0,i.jsx)(n.li,{children:"host\uff1a \u9ed8\u8ba4\u914d\u7f6e\u4e3a host"}),"\n",(0,i.jsx)(n.li,{children:"device\uff1a \u9ed8\u8ba4\u914d\u7f6e\u4e3a device"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'#if 1\n&otg {\n       otg-mode = "device";    /* auto/host/device */\n       status = "okay";\n};\n'})}),"\n",(0,i.jsx)(n.h4,{id:"712-\u624b\u52a8\u5207\u6362",children:"7.1.2. \u624b\u52a8\u5207\u6362"}),"\n",(0,i.jsx)(n.p,{children:"\u901a\u8fc7\u4e0a\u8ff0\u914d\u7f6e\u6253\u5f00 otg mode \u540e\u5c31\u53ef\u4ee5\u5728\u63a7\u5236\u53f0\u901a\u8fc7 sysfs \u7684\u63a5\u53e3\u8fdb\u884c\u624b\u52a8\u5207\u6362"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"[aic@] #cat /sys/devices/platform/soc/soc\\:usb-otg/otg_mode                 //\u5f53\u524d\u6a21\u5f0f\n[aic@] #echo auto > /sys/devices/platform/soc/soc\\:usb-otg/otg_mode         //\u5207\u6362\u4e3a auto\n[aic@] #echo device > /sys/devices/platform/soc/soc\\:usb-otg/otg_mode       //\u5207\u6362\u4e3a device\n[aic@] #echo host > /sys/devices/platform/soc/soc\\:usb-otg/otg_mode         //\u5207\u6362\u4e3a host\n"})})]})}function a(e={}){const{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>t,a:()=>c});var i=s(7294);const d={},r=i.createContext(d);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);